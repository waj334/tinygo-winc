// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package types

/*
#include "../include/m2m_types.h"
#include "../include/socket.h"
#include "../include/m2m_socket_host_if.h"
#include "../include/m2m_hif.h"
#include "../include/ecc_types.h"
#include "../include/wdrv_winc_ssl.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocECPointMemory allocates memory for type C.tstrECPoint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECPointMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfECPointValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfECPointValue = unsafe.Sizeof([1]C.tstrECPoint{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ECPoint) Ref() *C.tstrECPoint {
	if x == nil {
		return nil
	}
	return x.ref5481a313
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ECPoint) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref5481a313)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ECPoint) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ECPoint) Free() {
	if x != nil && x.allocs5481a313 != nil {
		x.allocs5481a313.(*cgoAllocMap).Free()
		x.ref5481a313 = nil
	}
}

// NewECPointRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewECPointRef(ref unsafe.Pointer) *ECPoint {
	if ref == nil {
		return nil
	}
	obj := new(ECPoint)
	obj.ref5481a313 = (*C.tstrECPoint)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ECPoint) PassRef() (*C.tstrECPoint, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5481a313 != nil {
		return x.ref5481a313, nil
	}
	mem5481a313 := allocECPointMemory(1)
	ref5481a313 := (*C.tstrECPoint)(mem5481a313)
	allocs5481a313 := new(cgoAllocMap)
	allocs5481a313.Add(mem5481a313)

	var cXY_allocs *cgoAllocMap
	ref5481a313.XY, cXY_allocs = *(*[64]C.uint8_t)(unsafe.Pointer(&x.XY)), cgoAllocsUnknown
	allocs5481a313.Borrow(cXY_allocs)

	var cu16Size_allocs *cgoAllocMap
	ref5481a313.u16Size, cu16Size_allocs = (C.uint16_t)(x.U16Size), cgoAllocsUnknown
	allocs5481a313.Borrow(cu16Size_allocs)

	var cu16PrivKeyID_allocs *cgoAllocMap
	ref5481a313.u16PrivKeyID, cu16PrivKeyID_allocs = (C.uint16_t)(x.U16PrivKeyID), cgoAllocsUnknown
	allocs5481a313.Borrow(cu16PrivKeyID_allocs)

	x.ref5481a313 = ref5481a313
	x.allocs5481a313 = allocs5481a313
	return ref5481a313, allocs5481a313

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ECPoint) PassValue() (C.tstrECPoint, *cgoAllocMap) {
	if x.ref5481a313 != nil {
		return *x.ref5481a313, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ECPoint) Deref() {
	if x.ref5481a313 == nil {
		return
	}
	x.XY = *(*[64]byte)(unsafe.Pointer(&x.ref5481a313.XY))
	x.U16Size = (uint16)(x.ref5481a313.u16Size)
	x.U16PrivKeyID = (uint16)(x.ref5481a313.u16PrivKeyID)
}

// allocECDomainParamMemory allocates memory for type C.tstrECDomainParam in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECDomainParamMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfECDomainParamValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfECDomainParamValue = unsafe.Sizeof([1]C.tstrECDomainParam{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ECDomainParam) Ref() *C.tstrECDomainParam {
	if x == nil {
		return nil
	}
	return x.ref305aa0bf
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ECDomainParam) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref305aa0bf)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ECDomainParam) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ECDomainParam) Free() {
	if x != nil && x.allocs305aa0bf != nil {
		x.allocs305aa0bf.(*cgoAllocMap).Free()
		x.ref305aa0bf = nil
	}
}

// NewECDomainParamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewECDomainParamRef(ref unsafe.Pointer) *ECDomainParam {
	if ref == nil {
		return nil
	}
	obj := new(ECDomainParam)
	obj.ref305aa0bf = (*C.tstrECDomainParam)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ECDomainParam) PassRef() (*C.tstrECDomainParam, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref305aa0bf != nil {
		return x.ref305aa0bf, nil
	}
	mem305aa0bf := allocECDomainParamMemory(1)
	ref305aa0bf := (*C.tstrECDomainParam)(mem305aa0bf)
	allocs305aa0bf := new(cgoAllocMap)
	allocs305aa0bf.Add(mem305aa0bf)

	var cp_allocs *cgoAllocMap
	ref305aa0bf.p, cp_allocs = *(*[8]C.uint32_t)(unsafe.Pointer(&x.P)), cgoAllocsUnknown
	allocs305aa0bf.Borrow(cp_allocs)

	var ca_allocs *cgoAllocMap
	ref305aa0bf.a, ca_allocs = *(*[8]C.uint32_t)(unsafe.Pointer(&x.A)), cgoAllocsUnknown
	allocs305aa0bf.Borrow(ca_allocs)

	var cb_allocs *cgoAllocMap
	ref305aa0bf.b, cb_allocs = *(*[8]C.uint32_t)(unsafe.Pointer(&x.B)), cgoAllocsUnknown
	allocs305aa0bf.Borrow(cb_allocs)

	var cG_allocs *cgoAllocMap
	ref305aa0bf.G, cG_allocs = x.G.PassValue()
	allocs305aa0bf.Borrow(cG_allocs)

	x.ref305aa0bf = ref305aa0bf
	x.allocs305aa0bf = allocs305aa0bf
	return ref305aa0bf, allocs305aa0bf

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ECDomainParam) PassValue() (C.tstrECDomainParam, *cgoAllocMap) {
	if x.ref305aa0bf != nil {
		return *x.ref305aa0bf, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ECDomainParam) Deref() {
	if x.ref305aa0bf == nil {
		return
	}
	x.P = *(*[8]uint32)(unsafe.Pointer(&x.ref305aa0bf.p))
	x.A = *(*[8]uint32)(unsafe.Pointer(&x.ref305aa0bf.a))
	x.B = *(*[8]uint32)(unsafe.Pointer(&x.ref305aa0bf.b))
	x.G = *NewECPointRef(unsafe.Pointer(&x.ref305aa0bf.G))
}

// allocEllipticCurveMemory allocates memory for type C.tstrEllipticCurve in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEllipticCurveMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfEllipticCurveValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfEllipticCurveValue = unsafe.Sizeof([1]C.tstrEllipticCurve{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EllipticCurve) Ref() *C.tstrEllipticCurve {
	if x == nil {
		return nil
	}
	return x.ref4d97526a
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *EllipticCurve) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref4d97526a)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *EllipticCurve) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EllipticCurve) Free() {
	if x != nil && x.allocs4d97526a != nil {
		x.allocs4d97526a.(*cgoAllocMap).Free()
		x.ref4d97526a = nil
	}
}

// NewEllipticCurveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEllipticCurveRef(ref unsafe.Pointer) *EllipticCurve {
	if ref == nil {
		return nil
	}
	obj := new(EllipticCurve)
	obj.ref4d97526a = (*C.tstrEllipticCurve)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EllipticCurve) PassRef() (*C.tstrEllipticCurve, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4d97526a != nil {
		return x.ref4d97526a, nil
	}
	mem4d97526a := allocEllipticCurveMemory(1)
	ref4d97526a := (*C.tstrEllipticCurve)(mem4d97526a)
	allocs4d97526a := new(cgoAllocMap)
	allocs4d97526a.Add(mem4d97526a)

	var cenuType_allocs *cgoAllocMap
	ref4d97526a.enuType, cenuType_allocs = (C.tenuEcNamedCurve)(x.EnuType), cgoAllocsUnknown
	allocs4d97526a.Borrow(cenuType_allocs)

	var cstrParam_allocs *cgoAllocMap
	ref4d97526a.strParam, cstrParam_allocs = x.StrParam.PassValue()
	allocs4d97526a.Borrow(cstrParam_allocs)

	x.ref4d97526a = ref4d97526a
	x.allocs4d97526a = allocs4d97526a
	return ref4d97526a, allocs4d97526a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EllipticCurve) PassValue() (C.tstrEllipticCurve, *cgoAllocMap) {
	if x.ref4d97526a != nil {
		return *x.ref4d97526a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EllipticCurve) Deref() {
	if x.ref4d97526a == nil {
		return
	}
	x.EnuType = (EnumEcNamedCurve)(x.ref4d97526a.enuType)
	x.StrParam = *NewECDomainParamRef(unsafe.Pointer(&x.ref4d97526a.strParam))
}

// allocEcdhReqInfoMemory allocates memory for type C.tstrEcdhReqInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEcdhReqInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfEcdhReqInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfEcdhReqInfoValue = unsafe.Sizeof([1]C.tstrEcdhReqInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EcdhReqInfo) Ref() *C.tstrEcdhReqInfo {
	if x == nil {
		return nil
	}
	return x.ref82b1acca
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *EcdhReqInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref82b1acca)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *EcdhReqInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EcdhReqInfo) Free() {
	if x != nil && x.allocs82b1acca != nil {
		x.allocs82b1acca.(*cgoAllocMap).Free()
		x.ref82b1acca = nil
	}
}

// NewEcdhReqInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEcdhReqInfoRef(ref unsafe.Pointer) *EcdhReqInfo {
	if ref == nil {
		return nil
	}
	obj := new(EcdhReqInfo)
	obj.ref82b1acca = (*C.tstrEcdhReqInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EcdhReqInfo) PassRef() (*C.tstrEcdhReqInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref82b1acca != nil {
		return x.ref82b1acca, nil
	}
	mem82b1acca := allocEcdhReqInfoMemory(1)
	ref82b1acca := (*C.tstrEcdhReqInfo)(mem82b1acca)
	allocs82b1acca := new(cgoAllocMap)
	allocs82b1acca.Add(mem82b1acca)

	var cu16REQ_allocs *cgoAllocMap
	ref82b1acca.u16REQ, cu16REQ_allocs = (C.uint16_t)(x.U16REQ), cgoAllocsUnknown
	allocs82b1acca.Borrow(cu16REQ_allocs)

	var cu16Status_allocs *cgoAllocMap
	ref82b1acca.u16Status, cu16Status_allocs = (C.uint16_t)(x.U16Status), cgoAllocsUnknown
	allocs82b1acca.Borrow(cu16Status_allocs)

	var cu32UserData_allocs *cgoAllocMap
	ref82b1acca.u32UserData, cu32UserData_allocs = (C.uint32_t)(x.U32UserData), cgoAllocsUnknown
	allocs82b1acca.Borrow(cu32UserData_allocs)

	var cu32SeqNo_allocs *cgoAllocMap
	ref82b1acca.u32SeqNo, cu32SeqNo_allocs = (C.uint32_t)(x.U32SeqNo), cgoAllocsUnknown
	allocs82b1acca.Borrow(cu32SeqNo_allocs)

	var cstrPubKey_allocs *cgoAllocMap
	ref82b1acca.strPubKey, cstrPubKey_allocs = x.StrPubKey.PassValue()
	allocs82b1acca.Borrow(cstrPubKey_allocs)

	var cau8Key_allocs *cgoAllocMap
	ref82b1acca.au8Key, cau8Key_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Au8Key)), cgoAllocsUnknown
	allocs82b1acca.Borrow(cau8Key_allocs)

	x.ref82b1acca = ref82b1acca
	x.allocs82b1acca = allocs82b1acca
	return ref82b1acca, allocs82b1acca

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EcdhReqInfo) PassValue() (C.tstrEcdhReqInfo, *cgoAllocMap) {
	if x.ref82b1acca != nil {
		return *x.ref82b1acca, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EcdhReqInfo) Deref() {
	if x.ref82b1acca == nil {
		return
	}
	x.U16REQ = (uint16)(x.ref82b1acca.u16REQ)
	x.U16Status = (uint16)(x.ref82b1acca.u16Status)
	x.U32UserData = (uint32)(x.ref82b1acca.u32UserData)
	x.U32SeqNo = (uint32)(x.ref82b1acca.u32SeqNo)
	x.StrPubKey = *NewECPointRef(unsafe.Pointer(&x.ref82b1acca.strPubKey))
	x.Au8Key = *(*[32]byte)(unsafe.Pointer(&x.ref82b1acca.au8Key))
}

// allocEcdsaVerifyReqInfoMemory allocates memory for type C.tstrEcdsaVerifyReqInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEcdsaVerifyReqInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfEcdsaVerifyReqInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfEcdsaVerifyReqInfoValue = unsafe.Sizeof([1]C.tstrEcdsaVerifyReqInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EcdsaVerifyReqInfo) Ref() *C.tstrEcdsaVerifyReqInfo {
	if x == nil {
		return nil
	}
	return x.ref38d99f76
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *EcdsaVerifyReqInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref38d99f76)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *EcdsaVerifyReqInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EcdsaVerifyReqInfo) Free() {
	if x != nil && x.allocs38d99f76 != nil {
		x.allocs38d99f76.(*cgoAllocMap).Free()
		x.ref38d99f76 = nil
	}
}

// NewEcdsaVerifyReqInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEcdsaVerifyReqInfoRef(ref unsafe.Pointer) *EcdsaVerifyReqInfo {
	if ref == nil {
		return nil
	}
	obj := new(EcdsaVerifyReqInfo)
	obj.ref38d99f76 = (*C.tstrEcdsaVerifyReqInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EcdsaVerifyReqInfo) PassRef() (*C.tstrEcdsaVerifyReqInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref38d99f76 != nil {
		return x.ref38d99f76, nil
	}
	mem38d99f76 := allocEcdsaVerifyReqInfoMemory(1)
	ref38d99f76 := (*C.tstrEcdsaVerifyReqInfo)(mem38d99f76)
	allocs38d99f76 := new(cgoAllocMap)
	allocs38d99f76.Add(mem38d99f76)

	var cu16REQ_allocs *cgoAllocMap
	ref38d99f76.u16REQ, cu16REQ_allocs = (C.uint16_t)(x.U16REQ), cgoAllocsUnknown
	allocs38d99f76.Borrow(cu16REQ_allocs)

	var cu16Status_allocs *cgoAllocMap
	ref38d99f76.u16Status, cu16Status_allocs = (C.uint16_t)(x.U16Status), cgoAllocsUnknown
	allocs38d99f76.Borrow(cu16Status_allocs)

	var cu32UserData_allocs *cgoAllocMap
	ref38d99f76.u32UserData, cu32UserData_allocs = (C.uint32_t)(x.U32UserData), cgoAllocsUnknown
	allocs38d99f76.Borrow(cu32UserData_allocs)

	var cu32SeqNo_allocs *cgoAllocMap
	ref38d99f76.u32SeqNo, cu32SeqNo_allocs = (C.uint32_t)(x.U32SeqNo), cgoAllocsUnknown
	allocs38d99f76.Borrow(cu32SeqNo_allocs)

	var cu32nSig_allocs *cgoAllocMap
	ref38d99f76.u32nSig, cu32nSig_allocs = (C.uint32_t)(x.U32nSig), cgoAllocsUnknown
	allocs38d99f76.Borrow(cu32nSig_allocs)

	x.ref38d99f76 = ref38d99f76
	x.allocs38d99f76 = allocs38d99f76
	return ref38d99f76, allocs38d99f76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EcdsaVerifyReqInfo) PassValue() (C.tstrEcdsaVerifyReqInfo, *cgoAllocMap) {
	if x.ref38d99f76 != nil {
		return *x.ref38d99f76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EcdsaVerifyReqInfo) Deref() {
	if x.ref38d99f76 == nil {
		return
	}
	x.U16REQ = (uint16)(x.ref38d99f76.u16REQ)
	x.U16Status = (uint16)(x.ref38d99f76.u16Status)
	x.U32UserData = (uint32)(x.ref38d99f76.u32UserData)
	x.U32SeqNo = (uint32)(x.ref38d99f76.u32SeqNo)
	x.U32nSig = (uint32)(x.ref38d99f76.u32nSig)
}

// allocEcdsaSignReqInfoMemory allocates memory for type C.tstrEcdsaSignReqInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEcdsaSignReqInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfEcdsaSignReqInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfEcdsaSignReqInfoValue = unsafe.Sizeof([1]C.tstrEcdsaSignReqInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EcdsaSignReqInfo) Ref() *C.tstrEcdsaSignReqInfo {
	if x == nil {
		return nil
	}
	return x.ref520501e6
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *EcdsaSignReqInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref520501e6)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *EcdsaSignReqInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EcdsaSignReqInfo) Free() {
	if x != nil && x.allocs520501e6 != nil {
		x.allocs520501e6.(*cgoAllocMap).Free()
		x.ref520501e6 = nil
	}
}

// NewEcdsaSignReqInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEcdsaSignReqInfoRef(ref unsafe.Pointer) *EcdsaSignReqInfo {
	if ref == nil {
		return nil
	}
	obj := new(EcdsaSignReqInfo)
	obj.ref520501e6 = (*C.tstrEcdsaSignReqInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EcdsaSignReqInfo) PassRef() (*C.tstrEcdsaSignReqInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref520501e6 != nil {
		return x.ref520501e6, nil
	}
	mem520501e6 := allocEcdsaSignReqInfoMemory(1)
	ref520501e6 := (*C.tstrEcdsaSignReqInfo)(mem520501e6)
	allocs520501e6 := new(cgoAllocMap)
	allocs520501e6.Add(mem520501e6)

	var cu16REQ_allocs *cgoAllocMap
	ref520501e6.u16REQ, cu16REQ_allocs = (C.uint16_t)(x.U16REQ), cgoAllocsUnknown
	allocs520501e6.Borrow(cu16REQ_allocs)

	var cu16Status_allocs *cgoAllocMap
	ref520501e6.u16Status, cu16Status_allocs = (C.uint16_t)(x.U16Status), cgoAllocsUnknown
	allocs520501e6.Borrow(cu16Status_allocs)

	var cu32UserData_allocs *cgoAllocMap
	ref520501e6.u32UserData, cu32UserData_allocs = (C.uint32_t)(x.U32UserData), cgoAllocsUnknown
	allocs520501e6.Borrow(cu32UserData_allocs)

	var cu32SeqNo_allocs *cgoAllocMap
	ref520501e6.u32SeqNo, cu32SeqNo_allocs = (C.uint32_t)(x.U32SeqNo), cgoAllocsUnknown
	allocs520501e6.Borrow(cu32SeqNo_allocs)

	var cu16CurveType_allocs *cgoAllocMap
	ref520501e6.u16CurveType, cu16CurveType_allocs = (C.uint16_t)(x.U16CurveType), cgoAllocsUnknown
	allocs520501e6.Borrow(cu16CurveType_allocs)

	var cu16HashSz_allocs *cgoAllocMap
	ref520501e6.u16HashSz, cu16HashSz_allocs = (C.uint16_t)(x.U16HashSz), cgoAllocsUnknown
	allocs520501e6.Borrow(cu16HashSz_allocs)

	x.ref520501e6 = ref520501e6
	x.allocs520501e6 = allocs520501e6
	return ref520501e6, allocs520501e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EcdsaSignReqInfo) PassValue() (C.tstrEcdsaSignReqInfo, *cgoAllocMap) {
	if x.ref520501e6 != nil {
		return *x.ref520501e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EcdsaSignReqInfo) Deref() {
	if x.ref520501e6 == nil {
		return
	}
	x.U16REQ = (uint16)(x.ref520501e6.u16REQ)
	x.U16Status = (uint16)(x.ref520501e6.u16Status)
	x.U32UserData = (uint32)(x.ref520501e6.u32UserData)
	x.U32SeqNo = (uint32)(x.ref520501e6.u32SeqNo)
	x.U16CurveType = (uint16)(x.ref520501e6.u16CurveType)
	x.U16HashSz = (uint16)(x.ref520501e6.u16HashSz)
}

// allocHifHdrMemory allocates memory for type C.tstrHifHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocHifHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfHifHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfHifHdrValue = unsafe.Sizeof([1]C.tstrHifHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *HifHdr) Ref() *C.tstrHifHdr {
	if x == nil {
		return nil
	}
	return x.ref2e9cbbc5
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *HifHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref2e9cbbc5)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *HifHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *HifHdr) Free() {
	if x != nil && x.allocs2e9cbbc5 != nil {
		x.allocs2e9cbbc5.(*cgoAllocMap).Free()
		x.ref2e9cbbc5 = nil
	}
}

// NewHifHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewHifHdrRef(ref unsafe.Pointer) *HifHdr {
	if ref == nil {
		return nil
	}
	obj := new(HifHdr)
	obj.ref2e9cbbc5 = (*C.tstrHifHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *HifHdr) PassRef() (*C.tstrHifHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2e9cbbc5 != nil {
		return x.ref2e9cbbc5, nil
	}
	mem2e9cbbc5 := allocHifHdrMemory(1)
	ref2e9cbbc5 := (*C.tstrHifHdr)(mem2e9cbbc5)
	allocs2e9cbbc5 := new(cgoAllocMap)
	allocs2e9cbbc5.Add(mem2e9cbbc5)

	var cu8Gid_allocs *cgoAllocMap
	ref2e9cbbc5.u8Gid, cu8Gid_allocs = (C.uint8_t)(x.U8Gid), cgoAllocsUnknown
	allocs2e9cbbc5.Borrow(cu8Gid_allocs)

	var cu8Opcode_allocs *cgoAllocMap
	ref2e9cbbc5.u8Opcode, cu8Opcode_allocs = (C.uint8_t)(x.U8Opcode), cgoAllocsUnknown
	allocs2e9cbbc5.Borrow(cu8Opcode_allocs)

	var cu16Length_allocs *cgoAllocMap
	ref2e9cbbc5.u16Length, cu16Length_allocs = (C.uint16_t)(x.U16Length), cgoAllocsUnknown
	allocs2e9cbbc5.Borrow(cu16Length_allocs)

	x.ref2e9cbbc5 = ref2e9cbbc5
	x.allocs2e9cbbc5 = allocs2e9cbbc5
	return ref2e9cbbc5, allocs2e9cbbc5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x HifHdr) PassValue() (C.tstrHifHdr, *cgoAllocMap) {
	if x.ref2e9cbbc5 != nil {
		return *x.ref2e9cbbc5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *HifHdr) Deref() {
	if x.ref2e9cbbc5 == nil {
		return
	}
	x.U8Gid = (byte)(x.ref2e9cbbc5.u8Gid)
	x.U8Opcode = (byte)(x.ref2e9cbbc5.u8Opcode)
	x.U16Length = (uint16)(x.ref2e9cbbc5.u16Length)
}

// allocSockAddrMemory allocates memory for type C.tstrSockAddr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSockAddrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSockAddrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSockAddrValue = unsafe.Sizeof([1]C.tstrSockAddr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SockAddr) Ref() *C.tstrSockAddr {
	if x == nil {
		return nil
	}
	return x.reff979731
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SockAddr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reff979731)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SockAddr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SockAddr) Free() {
	if x != nil && x.allocsf979731 != nil {
		x.allocsf979731.(*cgoAllocMap).Free()
		x.reff979731 = nil
	}
}

// NewSockAddrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSockAddrRef(ref unsafe.Pointer) *SockAddr {
	if ref == nil {
		return nil
	}
	obj := new(SockAddr)
	obj.reff979731 = (*C.tstrSockAddr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SockAddr) PassRef() (*C.tstrSockAddr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff979731 != nil {
		return x.reff979731, nil
	}
	memf979731 := allocSockAddrMemory(1)
	reff979731 := (*C.tstrSockAddr)(memf979731)
	allocsf979731 := new(cgoAllocMap)
	allocsf979731.Add(memf979731)

	var cu16Family_allocs *cgoAllocMap
	reff979731.u16Family, cu16Family_allocs = (C.uint16_t)(x.U16Family), cgoAllocsUnknown
	allocsf979731.Borrow(cu16Family_allocs)

	var cu16Port_allocs *cgoAllocMap
	reff979731.u16Port, cu16Port_allocs = (C.uint16_t)(x.U16Port), cgoAllocsUnknown
	allocsf979731.Borrow(cu16Port_allocs)

	var cu32IPAddr_allocs *cgoAllocMap
	reff979731.u32IPAddr, cu32IPAddr_allocs = (C.uint32_t)(x.U32IPAddr), cgoAllocsUnknown
	allocsf979731.Borrow(cu32IPAddr_allocs)

	x.reff979731 = reff979731
	x.allocsf979731 = allocsf979731
	return reff979731, allocsf979731

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SockAddr) PassValue() (C.tstrSockAddr, *cgoAllocMap) {
	if x.reff979731 != nil {
		return *x.reff979731, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SockAddr) Deref() {
	if x.reff979731 == nil {
		return
	}
	x.U16Family = (uint16)(x.reff979731.u16Family)
	x.U16Port = (uint16)(x.reff979731.u16Port)
	x.U32IPAddr = (uint32)(x.reff979731.u32IPAddr)
}

// allocUIPSockAddrMemory allocates memory for type C.tstrUIPSockAddr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUIPSockAddrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfUIPSockAddrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfUIPSockAddrValue = unsafe.Sizeof([1]C.tstrUIPSockAddr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *UIPSockAddr) Ref() *C.tstrUIPSockAddr {
	if x == nil {
		return nil
	}
	return x.ref73ec2e23
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *UIPSockAddr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref73ec2e23)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *UIPSockAddr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *UIPSockAddr) Free() {
	if x != nil && x.allocs73ec2e23 != nil {
		x.allocs73ec2e23.(*cgoAllocMap).Free()
		x.ref73ec2e23 = nil
	}
}

// NewUIPSockAddrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewUIPSockAddrRef(ref unsafe.Pointer) *UIPSockAddr {
	if ref == nil {
		return nil
	}
	obj := new(UIPSockAddr)
	obj.ref73ec2e23 = (*C.tstrUIPSockAddr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *UIPSockAddr) PassRef() (*C.tstrUIPSockAddr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref73ec2e23 != nil {
		return x.ref73ec2e23, nil
	}
	mem73ec2e23 := allocUIPSockAddrMemory(1)
	ref73ec2e23 := (*C.tstrUIPSockAddr)(mem73ec2e23)
	allocs73ec2e23 := new(cgoAllocMap)
	allocs73ec2e23.Add(mem73ec2e23)

	var cu16Family_allocs *cgoAllocMap
	ref73ec2e23.u16Family, cu16Family_allocs = (C.uint16_t)(x.U16Family), cgoAllocsUnknown
	allocs73ec2e23.Borrow(cu16Family_allocs)

	var cu16Port_allocs *cgoAllocMap
	ref73ec2e23.u16Port, cu16Port_allocs = (C.uint16_t)(x.U16Port), cgoAllocsUnknown
	allocs73ec2e23.Borrow(cu16Port_allocs)

	var cu32IPAddr_allocs *cgoAllocMap
	ref73ec2e23.u32IPAddr, cu32IPAddr_allocs = (C.uint32_t)(x.U32IPAddr), cgoAllocsUnknown
	allocs73ec2e23.Borrow(cu32IPAddr_allocs)

	x.ref73ec2e23 = ref73ec2e23
	x.allocs73ec2e23 = allocs73ec2e23
	return ref73ec2e23, allocs73ec2e23

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x UIPSockAddr) PassValue() (C.tstrUIPSockAddr, *cgoAllocMap) {
	if x.ref73ec2e23 != nil {
		return *x.ref73ec2e23, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *UIPSockAddr) Deref() {
	if x.ref73ec2e23 == nil {
		return
	}
	x.U16Family = (uint16)(x.ref73ec2e23.u16Family)
	x.U16Port = (uint16)(x.ref73ec2e23.u16Port)
	x.U32IPAddr = (uint32)(x.ref73ec2e23.u32IPAddr)
}

// allocDnsReplyMemory allocates memory for type C.tstrDnsReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocDnsReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfDnsReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfDnsReplyValue = unsafe.Sizeof([1]C.tstrDnsReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *DnsReply) Ref() *C.tstrDnsReply {
	if x == nil {
		return nil
	}
	return x.ref1b0d1c9e
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *DnsReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref1b0d1c9e)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *DnsReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *DnsReply) Free() {
	if x != nil && x.allocs1b0d1c9e != nil {
		x.allocs1b0d1c9e.(*cgoAllocMap).Free()
		x.ref1b0d1c9e = nil
	}
}

// NewDnsReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewDnsReplyRef(ref unsafe.Pointer) *DnsReply {
	if ref == nil {
		return nil
	}
	obj := new(DnsReply)
	obj.ref1b0d1c9e = (*C.tstrDnsReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *DnsReply) PassRef() (*C.tstrDnsReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1b0d1c9e != nil {
		return x.ref1b0d1c9e, nil
	}
	mem1b0d1c9e := allocDnsReplyMemory(1)
	ref1b0d1c9e := (*C.tstrDnsReply)(mem1b0d1c9e)
	allocs1b0d1c9e := new(cgoAllocMap)
	allocs1b0d1c9e.Add(mem1b0d1c9e)

	var cacHostName_allocs *cgoAllocMap
	ref1b0d1c9e.acHostName, cacHostName_allocs = *(*[64]C.char)(unsafe.Pointer(&x.AcHostName)), cgoAllocsUnknown
	allocs1b0d1c9e.Borrow(cacHostName_allocs)

	var cu32HostIP_allocs *cgoAllocMap
	ref1b0d1c9e.u32HostIP, cu32HostIP_allocs = (C.uint32_t)(x.U32HostIP), cgoAllocsUnknown
	allocs1b0d1c9e.Borrow(cu32HostIP_allocs)

	x.ref1b0d1c9e = ref1b0d1c9e
	x.allocs1b0d1c9e = allocs1b0d1c9e
	return ref1b0d1c9e, allocs1b0d1c9e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x DnsReply) PassValue() (C.tstrDnsReply, *cgoAllocMap) {
	if x.ref1b0d1c9e != nil {
		return *x.ref1b0d1c9e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *DnsReply) Deref() {
	if x.ref1b0d1c9e == nil {
		return
	}
	x.AcHostName = *(*[64]byte)(unsafe.Pointer(&x.ref1b0d1c9e.acHostName))
	x.U32HostIP = (uint32)(x.ref1b0d1c9e.u32HostIP)
}

// allocBindCmdMemory allocates memory for type C.tstrBindCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfBindCmdValue = unsafe.Sizeof([1]C.tstrBindCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindCmd) Ref() *C.tstrBindCmd {
	if x == nil {
		return nil
	}
	return x.reffd41baba
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *BindCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reffd41baba)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *BindCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindCmd) Free() {
	if x != nil && x.allocsfd41baba != nil {
		x.allocsfd41baba.(*cgoAllocMap).Free()
		x.reffd41baba = nil
	}
}

// NewBindCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindCmdRef(ref unsafe.Pointer) *BindCmd {
	if ref == nil {
		return nil
	}
	obj := new(BindCmd)
	obj.reffd41baba = (*C.tstrBindCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindCmd) PassRef() (*C.tstrBindCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffd41baba != nil {
		return x.reffd41baba, nil
	}
	memfd41baba := allocBindCmdMemory(1)
	reffd41baba := (*C.tstrBindCmd)(memfd41baba)
	allocsfd41baba := new(cgoAllocMap)
	allocsfd41baba.Add(memfd41baba)

	var cstrAddr_allocs *cgoAllocMap
	reffd41baba.strAddr, cstrAddr_allocs = x.StrAddr.PassValue()
	allocsfd41baba.Borrow(cstrAddr_allocs)

	var csock_allocs *cgoAllocMap
	reffd41baba.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocsfd41baba.Borrow(csock_allocs)

	var cu8Void_allocs *cgoAllocMap
	reffd41baba.u8Void, cu8Void_allocs = (C.uint8_t)(x.U8Void), cgoAllocsUnknown
	allocsfd41baba.Borrow(cu8Void_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	reffd41baba.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocsfd41baba.Borrow(cu16SessionID_allocs)

	x.reffd41baba = reffd41baba
	x.allocsfd41baba = allocsfd41baba
	return reffd41baba, allocsfd41baba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindCmd) PassValue() (C.tstrBindCmd, *cgoAllocMap) {
	if x.reffd41baba != nil {
		return *x.reffd41baba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindCmd) Deref() {
	if x.reffd41baba == nil {
		return
	}
	x.StrAddr = *NewSockAddrRef(unsafe.Pointer(&x.reffd41baba.strAddr))
	x.Sock = (int8)(x.reffd41baba.sock)
	x.U8Void = (byte)(x.reffd41baba.u8Void)
	x.U16SessionID = (uint16)(x.reffd41baba.u16SessionID)
}

// allocBindReplyMemory allocates memory for type C.tstrBindReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBindReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfBindReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfBindReplyValue = unsafe.Sizeof([1]C.tstrBindReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BindReply) Ref() *C.tstrBindReply {
	if x == nil {
		return nil
	}
	return x.ref17cd835c
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *BindReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref17cd835c)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *BindReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BindReply) Free() {
	if x != nil && x.allocs17cd835c != nil {
		x.allocs17cd835c.(*cgoAllocMap).Free()
		x.ref17cd835c = nil
	}
}

// NewBindReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBindReplyRef(ref unsafe.Pointer) *BindReply {
	if ref == nil {
		return nil
	}
	obj := new(BindReply)
	obj.ref17cd835c = (*C.tstrBindReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BindReply) PassRef() (*C.tstrBindReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref17cd835c != nil {
		return x.ref17cd835c, nil
	}
	mem17cd835c := allocBindReplyMemory(1)
	ref17cd835c := (*C.tstrBindReply)(mem17cd835c)
	allocs17cd835c := new(cgoAllocMap)
	allocs17cd835c.Add(mem17cd835c)

	var csock_allocs *cgoAllocMap
	ref17cd835c.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs17cd835c.Borrow(csock_allocs)

	var cs8Status_allocs *cgoAllocMap
	ref17cd835c.s8Status, cs8Status_allocs = (C.int8_t)(x.S8Status), cgoAllocsUnknown
	allocs17cd835c.Borrow(cs8Status_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref17cd835c.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs17cd835c.Borrow(cu16SessionID_allocs)

	x.ref17cd835c = ref17cd835c
	x.allocs17cd835c = allocs17cd835c
	return ref17cd835c, allocs17cd835c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BindReply) PassValue() (C.tstrBindReply, *cgoAllocMap) {
	if x.ref17cd835c != nil {
		return *x.ref17cd835c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *BindReply) Deref() {
	if x.ref17cd835c == nil {
		return
	}
	x.Sock = (int8)(x.ref17cd835c.sock)
	x.S8Status = (int8)(x.ref17cd835c.s8Status)
	x.U16SessionID = (uint16)(x.ref17cd835c.u16SessionID)
}

// allocListenCmdMemory allocates memory for type C.tstrListenCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocListenCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfListenCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfListenCmdValue = unsafe.Sizeof([1]C.tstrListenCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ListenCmd) Ref() *C.tstrListenCmd {
	if x == nil {
		return nil
	}
	return x.ref42e0429d
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ListenCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref42e0429d)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ListenCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ListenCmd) Free() {
	if x != nil && x.allocs42e0429d != nil {
		x.allocs42e0429d.(*cgoAllocMap).Free()
		x.ref42e0429d = nil
	}
}

// NewListenCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewListenCmdRef(ref unsafe.Pointer) *ListenCmd {
	if ref == nil {
		return nil
	}
	obj := new(ListenCmd)
	obj.ref42e0429d = (*C.tstrListenCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ListenCmd) PassRef() (*C.tstrListenCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref42e0429d != nil {
		return x.ref42e0429d, nil
	}
	mem42e0429d := allocListenCmdMemory(1)
	ref42e0429d := (*C.tstrListenCmd)(mem42e0429d)
	allocs42e0429d := new(cgoAllocMap)
	allocs42e0429d.Add(mem42e0429d)

	var csock_allocs *cgoAllocMap
	ref42e0429d.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs42e0429d.Borrow(csock_allocs)

	var cu8BackLog_allocs *cgoAllocMap
	ref42e0429d.u8BackLog, cu8BackLog_allocs = (C.uint8_t)(x.U8BackLog), cgoAllocsUnknown
	allocs42e0429d.Borrow(cu8BackLog_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref42e0429d.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs42e0429d.Borrow(cu16SessionID_allocs)

	x.ref42e0429d = ref42e0429d
	x.allocs42e0429d = allocs42e0429d
	return ref42e0429d, allocs42e0429d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ListenCmd) PassValue() (C.tstrListenCmd, *cgoAllocMap) {
	if x.ref42e0429d != nil {
		return *x.ref42e0429d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ListenCmd) Deref() {
	if x.ref42e0429d == nil {
		return
	}
	x.Sock = (int8)(x.ref42e0429d.sock)
	x.U8BackLog = (byte)(x.ref42e0429d.u8BackLog)
	x.U16SessionID = (uint16)(x.ref42e0429d.u16SessionID)
}

// allocListenReplyMemory allocates memory for type C.tstrListenReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocListenReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfListenReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfListenReplyValue = unsafe.Sizeof([1]C.tstrListenReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ListenReply) Ref() *C.tstrListenReply {
	if x == nil {
		return nil
	}
	return x.ref7e6ef4b6
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ListenReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref7e6ef4b6)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ListenReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ListenReply) Free() {
	if x != nil && x.allocs7e6ef4b6 != nil {
		x.allocs7e6ef4b6.(*cgoAllocMap).Free()
		x.ref7e6ef4b6 = nil
	}
}

// NewListenReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewListenReplyRef(ref unsafe.Pointer) *ListenReply {
	if ref == nil {
		return nil
	}
	obj := new(ListenReply)
	obj.ref7e6ef4b6 = (*C.tstrListenReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ListenReply) PassRef() (*C.tstrListenReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7e6ef4b6 != nil {
		return x.ref7e6ef4b6, nil
	}
	mem7e6ef4b6 := allocListenReplyMemory(1)
	ref7e6ef4b6 := (*C.tstrListenReply)(mem7e6ef4b6)
	allocs7e6ef4b6 := new(cgoAllocMap)
	allocs7e6ef4b6.Add(mem7e6ef4b6)

	var csock_allocs *cgoAllocMap
	ref7e6ef4b6.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs7e6ef4b6.Borrow(csock_allocs)

	var cs8Status_allocs *cgoAllocMap
	ref7e6ef4b6.s8Status, cs8Status_allocs = (C.int8_t)(x.S8Status), cgoAllocsUnknown
	allocs7e6ef4b6.Borrow(cs8Status_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref7e6ef4b6.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs7e6ef4b6.Borrow(cu16SessionID_allocs)

	x.ref7e6ef4b6 = ref7e6ef4b6
	x.allocs7e6ef4b6 = allocs7e6ef4b6
	return ref7e6ef4b6, allocs7e6ef4b6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ListenReply) PassValue() (C.tstrListenReply, *cgoAllocMap) {
	if x.ref7e6ef4b6 != nil {
		return *x.ref7e6ef4b6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ListenReply) Deref() {
	if x.ref7e6ef4b6 == nil {
		return
	}
	x.Sock = (int8)(x.ref7e6ef4b6.sock)
	x.S8Status = (int8)(x.ref7e6ef4b6.s8Status)
	x.U16SessionID = (uint16)(x.ref7e6ef4b6.u16SessionID)
}

// allocAcceptReplyMemory allocates memory for type C.tstrAcceptReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAcceptReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfAcceptReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfAcceptReplyValue = unsafe.Sizeof([1]C.tstrAcceptReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AcceptReply) Ref() *C.tstrAcceptReply {
	if x == nil {
		return nil
	}
	return x.ref29a2c828
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *AcceptReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref29a2c828)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *AcceptReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AcceptReply) Free() {
	if x != nil && x.allocs29a2c828 != nil {
		x.allocs29a2c828.(*cgoAllocMap).Free()
		x.ref29a2c828 = nil
	}
}

// NewAcceptReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAcceptReplyRef(ref unsafe.Pointer) *AcceptReply {
	if ref == nil {
		return nil
	}
	obj := new(AcceptReply)
	obj.ref29a2c828 = (*C.tstrAcceptReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AcceptReply) PassRef() (*C.tstrAcceptReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29a2c828 != nil {
		return x.ref29a2c828, nil
	}
	mem29a2c828 := allocAcceptReplyMemory(1)
	ref29a2c828 := (*C.tstrAcceptReply)(mem29a2c828)
	allocs29a2c828 := new(cgoAllocMap)
	allocs29a2c828.Add(mem29a2c828)

	var cstrAddr_allocs *cgoAllocMap
	ref29a2c828.strAddr, cstrAddr_allocs = x.StrAddr.PassValue()
	allocs29a2c828.Borrow(cstrAddr_allocs)

	var csListenSock_allocs *cgoAllocMap
	ref29a2c828.sListenSock, csListenSock_allocs = (C.SOCKET)(x.SListenSock), cgoAllocsUnknown
	allocs29a2c828.Borrow(csListenSock_allocs)

	var csConnectedSock_allocs *cgoAllocMap
	ref29a2c828.sConnectedSock, csConnectedSock_allocs = (C.SOCKET)(x.SConnectedSock), cgoAllocsUnknown
	allocs29a2c828.Borrow(csConnectedSock_allocs)

	var cu16AppDataOffset_allocs *cgoAllocMap
	ref29a2c828.u16AppDataOffset, cu16AppDataOffset_allocs = (C.uint16_t)(x.U16AppDataOffset), cgoAllocsUnknown
	allocs29a2c828.Borrow(cu16AppDataOffset_allocs)

	x.ref29a2c828 = ref29a2c828
	x.allocs29a2c828 = allocs29a2c828
	return ref29a2c828, allocs29a2c828

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AcceptReply) PassValue() (C.tstrAcceptReply, *cgoAllocMap) {
	if x.ref29a2c828 != nil {
		return *x.ref29a2c828, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *AcceptReply) Deref() {
	if x.ref29a2c828 == nil {
		return
	}
	x.StrAddr = *NewSockAddrRef(unsafe.Pointer(&x.ref29a2c828.strAddr))
	x.SListenSock = (int8)(x.ref29a2c828.sListenSock)
	x.SConnectedSock = (int8)(x.ref29a2c828.sConnectedSock)
	x.U16AppDataOffset = (uint16)(x.ref29a2c828.u16AppDataOffset)
}

// allocConnectCmdMemory allocates memory for type C.tstrConnectCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConnectCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfConnectCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfConnectCmdValue = unsafe.Sizeof([1]C.tstrConnectCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConnectCmd) Ref() *C.tstrConnectCmd {
	if x == nil {
		return nil
	}
	return x.refc65d5400
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ConnectCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refc65d5400)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ConnectCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConnectCmd) Free() {
	if x != nil && x.allocsc65d5400 != nil {
		x.allocsc65d5400.(*cgoAllocMap).Free()
		x.refc65d5400 = nil
	}
}

// NewConnectCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConnectCmdRef(ref unsafe.Pointer) *ConnectCmd {
	if ref == nil {
		return nil
	}
	obj := new(ConnectCmd)
	obj.refc65d5400 = (*C.tstrConnectCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConnectCmd) PassRef() (*C.tstrConnectCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc65d5400 != nil {
		return x.refc65d5400, nil
	}
	memc65d5400 := allocConnectCmdMemory(1)
	refc65d5400 := (*C.tstrConnectCmd)(memc65d5400)
	allocsc65d5400 := new(cgoAllocMap)
	allocsc65d5400.Add(memc65d5400)

	var cstrAddr_allocs *cgoAllocMap
	refc65d5400.strAddr, cstrAddr_allocs = x.StrAddr.PassValue()
	allocsc65d5400.Borrow(cstrAddr_allocs)

	var csock_allocs *cgoAllocMap
	refc65d5400.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocsc65d5400.Borrow(csock_allocs)

	var cu8SslFlags_allocs *cgoAllocMap
	refc65d5400.u8SslFlags, cu8SslFlags_allocs = (C.uint8_t)(x.U8SslFlags), cgoAllocsUnknown
	allocsc65d5400.Borrow(cu8SslFlags_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	refc65d5400.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocsc65d5400.Borrow(cu16SessionID_allocs)

	x.refc65d5400 = refc65d5400
	x.allocsc65d5400 = allocsc65d5400
	return refc65d5400, allocsc65d5400

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConnectCmd) PassValue() (C.tstrConnectCmd, *cgoAllocMap) {
	if x.refc65d5400 != nil {
		return *x.refc65d5400, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConnectCmd) Deref() {
	if x.refc65d5400 == nil {
		return
	}
	x.StrAddr = *NewSockAddrRef(unsafe.Pointer(&x.refc65d5400.strAddr))
	x.Sock = (int8)(x.refc65d5400.sock)
	x.U8SslFlags = (byte)(x.refc65d5400.u8SslFlags)
	x.U16SessionID = (uint16)(x.refc65d5400.u16SessionID)
}

// allocConnectReplyMemory allocates memory for type C.tstrConnectReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConnectReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfConnectReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfConnectReplyValue = unsafe.Sizeof([1]C.tstrConnectReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConnectReply) Ref() *C.tstrConnectReply {
	if x == nil {
		return nil
	}
	return x.ref4e55310d
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ConnectReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref4e55310d)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ConnectReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConnectReply) Free() {
	if x != nil && x.allocs4e55310d != nil {
		x.allocs4e55310d.(*cgoAllocMap).Free()
		x.ref4e55310d = nil
	}
}

// NewConnectReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConnectReplyRef(ref unsafe.Pointer) *ConnectReply {
	if ref == nil {
		return nil
	}
	obj := new(ConnectReply)
	obj.ref4e55310d = (*C.tstrConnectReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConnectReply) PassRef() (*C.tstrConnectReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4e55310d != nil {
		return x.ref4e55310d, nil
	}
	mem4e55310d := allocConnectReplyMemory(1)
	ref4e55310d := (*C.tstrConnectReply)(mem4e55310d)
	allocs4e55310d := new(cgoAllocMap)
	allocs4e55310d.Add(mem4e55310d)

	var csock_allocs *cgoAllocMap
	ref4e55310d.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs4e55310d.Borrow(csock_allocs)

	var cs8Error_allocs *cgoAllocMap
	ref4e55310d.s8Error, cs8Error_allocs = (C.int8_t)(x.S8Error), cgoAllocsUnknown
	allocs4e55310d.Borrow(cs8Error_allocs)

	var cu16ExtraData_allocs *cgoAllocMap
	ref4e55310d.u16ExtraData, cu16ExtraData_allocs = (C.uint16_t)(x.U16ExtraData), cgoAllocsUnknown
	allocs4e55310d.Borrow(cu16ExtraData_allocs)

	x.ref4e55310d = ref4e55310d
	x.allocs4e55310d = allocs4e55310d
	return ref4e55310d, allocs4e55310d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConnectReply) PassValue() (C.tstrConnectReply, *cgoAllocMap) {
	if x.ref4e55310d != nil {
		return *x.ref4e55310d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConnectReply) Deref() {
	if x.ref4e55310d == nil {
		return
	}
	x.Sock = (int8)(x.ref4e55310d.sock)
	x.S8Error = (int8)(x.ref4e55310d.s8Error)
	x.U16ExtraData = (uint16)(x.ref4e55310d.u16ExtraData)
}

// allocCloseCmdMemory allocates memory for type C.tstrCloseCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCloseCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfCloseCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfCloseCmdValue = unsafe.Sizeof([1]C.tstrCloseCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CloseCmd) Ref() *C.tstrCloseCmd {
	if x == nil {
		return nil
	}
	return x.ref52d2c6ab
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *CloseCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref52d2c6ab)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *CloseCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CloseCmd) Free() {
	if x != nil && x.allocs52d2c6ab != nil {
		x.allocs52d2c6ab.(*cgoAllocMap).Free()
		x.ref52d2c6ab = nil
	}
}

// NewCloseCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCloseCmdRef(ref unsafe.Pointer) *CloseCmd {
	if ref == nil {
		return nil
	}
	obj := new(CloseCmd)
	obj.ref52d2c6ab = (*C.tstrCloseCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CloseCmd) PassRef() (*C.tstrCloseCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref52d2c6ab != nil {
		return x.ref52d2c6ab, nil
	}
	mem52d2c6ab := allocCloseCmdMemory(1)
	ref52d2c6ab := (*C.tstrCloseCmd)(mem52d2c6ab)
	allocs52d2c6ab := new(cgoAllocMap)
	allocs52d2c6ab.Add(mem52d2c6ab)

	var csock_allocs *cgoAllocMap
	ref52d2c6ab.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs52d2c6ab.Borrow(csock_allocs)

	var cu8Dummy_allocs *cgoAllocMap
	ref52d2c6ab.u8Dummy, cu8Dummy_allocs = (C.uint8_t)(x.U8Dummy), cgoAllocsUnknown
	allocs52d2c6ab.Borrow(cu8Dummy_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref52d2c6ab.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs52d2c6ab.Borrow(cu16SessionID_allocs)

	x.ref52d2c6ab = ref52d2c6ab
	x.allocs52d2c6ab = allocs52d2c6ab
	return ref52d2c6ab, allocs52d2c6ab

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CloseCmd) PassValue() (C.tstrCloseCmd, *cgoAllocMap) {
	if x.ref52d2c6ab != nil {
		return *x.ref52d2c6ab, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CloseCmd) Deref() {
	if x.ref52d2c6ab == nil {
		return
	}
	x.Sock = (int8)(x.ref52d2c6ab.sock)
	x.U8Dummy = (byte)(x.ref52d2c6ab.u8Dummy)
	x.U16SessionID = (uint16)(x.ref52d2c6ab.u16SessionID)
}

// allocConnectAlpnReplyMemory allocates memory for type C.tstrConnectAlpnReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConnectAlpnReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfConnectAlpnReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfConnectAlpnReplyValue = unsafe.Sizeof([1]C.tstrConnectAlpnReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConnectAlpnReply) Ref() *C.tstrConnectAlpnReply {
	if x == nil {
		return nil
	}
	return x.ref696c1533
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ConnectAlpnReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref696c1533)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ConnectAlpnReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConnectAlpnReply) Free() {
	if x != nil && x.allocs696c1533 != nil {
		x.allocs696c1533.(*cgoAllocMap).Free()
		x.ref696c1533 = nil
	}
}

// NewConnectAlpnReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConnectAlpnReplyRef(ref unsafe.Pointer) *ConnectAlpnReply {
	if ref == nil {
		return nil
	}
	obj := new(ConnectAlpnReply)
	obj.ref696c1533 = (*C.tstrConnectAlpnReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConnectAlpnReply) PassRef() (*C.tstrConnectAlpnReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref696c1533 != nil {
		return x.ref696c1533, nil
	}
	mem696c1533 := allocConnectAlpnReplyMemory(1)
	ref696c1533 := (*C.tstrConnectAlpnReply)(mem696c1533)
	allocs696c1533 := new(cgoAllocMap)
	allocs696c1533.Add(mem696c1533)

	var cstrConnReply_allocs *cgoAllocMap
	ref696c1533.strConnReply, cstrConnReply_allocs = x.StrConnReply.PassValue()
	allocs696c1533.Borrow(cstrConnReply_allocs)

	var cu8AppProtocolIdx_allocs *cgoAllocMap
	ref696c1533.u8AppProtocolIdx, cu8AppProtocolIdx_allocs = (C.uint8_t)(x.U8AppProtocolIdx), cgoAllocsUnknown
	allocs696c1533.Borrow(cu8AppProtocolIdx_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref696c1533.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs696c1533.Borrow(c__PAD24___allocs)

	x.ref696c1533 = ref696c1533
	x.allocs696c1533 = allocs696c1533
	return ref696c1533, allocs696c1533

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConnectAlpnReply) PassValue() (C.tstrConnectAlpnReply, *cgoAllocMap) {
	if x.ref696c1533 != nil {
		return *x.ref696c1533, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConnectAlpnReply) Deref() {
	if x.ref696c1533 == nil {
		return
	}
	x.StrConnReply = *NewConnectReplyRef(unsafe.Pointer(&x.ref696c1533.strConnReply))
	x.U8AppProtocolIdx = (byte)(x.ref696c1533.u8AppProtocolIdx)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref696c1533.__PAD24__))
}

// allocSendCmdMemory allocates memory for type C.tstrSendCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSendCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSendCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSendCmdValue = unsafe.Sizeof([1]C.tstrSendCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SendCmd) Ref() *C.tstrSendCmd {
	if x == nil {
		return nil
	}
	return x.ref4b2aedbb
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SendCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref4b2aedbb)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SendCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SendCmd) Free() {
	if x != nil && x.allocs4b2aedbb != nil {
		x.allocs4b2aedbb.(*cgoAllocMap).Free()
		x.ref4b2aedbb = nil
	}
}

// NewSendCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSendCmdRef(ref unsafe.Pointer) *SendCmd {
	if ref == nil {
		return nil
	}
	obj := new(SendCmd)
	obj.ref4b2aedbb = (*C.tstrSendCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SendCmd) PassRef() (*C.tstrSendCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b2aedbb != nil {
		return x.ref4b2aedbb, nil
	}
	mem4b2aedbb := allocSendCmdMemory(1)
	ref4b2aedbb := (*C.tstrSendCmd)(mem4b2aedbb)
	allocs4b2aedbb := new(cgoAllocMap)
	allocs4b2aedbb.Add(mem4b2aedbb)

	var csock_allocs *cgoAllocMap
	ref4b2aedbb.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs4b2aedbb.Borrow(csock_allocs)

	var cu8Void_allocs *cgoAllocMap
	ref4b2aedbb.u8Void, cu8Void_allocs = (C.uint8_t)(x.U8Void), cgoAllocsUnknown
	allocs4b2aedbb.Borrow(cu8Void_allocs)

	var cu16DataSize_allocs *cgoAllocMap
	ref4b2aedbb.u16DataSize, cu16DataSize_allocs = (C.uint16_t)(x.U16DataSize), cgoAllocsUnknown
	allocs4b2aedbb.Borrow(cu16DataSize_allocs)

	var cstrAddr_allocs *cgoAllocMap
	ref4b2aedbb.strAddr, cstrAddr_allocs = x.StrAddr.PassValue()
	allocs4b2aedbb.Borrow(cstrAddr_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref4b2aedbb.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs4b2aedbb.Borrow(cu16SessionID_allocs)

	var cu16Void_allocs *cgoAllocMap
	ref4b2aedbb.u16Void, cu16Void_allocs = (C.uint16_t)(x.U16Void), cgoAllocsUnknown
	allocs4b2aedbb.Borrow(cu16Void_allocs)

	x.ref4b2aedbb = ref4b2aedbb
	x.allocs4b2aedbb = allocs4b2aedbb
	return ref4b2aedbb, allocs4b2aedbb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SendCmd) PassValue() (C.tstrSendCmd, *cgoAllocMap) {
	if x.ref4b2aedbb != nil {
		return *x.ref4b2aedbb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SendCmd) Deref() {
	if x.ref4b2aedbb == nil {
		return
	}
	x.Sock = (int8)(x.ref4b2aedbb.sock)
	x.U8Void = (byte)(x.ref4b2aedbb.u8Void)
	x.U16DataSize = (uint16)(x.ref4b2aedbb.u16DataSize)
	x.StrAddr = *NewSockAddrRef(unsafe.Pointer(&x.ref4b2aedbb.strAddr))
	x.U16SessionID = (uint16)(x.ref4b2aedbb.u16SessionID)
	x.U16Void = (uint16)(x.ref4b2aedbb.u16Void)
}

// allocSendReplyMemory allocates memory for type C.tstrSendReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSendReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSendReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSendReplyValue = unsafe.Sizeof([1]C.tstrSendReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SendReply) Ref() *C.tstrSendReply {
	if x == nil {
		return nil
	}
	return x.reffbd9c021
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SendReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reffbd9c021)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SendReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SendReply) Free() {
	if x != nil && x.allocsfbd9c021 != nil {
		x.allocsfbd9c021.(*cgoAllocMap).Free()
		x.reffbd9c021 = nil
	}
}

// NewSendReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSendReplyRef(ref unsafe.Pointer) *SendReply {
	if ref == nil {
		return nil
	}
	obj := new(SendReply)
	obj.reffbd9c021 = (*C.tstrSendReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SendReply) PassRef() (*C.tstrSendReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffbd9c021 != nil {
		return x.reffbd9c021, nil
	}
	memfbd9c021 := allocSendReplyMemory(1)
	reffbd9c021 := (*C.tstrSendReply)(memfbd9c021)
	allocsfbd9c021 := new(cgoAllocMap)
	allocsfbd9c021.Add(memfbd9c021)

	var csock_allocs *cgoAllocMap
	reffbd9c021.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocsfbd9c021.Borrow(csock_allocs)

	var cu8Void_allocs *cgoAllocMap
	reffbd9c021.u8Void, cu8Void_allocs = (C.uint8_t)(x.U8Void), cgoAllocsUnknown
	allocsfbd9c021.Borrow(cu8Void_allocs)

	var cs16SentBytes_allocs *cgoAllocMap
	reffbd9c021.s16SentBytes, cs16SentBytes_allocs = (C.int16_t)(x.S16SentBytes), cgoAllocsUnknown
	allocsfbd9c021.Borrow(cs16SentBytes_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	reffbd9c021.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocsfbd9c021.Borrow(cu16SessionID_allocs)

	var cu16Void_allocs *cgoAllocMap
	reffbd9c021.u16Void, cu16Void_allocs = (C.uint16_t)(x.U16Void), cgoAllocsUnknown
	allocsfbd9c021.Borrow(cu16Void_allocs)

	x.reffbd9c021 = reffbd9c021
	x.allocsfbd9c021 = allocsfbd9c021
	return reffbd9c021, allocsfbd9c021

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SendReply) PassValue() (C.tstrSendReply, *cgoAllocMap) {
	if x.reffbd9c021 != nil {
		return *x.reffbd9c021, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SendReply) Deref() {
	if x.reffbd9c021 == nil {
		return
	}
	x.Sock = (int8)(x.reffbd9c021.sock)
	x.U8Void = (byte)(x.reffbd9c021.u8Void)
	x.S16SentBytes = (int16)(x.reffbd9c021.s16SentBytes)
	x.U16SessionID = (uint16)(x.reffbd9c021.u16SessionID)
	x.U16Void = (uint16)(x.reffbd9c021.u16Void)
}

// allocRecvCmdMemory allocates memory for type C.tstrRecvCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfRecvCmdValue = unsafe.Sizeof([1]C.tstrRecvCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvCmd) Ref() *C.tstrRecvCmd {
	if x == nil {
		return nil
	}
	return x.refefddbdaa
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *RecvCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refefddbdaa)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *RecvCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvCmd) Free() {
	if x != nil && x.allocsefddbdaa != nil {
		x.allocsefddbdaa.(*cgoAllocMap).Free()
		x.refefddbdaa = nil
	}
}

// NewRecvCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvCmdRef(ref unsafe.Pointer) *RecvCmd {
	if ref == nil {
		return nil
	}
	obj := new(RecvCmd)
	obj.refefddbdaa = (*C.tstrRecvCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvCmd) PassRef() (*C.tstrRecvCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refefddbdaa != nil {
		return x.refefddbdaa, nil
	}
	memefddbdaa := allocRecvCmdMemory(1)
	refefddbdaa := (*C.tstrRecvCmd)(memefddbdaa)
	allocsefddbdaa := new(cgoAllocMap)
	allocsefddbdaa.Add(memefddbdaa)

	var cu32Timeoutmsec_allocs *cgoAllocMap
	refefddbdaa.u32Timeoutmsec, cu32Timeoutmsec_allocs = (C.uint32_t)(x.U32Timeoutmsec), cgoAllocsUnknown
	allocsefddbdaa.Borrow(cu32Timeoutmsec_allocs)

	var csock_allocs *cgoAllocMap
	refefddbdaa.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocsefddbdaa.Borrow(csock_allocs)

	var cu8Void_allocs *cgoAllocMap
	refefddbdaa.u8Void, cu8Void_allocs = (C.uint8_t)(x.U8Void), cgoAllocsUnknown
	allocsefddbdaa.Borrow(cu8Void_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	refefddbdaa.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocsefddbdaa.Borrow(cu16SessionID_allocs)

	var cu16BufLen_allocs *cgoAllocMap
	refefddbdaa.u16BufLen, cu16BufLen_allocs = (C.uint16_t)(x.U16BufLen), cgoAllocsUnknown
	allocsefddbdaa.Borrow(cu16BufLen_allocs)

	x.refefddbdaa = refefddbdaa
	x.allocsefddbdaa = allocsefddbdaa
	return refefddbdaa, allocsefddbdaa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvCmd) PassValue() (C.tstrRecvCmd, *cgoAllocMap) {
	if x.refefddbdaa != nil {
		return *x.refefddbdaa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvCmd) Deref() {
	if x.refefddbdaa == nil {
		return
	}
	x.U32Timeoutmsec = (uint32)(x.refefddbdaa.u32Timeoutmsec)
	x.Sock = (int8)(x.refefddbdaa.sock)
	x.U8Void = (byte)(x.refefddbdaa.u8Void)
	x.U16SessionID = (uint16)(x.refefddbdaa.u16SessionID)
	x.U16BufLen = (uint16)(x.refefddbdaa.u16BufLen)
}

// allocRecvReplyMemory allocates memory for type C.tstrRecvReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRecvReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfRecvReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfRecvReplyValue = unsafe.Sizeof([1]C.tstrRecvReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RecvReply) Ref() *C.tstrRecvReply {
	if x == nil {
		return nil
	}
	return x.refc36b1632
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *RecvReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refc36b1632)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *RecvReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RecvReply) Free() {
	if x != nil && x.allocsc36b1632 != nil {
		x.allocsc36b1632.(*cgoAllocMap).Free()
		x.refc36b1632 = nil
	}
}

// NewRecvReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRecvReplyRef(ref unsafe.Pointer) *RecvReply {
	if ref == nil {
		return nil
	}
	obj := new(RecvReply)
	obj.refc36b1632 = (*C.tstrRecvReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RecvReply) PassRef() (*C.tstrRecvReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc36b1632 != nil {
		return x.refc36b1632, nil
	}
	memc36b1632 := allocRecvReplyMemory(1)
	refc36b1632 := (*C.tstrRecvReply)(memc36b1632)
	allocsc36b1632 := new(cgoAllocMap)
	allocsc36b1632.Add(memc36b1632)

	var cstrRemoteAddr_allocs *cgoAllocMap
	refc36b1632.strRemoteAddr, cstrRemoteAddr_allocs = x.StrRemoteAddr.PassValue()
	allocsc36b1632.Borrow(cstrRemoteAddr_allocs)

	var cs16RecvStatus_allocs *cgoAllocMap
	refc36b1632.s16RecvStatus, cs16RecvStatus_allocs = (C.int16_t)(x.S16RecvStatus), cgoAllocsUnknown
	allocsc36b1632.Borrow(cs16RecvStatus_allocs)

	var cu16DataOffset_allocs *cgoAllocMap
	refc36b1632.u16DataOffset, cu16DataOffset_allocs = (C.uint16_t)(x.U16DataOffset), cgoAllocsUnknown
	allocsc36b1632.Borrow(cu16DataOffset_allocs)

	var csock_allocs *cgoAllocMap
	refc36b1632.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocsc36b1632.Borrow(csock_allocs)

	var cu8Void_allocs *cgoAllocMap
	refc36b1632.u8Void, cu8Void_allocs = (C.uint8_t)(x.U8Void), cgoAllocsUnknown
	allocsc36b1632.Borrow(cu8Void_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	refc36b1632.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocsc36b1632.Borrow(cu16SessionID_allocs)

	x.refc36b1632 = refc36b1632
	x.allocsc36b1632 = allocsc36b1632
	return refc36b1632, allocsc36b1632

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RecvReply) PassValue() (C.tstrRecvReply, *cgoAllocMap) {
	if x.refc36b1632 != nil {
		return *x.refc36b1632, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *RecvReply) Deref() {
	if x.refc36b1632 == nil {
		return
	}
	x.StrRemoteAddr = *NewSockAddrRef(unsafe.Pointer(&x.refc36b1632.strRemoteAddr))
	x.S16RecvStatus = (int16)(x.refc36b1632.s16RecvStatus)
	x.U16DataOffset = (uint16)(x.refc36b1632.u16DataOffset)
	x.Sock = (int8)(x.refc36b1632.sock)
	x.U8Void = (byte)(x.refc36b1632.u8Void)
	x.U16SessionID = (uint16)(x.refc36b1632.u16SessionID)
}

// allocSetSocketOptCmdMemory allocates memory for type C.tstrSetSocketOptCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSetSocketOptCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSetSocketOptCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSetSocketOptCmdValue = unsafe.Sizeof([1]C.tstrSetSocketOptCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SetSocketOptCmd) Ref() *C.tstrSetSocketOptCmd {
	if x == nil {
		return nil
	}
	return x.ref2d3fd62a
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SetSocketOptCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref2d3fd62a)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SetSocketOptCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SetSocketOptCmd) Free() {
	if x != nil && x.allocs2d3fd62a != nil {
		x.allocs2d3fd62a.(*cgoAllocMap).Free()
		x.ref2d3fd62a = nil
	}
}

// NewSetSocketOptCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSetSocketOptCmdRef(ref unsafe.Pointer) *SetSocketOptCmd {
	if ref == nil {
		return nil
	}
	obj := new(SetSocketOptCmd)
	obj.ref2d3fd62a = (*C.tstrSetSocketOptCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SetSocketOptCmd) PassRef() (*C.tstrSetSocketOptCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2d3fd62a != nil {
		return x.ref2d3fd62a, nil
	}
	mem2d3fd62a := allocSetSocketOptCmdMemory(1)
	ref2d3fd62a := (*C.tstrSetSocketOptCmd)(mem2d3fd62a)
	allocs2d3fd62a := new(cgoAllocMap)
	allocs2d3fd62a.Add(mem2d3fd62a)

	var cu32OptionValue_allocs *cgoAllocMap
	ref2d3fd62a.u32OptionValue, cu32OptionValue_allocs = (C.uint32_t)(x.U32OptionValue), cgoAllocsUnknown
	allocs2d3fd62a.Borrow(cu32OptionValue_allocs)

	var csock_allocs *cgoAllocMap
	ref2d3fd62a.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs2d3fd62a.Borrow(csock_allocs)

	var cu8Option_allocs *cgoAllocMap
	ref2d3fd62a.u8Option, cu8Option_allocs = (C.uint8_t)(x.U8Option), cgoAllocsUnknown
	allocs2d3fd62a.Borrow(cu8Option_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref2d3fd62a.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs2d3fd62a.Borrow(cu16SessionID_allocs)

	x.ref2d3fd62a = ref2d3fd62a
	x.allocs2d3fd62a = allocs2d3fd62a
	return ref2d3fd62a, allocs2d3fd62a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SetSocketOptCmd) PassValue() (C.tstrSetSocketOptCmd, *cgoAllocMap) {
	if x.ref2d3fd62a != nil {
		return *x.ref2d3fd62a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SetSocketOptCmd) Deref() {
	if x.ref2d3fd62a == nil {
		return
	}
	x.U32OptionValue = (uint32)(x.ref2d3fd62a.u32OptionValue)
	x.Sock = (int8)(x.ref2d3fd62a.sock)
	x.U8Option = (byte)(x.ref2d3fd62a.u8Option)
	x.U16SessionID = (uint16)(x.ref2d3fd62a.u16SessionID)
}

// allocSSLSocketCreateCmdMemory allocates memory for type C.tstrSSLSocketCreateCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSSLSocketCreateCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSSLSocketCreateCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSSLSocketCreateCmdValue = unsafe.Sizeof([1]C.tstrSSLSocketCreateCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SSLSocketCreateCmd) Ref() *C.tstrSSLSocketCreateCmd {
	if x == nil {
		return nil
	}
	return x.refa5924504
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SSLSocketCreateCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refa5924504)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SSLSocketCreateCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SSLSocketCreateCmd) Free() {
	if x != nil && x.allocsa5924504 != nil {
		x.allocsa5924504.(*cgoAllocMap).Free()
		x.refa5924504 = nil
	}
}

// NewSSLSocketCreateCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSSLSocketCreateCmdRef(ref unsafe.Pointer) *SSLSocketCreateCmd {
	if ref == nil {
		return nil
	}
	obj := new(SSLSocketCreateCmd)
	obj.refa5924504 = (*C.tstrSSLSocketCreateCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SSLSocketCreateCmd) PassRef() (*C.tstrSSLSocketCreateCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa5924504 != nil {
		return x.refa5924504, nil
	}
	mema5924504 := allocSSLSocketCreateCmdMemory(1)
	refa5924504 := (*C.tstrSSLSocketCreateCmd)(mema5924504)
	allocsa5924504 := new(cgoAllocMap)
	allocsa5924504.Add(mema5924504)

	var csslSock_allocs *cgoAllocMap
	refa5924504.sslSock, csslSock_allocs = (C.SOCKET)(x.SslSock), cgoAllocsUnknown
	allocsa5924504.Borrow(csslSock_allocs)

	var c__PAD24___allocs *cgoAllocMap
	refa5924504.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocsa5924504.Borrow(c__PAD24___allocs)

	x.refa5924504 = refa5924504
	x.allocsa5924504 = allocsa5924504
	return refa5924504, allocsa5924504

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SSLSocketCreateCmd) PassValue() (C.tstrSSLSocketCreateCmd, *cgoAllocMap) {
	if x.refa5924504 != nil {
		return *x.refa5924504, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SSLSocketCreateCmd) Deref() {
	if x.refa5924504 == nil {
		return
	}
	x.SslSock = (int8)(x.refa5924504.sslSock)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.refa5924504.__PAD24__))
}

// allocSSLSetSockOptCmdMemory allocates memory for type C.tstrSSLSetSockOptCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSSLSetSockOptCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSSLSetSockOptCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSSLSetSockOptCmdValue = unsafe.Sizeof([1]C.tstrSSLSetSockOptCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SSLSetSockOptCmd) Ref() *C.tstrSSLSetSockOptCmd {
	if x == nil {
		return nil
	}
	return x.ref75a4c4a8
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SSLSetSockOptCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref75a4c4a8)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SSLSetSockOptCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SSLSetSockOptCmd) Free() {
	if x != nil && x.allocs75a4c4a8 != nil {
		x.allocs75a4c4a8.(*cgoAllocMap).Free()
		x.ref75a4c4a8 = nil
	}
}

// NewSSLSetSockOptCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSSLSetSockOptCmdRef(ref unsafe.Pointer) *SSLSetSockOptCmd {
	if ref == nil {
		return nil
	}
	obj := new(SSLSetSockOptCmd)
	obj.ref75a4c4a8 = (*C.tstrSSLSetSockOptCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SSLSetSockOptCmd) PassRef() (*C.tstrSSLSetSockOptCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75a4c4a8 != nil {
		return x.ref75a4c4a8, nil
	}
	mem75a4c4a8 := allocSSLSetSockOptCmdMemory(1)
	ref75a4c4a8 := (*C.tstrSSLSetSockOptCmd)(mem75a4c4a8)
	allocs75a4c4a8 := new(cgoAllocMap)
	allocs75a4c4a8.Add(mem75a4c4a8)

	var csock_allocs *cgoAllocMap
	ref75a4c4a8.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs75a4c4a8.Borrow(csock_allocs)

	var cu8Option_allocs *cgoAllocMap
	ref75a4c4a8.u8Option, cu8Option_allocs = (C.uint8_t)(x.U8Option), cgoAllocsUnknown
	allocs75a4c4a8.Borrow(cu8Option_allocs)

	var cu16SessionID_allocs *cgoAllocMap
	ref75a4c4a8.u16SessionID, cu16SessionID_allocs = (C.uint16_t)(x.U16SessionID), cgoAllocsUnknown
	allocs75a4c4a8.Borrow(cu16SessionID_allocs)

	var cu32OptLen_allocs *cgoAllocMap
	ref75a4c4a8.u32OptLen, cu32OptLen_allocs = (C.uint32_t)(x.U32OptLen), cgoAllocsUnknown
	allocs75a4c4a8.Borrow(cu32OptLen_allocs)

	var cau8OptVal_allocs *cgoAllocMap
	ref75a4c4a8.au8OptVal, cau8OptVal_allocs = *(*[64]C.uint8_t)(unsafe.Pointer(&x.Au8OptVal)), cgoAllocsUnknown
	allocs75a4c4a8.Borrow(cau8OptVal_allocs)

	x.ref75a4c4a8 = ref75a4c4a8
	x.allocs75a4c4a8 = allocs75a4c4a8
	return ref75a4c4a8, allocs75a4c4a8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SSLSetSockOptCmd) PassValue() (C.tstrSSLSetSockOptCmd, *cgoAllocMap) {
	if x.ref75a4c4a8 != nil {
		return *x.ref75a4c4a8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SSLSetSockOptCmd) Deref() {
	if x.ref75a4c4a8 == nil {
		return
	}
	x.Sock = (int8)(x.ref75a4c4a8.sock)
	x.U8Option = (byte)(x.ref75a4c4a8.u8Option)
	x.U16SessionID = (uint16)(x.ref75a4c4a8.u16SessionID)
	x.U32OptLen = (uint32)(x.ref75a4c4a8.u32OptLen)
	x.Au8OptVal = *(*[64]byte)(unsafe.Pointer(&x.ref75a4c4a8.au8OptVal))
}

// allocPingCmdMemory allocates memory for type C.tstrPingCmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPingCmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfPingCmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfPingCmdValue = unsafe.Sizeof([1]C.tstrPingCmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PingCmd) Ref() *C.tstrPingCmd {
	if x == nil {
		return nil
	}
	return x.ref1fb598b3
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *PingCmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref1fb598b3)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *PingCmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PingCmd) Free() {
	if x != nil && x.allocs1fb598b3 != nil {
		x.allocs1fb598b3.(*cgoAllocMap).Free()
		x.ref1fb598b3 = nil
	}
}

// NewPingCmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPingCmdRef(ref unsafe.Pointer) *PingCmd {
	if ref == nil {
		return nil
	}
	obj := new(PingCmd)
	obj.ref1fb598b3 = (*C.tstrPingCmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PingCmd) PassRef() (*C.tstrPingCmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1fb598b3 != nil {
		return x.ref1fb598b3, nil
	}
	mem1fb598b3 := allocPingCmdMemory(1)
	ref1fb598b3 := (*C.tstrPingCmd)(mem1fb598b3)
	allocs1fb598b3 := new(cgoAllocMap)
	allocs1fb598b3.Add(mem1fb598b3)

	var cu32DestIPAddr_allocs *cgoAllocMap
	ref1fb598b3.u32DestIPAddr, cu32DestIPAddr_allocs = (C.uint32_t)(x.U32DestIPAddr), cgoAllocsUnknown
	allocs1fb598b3.Borrow(cu32DestIPAddr_allocs)

	var cu32CmdPrivate_allocs *cgoAllocMap
	ref1fb598b3.u32CmdPrivate, cu32CmdPrivate_allocs = (C.uint32_t)(x.U32CmdPrivate), cgoAllocsUnknown
	allocs1fb598b3.Borrow(cu32CmdPrivate_allocs)

	var cu16PingCount_allocs *cgoAllocMap
	ref1fb598b3.u16PingCount, cu16PingCount_allocs = (C.uint16_t)(x.U16PingCount), cgoAllocsUnknown
	allocs1fb598b3.Borrow(cu16PingCount_allocs)

	var cu8TTL_allocs *cgoAllocMap
	ref1fb598b3.u8TTL, cu8TTL_allocs = (C.uint8_t)(x.U8TTL), cgoAllocsUnknown
	allocs1fb598b3.Borrow(cu8TTL_allocs)

	var c__PAD8___allocs *cgoAllocMap
	ref1fb598b3.__PAD8__, c__PAD8___allocs = (C.uint8_t)(x.__PAD8__), cgoAllocsUnknown
	allocs1fb598b3.Borrow(c__PAD8___allocs)

	x.ref1fb598b3 = ref1fb598b3
	x.allocs1fb598b3 = allocs1fb598b3
	return ref1fb598b3, allocs1fb598b3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PingCmd) PassValue() (C.tstrPingCmd, *cgoAllocMap) {
	if x.ref1fb598b3 != nil {
		return *x.ref1fb598b3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PingCmd) Deref() {
	if x.ref1fb598b3 == nil {
		return
	}
	x.U32DestIPAddr = (uint32)(x.ref1fb598b3.u32DestIPAddr)
	x.U32CmdPrivate = (uint32)(x.ref1fb598b3.u32CmdPrivate)
	x.U16PingCount = (uint16)(x.ref1fb598b3.u16PingCount)
	x.U8TTL = (byte)(x.ref1fb598b3.u8TTL)
	x.__PAD8__ = (byte)(x.ref1fb598b3.__PAD8__)
}

// allocPingReplyMemory allocates memory for type C.tstrPingReply in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPingReplyMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfPingReplyValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfPingReplyValue = unsafe.Sizeof([1]C.tstrPingReply{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PingReply) Ref() *C.tstrPingReply {
	if x == nil {
		return nil
	}
	return x.ref136f9b05
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *PingReply) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref136f9b05)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *PingReply) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PingReply) Free() {
	if x != nil && x.allocs136f9b05 != nil {
		x.allocs136f9b05.(*cgoAllocMap).Free()
		x.ref136f9b05 = nil
	}
}

// NewPingReplyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPingReplyRef(ref unsafe.Pointer) *PingReply {
	if ref == nil {
		return nil
	}
	obj := new(PingReply)
	obj.ref136f9b05 = (*C.tstrPingReply)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PingReply) PassRef() (*C.tstrPingReply, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref136f9b05 != nil {
		return x.ref136f9b05, nil
	}
	mem136f9b05 := allocPingReplyMemory(1)
	ref136f9b05 := (*C.tstrPingReply)(mem136f9b05)
	allocs136f9b05 := new(cgoAllocMap)
	allocs136f9b05.Add(mem136f9b05)

	var cu32IPAddr_allocs *cgoAllocMap
	ref136f9b05.u32IPAddr, cu32IPAddr_allocs = (C.uint32_t)(x.U32IPAddr), cgoAllocsUnknown
	allocs136f9b05.Borrow(cu32IPAddr_allocs)

	var cu32CmdPrivate_allocs *cgoAllocMap
	ref136f9b05.u32CmdPrivate, cu32CmdPrivate_allocs = (C.uint32_t)(x.U32CmdPrivate), cgoAllocsUnknown
	allocs136f9b05.Borrow(cu32CmdPrivate_allocs)

	var cu32RTT_allocs *cgoAllocMap
	ref136f9b05.u32RTT, cu32RTT_allocs = (C.uint32_t)(x.U32RTT), cgoAllocsUnknown
	allocs136f9b05.Borrow(cu32RTT_allocs)

	var cu16Success_allocs *cgoAllocMap
	ref136f9b05.u16Success, cu16Success_allocs = (C.uint16_t)(x.U16Success), cgoAllocsUnknown
	allocs136f9b05.Borrow(cu16Success_allocs)

	var cu16Fail_allocs *cgoAllocMap
	ref136f9b05.u16Fail, cu16Fail_allocs = (C.uint16_t)(x.U16Fail), cgoAllocsUnknown
	allocs136f9b05.Borrow(cu16Fail_allocs)

	var cu8ErrorCode_allocs *cgoAllocMap
	ref136f9b05.u8ErrorCode, cu8ErrorCode_allocs = (C.uint8_t)(x.U8ErrorCode), cgoAllocsUnknown
	allocs136f9b05.Borrow(cu8ErrorCode_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref136f9b05.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs136f9b05.Borrow(c__PAD24___allocs)

	x.ref136f9b05 = ref136f9b05
	x.allocs136f9b05 = allocs136f9b05
	return ref136f9b05, allocs136f9b05

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PingReply) PassValue() (C.tstrPingReply, *cgoAllocMap) {
	if x.ref136f9b05 != nil {
		return *x.ref136f9b05, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *PingReply) Deref() {
	if x.ref136f9b05 == nil {
		return
	}
	x.U32IPAddr = (uint32)(x.ref136f9b05.u32IPAddr)
	x.U32CmdPrivate = (uint32)(x.ref136f9b05.u32CmdPrivate)
	x.U32RTT = (uint32)(x.ref136f9b05.u32RTT)
	x.U16Success = (uint16)(x.ref136f9b05.u16Success)
	x.U16Fail = (uint16)(x.ref136f9b05.u16Fail)
	x.U8ErrorCode = (byte)(x.ref136f9b05.u8ErrorCode)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref136f9b05.__PAD24__))
}

// allocSslCertExpSettingsMemory allocates memory for type C.tstrSslCertExpSettings in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSslCertExpSettingsMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSslCertExpSettingsValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSslCertExpSettingsValue = unsafe.Sizeof([1]C.tstrSslCertExpSettings{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SslCertExpSettings) Ref() *C.tstrSslCertExpSettings {
	if x == nil {
		return nil
	}
	return x.reff3e2216d
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SslCertExpSettings) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reff3e2216d)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SslCertExpSettings) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SslCertExpSettings) Free() {
	if x != nil && x.allocsf3e2216d != nil {
		x.allocsf3e2216d.(*cgoAllocMap).Free()
		x.reff3e2216d = nil
	}
}

// NewSslCertExpSettingsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSslCertExpSettingsRef(ref unsafe.Pointer) *SslCertExpSettings {
	if ref == nil {
		return nil
	}
	obj := new(SslCertExpSettings)
	obj.reff3e2216d = (*C.tstrSslCertExpSettings)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SslCertExpSettings) PassRef() (*C.tstrSslCertExpSettings, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff3e2216d != nil {
		return x.reff3e2216d, nil
	}
	memf3e2216d := allocSslCertExpSettingsMemory(1)
	reff3e2216d := (*C.tstrSslCertExpSettings)(memf3e2216d)
	allocsf3e2216d := new(cgoAllocMap)
	allocsf3e2216d.Add(memf3e2216d)

	var cu32CertExpValidationOpt_allocs *cgoAllocMap
	reff3e2216d.u32CertExpValidationOpt, cu32CertExpValidationOpt_allocs = (C.uint32_t)(x.U32CertExpValidationOpt), cgoAllocsUnknown
	allocsf3e2216d.Borrow(cu32CertExpValidationOpt_allocs)

	x.reff3e2216d = reff3e2216d
	x.allocsf3e2216d = allocsf3e2216d
	return reff3e2216d, allocsf3e2216d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SslCertExpSettings) PassValue() (C.tstrSslCertExpSettings, *cgoAllocMap) {
	if x.reff3e2216d != nil {
		return *x.reff3e2216d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SslCertExpSettings) Deref() {
	if x.reff3e2216d == nil {
		return
	}
	x.U32CertExpValidationOpt = (uint32)(x.reff3e2216d.u32CertExpValidationOpt)
}

// allocM2mPwrModeMemory allocates memory for type C.tstrM2mPwrMode in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mPwrModeMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mPwrModeValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mPwrModeValue = unsafe.Sizeof([1]C.tstrM2mPwrMode{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mPwrMode) Ref() *C.tstrM2mPwrMode {
	if x == nil {
		return nil
	}
	return x.ref247585ac
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mPwrMode) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref247585ac)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mPwrMode) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mPwrMode) Free() {
	if x != nil && x.allocs247585ac != nil {
		x.allocs247585ac.(*cgoAllocMap).Free()
		x.ref247585ac = nil
	}
}

// NewM2mPwrModeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mPwrModeRef(ref unsafe.Pointer) *M2mPwrMode {
	if ref == nil {
		return nil
	}
	obj := new(M2mPwrMode)
	obj.ref247585ac = (*C.tstrM2mPwrMode)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mPwrMode) PassRef() (*C.tstrM2mPwrMode, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref247585ac != nil {
		return x.ref247585ac, nil
	}
	mem247585ac := allocM2mPwrModeMemory(1)
	ref247585ac := (*C.tstrM2mPwrMode)(mem247585ac)
	allocs247585ac := new(cgoAllocMap)
	allocs247585ac.Add(mem247585ac)

	var cu8PwrMode_allocs *cgoAllocMap
	ref247585ac.u8PwrMode, cu8PwrMode_allocs = (C.uint8_t)(x.U8PwrMode), cgoAllocsUnknown
	allocs247585ac.Borrow(cu8PwrMode_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref247585ac.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs247585ac.Borrow(c__PAD24___allocs)

	x.ref247585ac = ref247585ac
	x.allocs247585ac = allocs247585ac
	return ref247585ac, allocs247585ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mPwrMode) PassValue() (C.tstrM2mPwrMode, *cgoAllocMap) {
	if x.ref247585ac != nil {
		return *x.ref247585ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mPwrMode) Deref() {
	if x.ref247585ac == nil {
		return
	}
	x.U8PwrMode = (byte)(x.ref247585ac.u8PwrMode)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref247585ac.__PAD24__))
}

// allocM2mTxPwrLevelMemory allocates memory for type C.tstrM2mTxPwrLevel in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mTxPwrLevelMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mTxPwrLevelValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mTxPwrLevelValue = unsafe.Sizeof([1]C.tstrM2mTxPwrLevel{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mTxPwrLevel) Ref() *C.tstrM2mTxPwrLevel {
	if x == nil {
		return nil
	}
	return x.ref6aa1b7e0
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mTxPwrLevel) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref6aa1b7e0)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mTxPwrLevel) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mTxPwrLevel) Free() {
	if x != nil && x.allocs6aa1b7e0 != nil {
		x.allocs6aa1b7e0.(*cgoAllocMap).Free()
		x.ref6aa1b7e0 = nil
	}
}

// NewM2mTxPwrLevelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mTxPwrLevelRef(ref unsafe.Pointer) *M2mTxPwrLevel {
	if ref == nil {
		return nil
	}
	obj := new(M2mTxPwrLevel)
	obj.ref6aa1b7e0 = (*C.tstrM2mTxPwrLevel)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mTxPwrLevel) PassRef() (*C.tstrM2mTxPwrLevel, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6aa1b7e0 != nil {
		return x.ref6aa1b7e0, nil
	}
	mem6aa1b7e0 := allocM2mTxPwrLevelMemory(1)
	ref6aa1b7e0 := (*C.tstrM2mTxPwrLevel)(mem6aa1b7e0)
	allocs6aa1b7e0 := new(cgoAllocMap)
	allocs6aa1b7e0.Add(mem6aa1b7e0)

	var cu8TxPwrLevel_allocs *cgoAllocMap
	ref6aa1b7e0.u8TxPwrLevel, cu8TxPwrLevel_allocs = (C.uint8_t)(x.U8TxPwrLevel), cgoAllocsUnknown
	allocs6aa1b7e0.Borrow(cu8TxPwrLevel_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref6aa1b7e0.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs6aa1b7e0.Borrow(c__PAD24___allocs)

	x.ref6aa1b7e0 = ref6aa1b7e0
	x.allocs6aa1b7e0 = allocs6aa1b7e0
	return ref6aa1b7e0, allocs6aa1b7e0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mTxPwrLevel) PassValue() (C.tstrM2mTxPwrLevel, *cgoAllocMap) {
	if x.ref6aa1b7e0 != nil {
		return *x.ref6aa1b7e0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mTxPwrLevel) Deref() {
	if x.ref6aa1b7e0 == nil {
		return
	}
	x.U8TxPwrLevel = (byte)(x.ref6aa1b7e0.u8TxPwrLevel)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref6aa1b7e0.__PAD24__))
}

// allocM2mWiFiGainIdxMemory allocates memory for type C.tstrM2mWiFiGainIdx in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWiFiGainIdxMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWiFiGainIdxValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWiFiGainIdxValue = unsafe.Sizeof([1]C.tstrM2mWiFiGainIdx{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWiFiGainIdx) Ref() *C.tstrM2mWiFiGainIdx {
	if x == nil {
		return nil
	}
	return x.ref2363fa99
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWiFiGainIdx) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref2363fa99)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWiFiGainIdx) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWiFiGainIdx) Free() {
	if x != nil && x.allocs2363fa99 != nil {
		x.allocs2363fa99.(*cgoAllocMap).Free()
		x.ref2363fa99 = nil
	}
}

// NewM2mWiFiGainIdxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWiFiGainIdxRef(ref unsafe.Pointer) *M2mWiFiGainIdx {
	if ref == nil {
		return nil
	}
	obj := new(M2mWiFiGainIdx)
	obj.ref2363fa99 = (*C.tstrM2mWiFiGainIdx)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWiFiGainIdx) PassRef() (*C.tstrM2mWiFiGainIdx, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2363fa99 != nil {
		return x.ref2363fa99, nil
	}
	mem2363fa99 := allocM2mWiFiGainIdxMemory(1)
	ref2363fa99 := (*C.tstrM2mWiFiGainIdx)(mem2363fa99)
	allocs2363fa99 := new(cgoAllocMap)
	allocs2363fa99.Add(mem2363fa99)

	var cu8GainTableIdx_allocs *cgoAllocMap
	ref2363fa99.u8GainTableIdx, cu8GainTableIdx_allocs = (C.uint8_t)(x.U8GainTableIdx), cgoAllocsUnknown
	allocs2363fa99.Borrow(cu8GainTableIdx_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref2363fa99.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs2363fa99.Borrow(c__PAD24___allocs)

	x.ref2363fa99 = ref2363fa99
	x.allocs2363fa99 = allocs2363fa99
	return ref2363fa99, allocs2363fa99

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWiFiGainIdx) PassValue() (C.tstrM2mWiFiGainIdx, *cgoAllocMap) {
	if x.ref2363fa99 != nil {
		return *x.ref2363fa99, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWiFiGainIdx) Deref() {
	if x.ref2363fa99 == nil {
		return
	}
	x.U8GainTableIdx = (byte)(x.ref2363fa99.u8GainTableIdx)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref2363fa99.__PAD24__))
}

// allocM2mEnableLogsMemory allocates memory for type C.tstrM2mEnableLogs in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mEnableLogsMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mEnableLogsValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mEnableLogsValue = unsafe.Sizeof([1]C.tstrM2mEnableLogs{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mEnableLogs) Ref() *C.tstrM2mEnableLogs {
	if x == nil {
		return nil
	}
	return x.ref8568bfe5
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mEnableLogs) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref8568bfe5)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mEnableLogs) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mEnableLogs) Free() {
	if x != nil && x.allocs8568bfe5 != nil {
		x.allocs8568bfe5.(*cgoAllocMap).Free()
		x.ref8568bfe5 = nil
	}
}

// NewM2mEnableLogsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mEnableLogsRef(ref unsafe.Pointer) *M2mEnableLogs {
	if ref == nil {
		return nil
	}
	obj := new(M2mEnableLogs)
	obj.ref8568bfe5 = (*C.tstrM2mEnableLogs)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mEnableLogs) PassRef() (*C.tstrM2mEnableLogs, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8568bfe5 != nil {
		return x.ref8568bfe5, nil
	}
	mem8568bfe5 := allocM2mEnableLogsMemory(1)
	ref8568bfe5 := (*C.tstrM2mEnableLogs)(mem8568bfe5)
	allocs8568bfe5 := new(cgoAllocMap)
	allocs8568bfe5.Add(mem8568bfe5)

	var cu8Enable_allocs *cgoAllocMap
	ref8568bfe5.u8Enable, cu8Enable_allocs = (C.uint8_t)(x.U8Enable), cgoAllocsUnknown
	allocs8568bfe5.Borrow(cu8Enable_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref8568bfe5.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs8568bfe5.Borrow(c__PAD24___allocs)

	x.ref8568bfe5 = ref8568bfe5
	x.allocs8568bfe5 = allocs8568bfe5
	return ref8568bfe5, allocs8568bfe5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mEnableLogs) PassValue() (C.tstrM2mEnableLogs, *cgoAllocMap) {
	if x.ref8568bfe5 != nil {
		return *x.ref8568bfe5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mEnableLogs) Deref() {
	if x.ref8568bfe5 == nil {
		return
	}
	x.U8Enable = (byte)(x.ref8568bfe5.u8Enable)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref8568bfe5.__PAD24__))
}

// allocM2mBatteryVoltageMemory allocates memory for type C.tstrM2mBatteryVoltage in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mBatteryVoltageMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mBatteryVoltageValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mBatteryVoltageValue = unsafe.Sizeof([1]C.tstrM2mBatteryVoltage{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mBatteryVoltage) Ref() *C.tstrM2mBatteryVoltage {
	if x == nil {
		return nil
	}
	return x.refdef96f15
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mBatteryVoltage) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refdef96f15)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mBatteryVoltage) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mBatteryVoltage) Free() {
	if x != nil && x.allocsdef96f15 != nil {
		x.allocsdef96f15.(*cgoAllocMap).Free()
		x.refdef96f15 = nil
	}
}

// NewM2mBatteryVoltageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mBatteryVoltageRef(ref unsafe.Pointer) *M2mBatteryVoltage {
	if ref == nil {
		return nil
	}
	obj := new(M2mBatteryVoltage)
	obj.refdef96f15 = (*C.tstrM2mBatteryVoltage)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mBatteryVoltage) PassRef() (*C.tstrM2mBatteryVoltage, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdef96f15 != nil {
		return x.refdef96f15, nil
	}
	memdef96f15 := allocM2mBatteryVoltageMemory(1)
	refdef96f15 := (*C.tstrM2mBatteryVoltage)(memdef96f15)
	allocsdef96f15 := new(cgoAllocMap)
	allocsdef96f15.Add(memdef96f15)

	var cu16BattVolt_allocs *cgoAllocMap
	refdef96f15.u16BattVolt, cu16BattVolt_allocs = (C.uint16_t)(x.U16BattVolt), cgoAllocsUnknown
	allocsdef96f15.Borrow(cu16BattVolt_allocs)

	var c__PAD16___allocs *cgoAllocMap
	refdef96f15.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocsdef96f15.Borrow(c__PAD16___allocs)

	x.refdef96f15 = refdef96f15
	x.allocsdef96f15 = allocsdef96f15
	return refdef96f15, allocsdef96f15

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mBatteryVoltage) PassValue() (C.tstrM2mBatteryVoltage, *cgoAllocMap) {
	if x.refdef96f15 != nil {
		return *x.refdef96f15, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mBatteryVoltage) Deref() {
	if x.refdef96f15 == nil {
		return
	}
	x.U16BattVolt = (uint16)(x.refdef96f15.u16BattVolt)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.refdef96f15.__PAD16__))
}

// allocM2mWiFiRoamingMemory allocates memory for type C.tstrM2mWiFiRoaming in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWiFiRoamingMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWiFiRoamingValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWiFiRoamingValue = unsafe.Sizeof([1]C.tstrM2mWiFiRoaming{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWiFiRoaming) Ref() *C.tstrM2mWiFiRoaming {
	if x == nil {
		return nil
	}
	return x.ref41e06f30
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWiFiRoaming) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref41e06f30)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWiFiRoaming) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWiFiRoaming) Free() {
	if x != nil && x.allocs41e06f30 != nil {
		x.allocs41e06f30.(*cgoAllocMap).Free()
		x.ref41e06f30 = nil
	}
}

// NewM2mWiFiRoamingRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWiFiRoamingRef(ref unsafe.Pointer) *M2mWiFiRoaming {
	if ref == nil {
		return nil
	}
	obj := new(M2mWiFiRoaming)
	obj.ref41e06f30 = (*C.tstrM2mWiFiRoaming)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWiFiRoaming) PassRef() (*C.tstrM2mWiFiRoaming, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref41e06f30 != nil {
		return x.ref41e06f30, nil
	}
	mem41e06f30 := allocM2mWiFiRoamingMemory(1)
	ref41e06f30 := (*C.tstrM2mWiFiRoaming)(mem41e06f30)
	allocs41e06f30 := new(cgoAllocMap)
	allocs41e06f30.Add(mem41e06f30)

	var cu8EnableRoaming_allocs *cgoAllocMap
	ref41e06f30.u8EnableRoaming, cu8EnableRoaming_allocs = (C.uint8_t)(x.U8EnableRoaming), cgoAllocsUnknown
	allocs41e06f30.Borrow(cu8EnableRoaming_allocs)

	var cu8EnableDhcp_allocs *cgoAllocMap
	ref41e06f30.u8EnableDhcp, cu8EnableDhcp_allocs = (C.uint8_t)(x.U8EnableDhcp), cgoAllocsUnknown
	allocs41e06f30.Borrow(cu8EnableDhcp_allocs)

	var c__PAD16___allocs *cgoAllocMap
	ref41e06f30.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocs41e06f30.Borrow(c__PAD16___allocs)

	x.ref41e06f30 = ref41e06f30
	x.allocs41e06f30 = allocs41e06f30
	return ref41e06f30, allocs41e06f30

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWiFiRoaming) PassValue() (C.tstrM2mWiFiRoaming, *cgoAllocMap) {
	if x.ref41e06f30 != nil {
		return *x.ref41e06f30, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWiFiRoaming) Deref() {
	if x.ref41e06f30 == nil {
		return
	}
	x.U8EnableRoaming = (byte)(x.ref41e06f30.u8EnableRoaming)
	x.U8EnableDhcp = (byte)(x.ref41e06f30.u8EnableDhcp)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.ref41e06f30.__PAD16__))
}

// allocM2mWiFiXOSleepEnableMemory allocates memory for type C.tstrM2mWiFiXOSleepEnable in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWiFiXOSleepEnableMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWiFiXOSleepEnableValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWiFiXOSleepEnableValue = unsafe.Sizeof([1]C.tstrM2mWiFiXOSleepEnable{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWiFiXOSleepEnable) Ref() *C.tstrM2mWiFiXOSleepEnable {
	if x == nil {
		return nil
	}
	return x.refe8bee5c5
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWiFiXOSleepEnable) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refe8bee5c5)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWiFiXOSleepEnable) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWiFiXOSleepEnable) Free() {
	if x != nil && x.allocse8bee5c5 != nil {
		x.allocse8bee5c5.(*cgoAllocMap).Free()
		x.refe8bee5c5 = nil
	}
}

// NewM2mWiFiXOSleepEnableRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWiFiXOSleepEnableRef(ref unsafe.Pointer) *M2mWiFiXOSleepEnable {
	if ref == nil {
		return nil
	}
	obj := new(M2mWiFiXOSleepEnable)
	obj.refe8bee5c5 = (*C.tstrM2mWiFiXOSleepEnable)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWiFiXOSleepEnable) PassRef() (*C.tstrM2mWiFiXOSleepEnable, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe8bee5c5 != nil {
		return x.refe8bee5c5, nil
	}
	meme8bee5c5 := allocM2mWiFiXOSleepEnableMemory(1)
	refe8bee5c5 := (*C.tstrM2mWiFiXOSleepEnable)(meme8bee5c5)
	allocse8bee5c5 := new(cgoAllocMap)
	allocse8bee5c5.Add(meme8bee5c5)

	var cu8EnableXODuringSleep_allocs *cgoAllocMap
	refe8bee5c5.u8EnableXODuringSleep, cu8EnableXODuringSleep_allocs = (C.uint8_t)(x.U8EnableXODuringSleep), cgoAllocsUnknown
	allocse8bee5c5.Borrow(cu8EnableXODuringSleep_allocs)

	var c__PAD16___allocs *cgoAllocMap
	refe8bee5c5.__PAD16__, c__PAD16___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocse8bee5c5.Borrow(c__PAD16___allocs)

	x.refe8bee5c5 = refe8bee5c5
	x.allocse8bee5c5 = allocse8bee5c5
	return refe8bee5c5, allocse8bee5c5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWiFiXOSleepEnable) PassValue() (C.tstrM2mWiFiXOSleepEnable, *cgoAllocMap) {
	if x.refe8bee5c5 != nil {
		return *x.refe8bee5c5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWiFiXOSleepEnable) Deref() {
	if x.refe8bee5c5 == nil {
		return
	}
	x.U8EnableXODuringSleep = (byte)(x.refe8bee5c5.u8EnableXODuringSleep)
	x.__PAD16__ = *(*[3]byte)(unsafe.Pointer(&x.refe8bee5c5.__PAD16__))
}

// allocM2mWifiGainsParamsMemory allocates memory for type C.tstrM2mWifiGainsParams in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiGainsParamsMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiGainsParamsValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiGainsParamsValue = unsafe.Sizeof([1]C.tstrM2mWifiGainsParams{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiGainsParams) Ref() *C.tstrM2mWifiGainsParams {
	if x == nil {
		return nil
	}
	return x.ref69e233ef
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiGainsParams) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref69e233ef)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiGainsParams) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiGainsParams) Free() {
	if x != nil && x.allocs69e233ef != nil {
		x.allocs69e233ef.(*cgoAllocMap).Free()
		x.ref69e233ef = nil
	}
}

// NewM2mWifiGainsParamsRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiGainsParamsRef(ref unsafe.Pointer) *M2mWifiGainsParams {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiGainsParams)
	obj.ref69e233ef = (*C.tstrM2mWifiGainsParams)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiGainsParams) PassRef() (*C.tstrM2mWifiGainsParams, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref69e233ef != nil {
		return x.ref69e233ef, nil
	}
	mem69e233ef := allocM2mWifiGainsParamsMemory(1)
	ref69e233ef := (*C.tstrM2mWifiGainsParams)(mem69e233ef)
	allocs69e233ef := new(cgoAllocMap)
	allocs69e233ef.Add(mem69e233ef)

	var cu8PPAGFor11B_allocs *cgoAllocMap
	ref69e233ef.u8PPAGFor11B, cu8PPAGFor11B_allocs = (C.uint16_t)(x.U8PPAGFor11B), cgoAllocsUnknown
	allocs69e233ef.Borrow(cu8PPAGFor11B_allocs)

	var cu8PPAGFor11GN_allocs *cgoAllocMap
	ref69e233ef.u8PPAGFor11GN, cu8PPAGFor11GN_allocs = (C.uint16_t)(x.U8PPAGFor11GN), cgoAllocsUnknown
	allocs69e233ef.Borrow(cu8PPAGFor11GN_allocs)

	x.ref69e233ef = ref69e233ef
	x.allocs69e233ef = allocs69e233ef
	return ref69e233ef, allocs69e233ef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiGainsParams) PassValue() (C.tstrM2mWifiGainsParams, *cgoAllocMap) {
	if x.ref69e233ef != nil {
		return *x.ref69e233ef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiGainsParams) Deref() {
	if x.ref69e233ef == nil {
		return
	}
	x.U8PPAGFor11B = (uint16)(x.ref69e233ef.u8PPAGFor11B)
	x.U8PPAGFor11GN = (uint16)(x.ref69e233ef.u8PPAGFor11GN)
}

// allocM2mConnCredHdrMemory allocates memory for type C.tstrM2mConnCredHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mConnCredHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mConnCredHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mConnCredHdrValue = unsafe.Sizeof([1]C.tstrM2mConnCredHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mConnCredHdr) Ref() *C.tstrM2mConnCredHdr {
	if x == nil {
		return nil
	}
	return x.ref39e9ce5f
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mConnCredHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref39e9ce5f)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mConnCredHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mConnCredHdr) Free() {
	if x != nil && x.allocs39e9ce5f != nil {
		x.allocs39e9ce5f.(*cgoAllocMap).Free()
		x.ref39e9ce5f = nil
	}
}

// NewM2mConnCredHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mConnCredHdrRef(ref unsafe.Pointer) *M2mConnCredHdr {
	if ref == nil {
		return nil
	}
	obj := new(M2mConnCredHdr)
	obj.ref39e9ce5f = (*C.tstrM2mConnCredHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mConnCredHdr) PassRef() (*C.tstrM2mConnCredHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref39e9ce5f != nil {
		return x.ref39e9ce5f, nil
	}
	mem39e9ce5f := allocM2mConnCredHdrMemory(1)
	ref39e9ce5f := (*C.tstrM2mConnCredHdr)(mem39e9ce5f)
	allocs39e9ce5f := new(cgoAllocMap)
	allocs39e9ce5f.Add(mem39e9ce5f)

	var cu16CredSize_allocs *cgoAllocMap
	ref39e9ce5f.u16CredSize, cu16CredSize_allocs = (C.uint16_t)(x.U16CredSize), cgoAllocsUnknown
	allocs39e9ce5f.Borrow(cu16CredSize_allocs)

	var cu8CredStoreFlags_allocs *cgoAllocMap
	ref39e9ce5f.u8CredStoreFlags, cu8CredStoreFlags_allocs = (C.uint8_t)(x.U8CredStoreFlags), cgoAllocsUnknown
	allocs39e9ce5f.Borrow(cu8CredStoreFlags_allocs)

	var cu8Channel_allocs *cgoAllocMap
	ref39e9ce5f.u8Channel, cu8Channel_allocs = (C.uint8_t)(x.U8Channel), cgoAllocsUnknown
	allocs39e9ce5f.Borrow(cu8Channel_allocs)

	x.ref39e9ce5f = ref39e9ce5f
	x.allocs39e9ce5f = allocs39e9ce5f
	return ref39e9ce5f, allocs39e9ce5f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mConnCredHdr) PassValue() (C.tstrM2mConnCredHdr, *cgoAllocMap) {
	if x.ref39e9ce5f != nil {
		return *x.ref39e9ce5f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mConnCredHdr) Deref() {
	if x.ref39e9ce5f == nil {
		return
	}
	x.U16CredSize = (uint16)(x.ref39e9ce5f.u16CredSize)
	x.U8CredStoreFlags = (byte)(x.ref39e9ce5f.u8CredStoreFlags)
	x.U8Channel = (byte)(x.ref39e9ce5f.u8Channel)
}

// allocM2mConnCredCmnMemory allocates memory for type C.tstrM2mConnCredCmn in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mConnCredCmnMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mConnCredCmnValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mConnCredCmnValue = unsafe.Sizeof([1]C.tstrM2mConnCredCmn{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mConnCredCmn) Ref() *C.tstrM2mConnCredCmn {
	if x == nil {
		return nil
	}
	return x.reff07fc6b8
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mConnCredCmn) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reff07fc6b8)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mConnCredCmn) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mConnCredCmn) Free() {
	if x != nil && x.allocsf07fc6b8 != nil {
		x.allocsf07fc6b8.(*cgoAllocMap).Free()
		x.reff07fc6b8 = nil
	}
}

// NewM2mConnCredCmnRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mConnCredCmnRef(ref unsafe.Pointer) *M2mConnCredCmn {
	if ref == nil {
		return nil
	}
	obj := new(M2mConnCredCmn)
	obj.reff07fc6b8 = (*C.tstrM2mConnCredCmn)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mConnCredCmn) PassRef() (*C.tstrM2mConnCredCmn, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff07fc6b8 != nil {
		return x.reff07fc6b8, nil
	}
	memf07fc6b8 := allocM2mConnCredCmnMemory(1)
	reff07fc6b8 := (*C.tstrM2mConnCredCmn)(memf07fc6b8)
	allocsf07fc6b8 := new(cgoAllocMap)
	allocsf07fc6b8.Add(memf07fc6b8)

	var cu8SsidLen_allocs *cgoAllocMap
	reff07fc6b8.u8SsidLen, cu8SsidLen_allocs = (C.uint8_t)(x.U8SsidLen), cgoAllocsUnknown
	allocsf07fc6b8.Borrow(cu8SsidLen_allocs)

	var cau8Ssid_allocs *cgoAllocMap
	reff07fc6b8.au8Ssid, cau8Ssid_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Au8Ssid)), cgoAllocsUnknown
	allocsf07fc6b8.Borrow(cau8Ssid_allocs)

	var cu8Options_allocs *cgoAllocMap
	reff07fc6b8.u8Options, cu8Options_allocs = (C.uint8_t)(x.U8Options), cgoAllocsUnknown
	allocsf07fc6b8.Borrow(cu8Options_allocs)

	var cau8Bssid_allocs *cgoAllocMap
	reff07fc6b8.au8Bssid, cau8Bssid_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8Bssid)), cgoAllocsUnknown
	allocsf07fc6b8.Borrow(cau8Bssid_allocs)

	var cu8AuthType_allocs *cgoAllocMap
	reff07fc6b8.u8AuthType, cu8AuthType_allocs = (C.uint8_t)(x.U8AuthType), cgoAllocsUnknown
	allocsf07fc6b8.Borrow(cu8AuthType_allocs)

	var cau8Rsv_allocs *cgoAllocMap
	reff07fc6b8.au8Rsv, cau8Rsv_allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.Au8Rsv)), cgoAllocsUnknown
	allocsf07fc6b8.Borrow(cau8Rsv_allocs)

	x.reff07fc6b8 = reff07fc6b8
	x.allocsf07fc6b8 = allocsf07fc6b8
	return reff07fc6b8, allocsf07fc6b8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mConnCredCmn) PassValue() (C.tstrM2mConnCredCmn, *cgoAllocMap) {
	if x.reff07fc6b8 != nil {
		return *x.reff07fc6b8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mConnCredCmn) Deref() {
	if x.reff07fc6b8 == nil {
		return
	}
	x.U8SsidLen = (byte)(x.reff07fc6b8.u8SsidLen)
	x.Au8Ssid = *(*[32]byte)(unsafe.Pointer(&x.reff07fc6b8.au8Ssid))
	x.U8Options = (byte)(x.reff07fc6b8.u8Options)
	x.Au8Bssid = *(*[6]byte)(unsafe.Pointer(&x.reff07fc6b8.au8Bssid))
	x.U8AuthType = (byte)(x.reff07fc6b8.u8AuthType)
	x.Au8Rsv = *(*[3]byte)(unsafe.Pointer(&x.reff07fc6b8.au8Rsv))
}

// allocM2mWifiWepMemory allocates memory for type C.tstrM2mWifiWep in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiWepMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiWepValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiWepValue = unsafe.Sizeof([1]C.tstrM2mWifiWep{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiWep) Ref() *C.tstrM2mWifiWep {
	if x == nil {
		return nil
	}
	return x.ref3c80b060
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiWep) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref3c80b060)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiWep) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiWep) Free() {
	if x != nil && x.allocs3c80b060 != nil {
		x.allocs3c80b060.(*cgoAllocMap).Free()
		x.ref3c80b060 = nil
	}
}

// NewM2mWifiWepRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiWepRef(ref unsafe.Pointer) *M2mWifiWep {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiWep)
	obj.ref3c80b060 = (*C.tstrM2mWifiWep)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiWep) PassRef() (*C.tstrM2mWifiWep, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c80b060 != nil {
		return x.ref3c80b060, nil
	}
	mem3c80b060 := allocM2mWifiWepMemory(1)
	ref3c80b060 := (*C.tstrM2mWifiWep)(mem3c80b060)
	allocs3c80b060 := new(cgoAllocMap)
	allocs3c80b060.Add(mem3c80b060)

	var cu8KeyIndex_allocs *cgoAllocMap
	ref3c80b060.u8KeyIndex, cu8KeyIndex_allocs = (C.uint8_t)(x.U8KeyIndex), cgoAllocsUnknown
	allocs3c80b060.Borrow(cu8KeyIndex_allocs)

	var cu8KeyLen_allocs *cgoAllocMap
	ref3c80b060.u8KeyLen, cu8KeyLen_allocs = (C.uint8_t)(x.U8KeyLen), cgoAllocsUnknown
	allocs3c80b060.Borrow(cu8KeyLen_allocs)

	var cau8WepKey_allocs *cgoAllocMap
	ref3c80b060.au8WepKey, cau8WepKey_allocs = *(*[13]C.uint8_t)(unsafe.Pointer(&x.Au8WepKey)), cgoAllocsUnknown
	allocs3c80b060.Borrow(cau8WepKey_allocs)

	var cu8Rsv_allocs *cgoAllocMap
	ref3c80b060.u8Rsv, cu8Rsv_allocs = (C.uint8_t)(x.U8Rsv), cgoAllocsUnknown
	allocs3c80b060.Borrow(cu8Rsv_allocs)

	x.ref3c80b060 = ref3c80b060
	x.allocs3c80b060 = allocs3c80b060
	return ref3c80b060, allocs3c80b060

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiWep) PassValue() (C.tstrM2mWifiWep, *cgoAllocMap) {
	if x.ref3c80b060 != nil {
		return *x.ref3c80b060, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiWep) Deref() {
	if x.ref3c80b060 == nil {
		return
	}
	x.U8KeyIndex = (byte)(x.ref3c80b060.u8KeyIndex)
	x.U8KeyLen = (byte)(x.ref3c80b060.u8KeyLen)
	x.Au8WepKey = *(*[13]byte)(unsafe.Pointer(&x.ref3c80b060.au8WepKey))
	x.U8Rsv = (byte)(x.ref3c80b060.u8Rsv)
}

// allocM2mWifiPskMemory allocates memory for type C.tstrM2mWifiPsk in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiPskMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiPskValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiPskValue = unsafe.Sizeof([1]C.tstrM2mWifiPsk{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiPsk) Ref() *C.tstrM2mWifiPsk {
	if x == nil {
		return nil
	}
	return x.refaf32dade
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiPsk) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refaf32dade)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiPsk) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiPsk) Free() {
	if x != nil && x.allocsaf32dade != nil {
		x.allocsaf32dade.(*cgoAllocMap).Free()
		x.refaf32dade = nil
	}
}

// NewM2mWifiPskRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiPskRef(ref unsafe.Pointer) *M2mWifiPsk {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiPsk)
	obj.refaf32dade = (*C.tstrM2mWifiPsk)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiPsk) PassRef() (*C.tstrM2mWifiPsk, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaf32dade != nil {
		return x.refaf32dade, nil
	}
	memaf32dade := allocM2mWifiPskMemory(1)
	refaf32dade := (*C.tstrM2mWifiPsk)(memaf32dade)
	allocsaf32dade := new(cgoAllocMap)
	allocsaf32dade.Add(memaf32dade)

	var cu8PassphraseLen_allocs *cgoAllocMap
	refaf32dade.u8PassphraseLen, cu8PassphraseLen_allocs = (C.uint8_t)(x.U8PassphraseLen), cgoAllocsUnknown
	allocsaf32dade.Borrow(cu8PassphraseLen_allocs)

	var cau8Passphrase_allocs *cgoAllocMap
	refaf32dade.au8Passphrase, cau8Passphrase_allocs = *(*[64]C.uint8_t)(unsafe.Pointer(&x.Au8Passphrase)), cgoAllocsUnknown
	allocsaf32dade.Borrow(cau8Passphrase_allocs)

	var cau8Psk_allocs *cgoAllocMap
	refaf32dade.au8Psk, cau8Psk_allocs = *(*[40]C.uint8_t)(unsafe.Pointer(&x.Au8Psk)), cgoAllocsUnknown
	allocsaf32dade.Borrow(cau8Psk_allocs)

	var cu8PskCalculated_allocs *cgoAllocMap
	refaf32dade.u8PskCalculated, cu8PskCalculated_allocs = (C.uint8_t)(x.U8PskCalculated), cgoAllocsUnknown
	allocsaf32dade.Borrow(cu8PskCalculated_allocs)

	var cau8Rsv_allocs *cgoAllocMap
	refaf32dade.au8Rsv, cau8Rsv_allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.Au8Rsv)), cgoAllocsUnknown
	allocsaf32dade.Borrow(cau8Rsv_allocs)

	x.refaf32dade = refaf32dade
	x.allocsaf32dade = allocsaf32dade
	return refaf32dade, allocsaf32dade

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiPsk) PassValue() (C.tstrM2mWifiPsk, *cgoAllocMap) {
	if x.refaf32dade != nil {
		return *x.refaf32dade, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiPsk) Deref() {
	if x.refaf32dade == nil {
		return
	}
	x.U8PassphraseLen = (byte)(x.refaf32dade.u8PassphraseLen)
	x.Au8Passphrase = *(*[64]byte)(unsafe.Pointer(&x.refaf32dade.au8Passphrase))
	x.Au8Psk = *(*[40]byte)(unsafe.Pointer(&x.refaf32dade.au8Psk))
	x.U8PskCalculated = (byte)(x.refaf32dade.u8PskCalculated)
	x.Au8Rsv = *(*[2]byte)(unsafe.Pointer(&x.refaf32dade.au8Rsv))
}

// allocM2mWifi1xHdrMemory allocates memory for type C.tstrM2mWifi1xHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifi1xHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifi1xHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifi1xHdrValue = unsafe.Sizeof([1]C.tstrM2mWifi1xHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifi1xHdr) Ref() *C.tstrM2mWifi1xHdr {
	if x == nil {
		return nil
	}
	return x.refcea6f160
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifi1xHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refcea6f160)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifi1xHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifi1xHdr) Free() {
	if x != nil && x.allocscea6f160 != nil {
		x.allocscea6f160.(*cgoAllocMap).Free()
		x.refcea6f160 = nil
	}
}

// NewM2mWifi1xHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifi1xHdrRef(ref unsafe.Pointer) *M2mWifi1xHdr {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifi1xHdr)
	obj.refcea6f160 = (*C.tstrM2mWifi1xHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifi1xHdr) PassRef() (*C.tstrM2mWifi1xHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcea6f160 != nil {
		return x.refcea6f160, nil
	}
	memcea6f160 := allocM2mWifi1xHdrMemory(1)
	refcea6f160 := (*C.tstrM2mWifi1xHdr)(memcea6f160)
	allocscea6f160 := new(cgoAllocMap)
	allocscea6f160.Add(memcea6f160)

	var cu8Flags_allocs *cgoAllocMap
	refcea6f160.u8Flags, cu8Flags_allocs = (C.uint8_t)(x.U8Flags), cgoAllocsUnknown
	allocscea6f160.Borrow(cu8Flags_allocs)

	var cu8DomainLength_allocs *cgoAllocMap
	refcea6f160.u8DomainLength, cu8DomainLength_allocs = (C.uint8_t)(x.U8DomainLength), cgoAllocsUnknown
	allocscea6f160.Borrow(cu8DomainLength_allocs)

	var cu8UserNameLength_allocs *cgoAllocMap
	refcea6f160.u8UserNameLength, cu8UserNameLength_allocs = (C.uint8_t)(x.U8UserNameLength), cgoAllocsUnknown
	allocscea6f160.Borrow(cu8UserNameLength_allocs)

	var cu8HdrLength_allocs *cgoAllocMap
	refcea6f160.u8HdrLength, cu8HdrLength_allocs = (C.uint8_t)(x.U8HdrLength), cgoAllocsUnknown
	allocscea6f160.Borrow(cu8HdrLength_allocs)

	var cu16PrivateKeyOffset_allocs *cgoAllocMap
	refcea6f160.u16PrivateKeyOffset, cu16PrivateKeyOffset_allocs = (C.uint16_t)(x.U16PrivateKeyOffset), cgoAllocsUnknown
	allocscea6f160.Borrow(cu16PrivateKeyOffset_allocs)

	var cu16PrivateKeyLength_allocs *cgoAllocMap
	refcea6f160.u16PrivateKeyLength, cu16PrivateKeyLength_allocs = (C.uint16_t)(x.U16PrivateKeyLength), cgoAllocsUnknown
	allocscea6f160.Borrow(cu16PrivateKeyLength_allocs)

	var cu16CertificateOffset_allocs *cgoAllocMap
	refcea6f160.u16CertificateOffset, cu16CertificateOffset_allocs = (C.uint16_t)(x.U16CertificateOffset), cgoAllocsUnknown
	allocscea6f160.Borrow(cu16CertificateOffset_allocs)

	var cu16CertificateLength_allocs *cgoAllocMap
	refcea6f160.u16CertificateLength, cu16CertificateLength_allocs = (C.uint16_t)(x.U16CertificateLength), cgoAllocsUnknown
	allocscea6f160.Borrow(cu16CertificateLength_allocs)

	var cau8TlsSpecificRootNameSha1_allocs *cgoAllocMap
	refcea6f160.au8TlsSpecificRootNameSha1, cau8TlsSpecificRootNameSha1_allocs = *(*[20]C.uint8_t)(unsafe.Pointer(&x.Au8TlsSpecificRootNameSha1)), cgoAllocsUnknown
	allocscea6f160.Borrow(cau8TlsSpecificRootNameSha1_allocs)

	var cu32Rsv1_allocs *cgoAllocMap
	refcea6f160.u32Rsv1, cu32Rsv1_allocs = (C.uint32_t)(x.U32Rsv1), cgoAllocsUnknown
	allocscea6f160.Borrow(cu32Rsv1_allocs)

	var cu32TlsHsFlags_allocs *cgoAllocMap
	refcea6f160.u32TlsHsFlags, cu32TlsHsFlags_allocs = (C.uint32_t)(x.U32TlsHsFlags), cgoAllocsUnknown
	allocscea6f160.Borrow(cu32TlsHsFlags_allocs)

	var cu32Rsv2_allocs *cgoAllocMap
	refcea6f160.u32Rsv2, cu32Rsv2_allocs = (C.uint32_t)(x.U32Rsv2), cgoAllocsUnknown
	allocscea6f160.Borrow(cu32Rsv2_allocs)

	x.refcea6f160 = refcea6f160
	x.allocscea6f160 = allocscea6f160
	return refcea6f160, allocscea6f160

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifi1xHdr) PassValue() (C.tstrM2mWifi1xHdr, *cgoAllocMap) {
	if x.refcea6f160 != nil {
		return *x.refcea6f160, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifi1xHdr) Deref() {
	if x.refcea6f160 == nil {
		return
	}
	x.U8Flags = (byte)(x.refcea6f160.u8Flags)
	x.U8DomainLength = (byte)(x.refcea6f160.u8DomainLength)
	x.U8UserNameLength = (byte)(x.refcea6f160.u8UserNameLength)
	x.U8HdrLength = (byte)(x.refcea6f160.u8HdrLength)
	x.U16PrivateKeyOffset = (uint16)(x.refcea6f160.u16PrivateKeyOffset)
	x.U16PrivateKeyLength = (uint16)(x.refcea6f160.u16PrivateKeyLength)
	x.U16CertificateOffset = (uint16)(x.refcea6f160.u16CertificateOffset)
	x.U16CertificateLength = (uint16)(x.refcea6f160.u16CertificateLength)
	x.Au8TlsSpecificRootNameSha1 = *(*[20]byte)(unsafe.Pointer(&x.refcea6f160.au8TlsSpecificRootNameSha1))
	x.U32Rsv1 = (uint32)(x.refcea6f160.u32Rsv1)
	x.U32TlsHsFlags = (uint32)(x.refcea6f160.u32TlsHsFlags)
	x.U32Rsv2 = (uint32)(x.refcea6f160.u32Rsv2)
}

// allocM2mWifiAuthInfoHdrMemory allocates memory for type C.tstrM2mWifiAuthInfoHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiAuthInfoHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiAuthInfoHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiAuthInfoHdrValue = unsafe.Sizeof([1]C.tstrM2mWifiAuthInfoHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiAuthInfoHdr) Ref() *C.tstrM2mWifiAuthInfoHdr {
	if x == nil {
		return nil
	}
	return x.ref879b4dbc
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiAuthInfoHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref879b4dbc)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiAuthInfoHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiAuthInfoHdr) Free() {
	if x != nil && x.allocs879b4dbc != nil {
		x.allocs879b4dbc.(*cgoAllocMap).Free()
		x.ref879b4dbc = nil
	}
}

// NewM2mWifiAuthInfoHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiAuthInfoHdrRef(ref unsafe.Pointer) *M2mWifiAuthInfoHdr {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiAuthInfoHdr)
	obj.ref879b4dbc = (*C.tstrM2mWifiAuthInfoHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiAuthInfoHdr) PassRef() (*C.tstrM2mWifiAuthInfoHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref879b4dbc != nil {
		return x.ref879b4dbc, nil
	}
	mem879b4dbc := allocM2mWifiAuthInfoHdrMemory(1)
	ref879b4dbc := (*C.tstrM2mWifiAuthInfoHdr)(mem879b4dbc)
	allocs879b4dbc := new(cgoAllocMap)
	allocs879b4dbc.Add(mem879b4dbc)

	var cu8Type_allocs *cgoAllocMap
	ref879b4dbc.u8Type, cu8Type_allocs = (C.uint8_t)(x.U8Type), cgoAllocsUnknown
	allocs879b4dbc.Borrow(cu8Type_allocs)

	var cau8Rsv_allocs *cgoAllocMap
	ref879b4dbc.au8Rsv, cau8Rsv_allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.Au8Rsv)), cgoAllocsUnknown
	allocs879b4dbc.Borrow(cau8Rsv_allocs)

	var cu16InfoPos_allocs *cgoAllocMap
	ref879b4dbc.u16InfoPos, cu16InfoPos_allocs = (C.uint16_t)(x.U16InfoPos), cgoAllocsUnknown
	allocs879b4dbc.Borrow(cu16InfoPos_allocs)

	var cu16InfoLen_allocs *cgoAllocMap
	ref879b4dbc.u16InfoLen, cu16InfoLen_allocs = (C.uint16_t)(x.U16InfoLen), cgoAllocsUnknown
	allocs879b4dbc.Borrow(cu16InfoLen_allocs)

	x.ref879b4dbc = ref879b4dbc
	x.allocs879b4dbc = allocs879b4dbc
	return ref879b4dbc, allocs879b4dbc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiAuthInfoHdr) PassValue() (C.tstrM2mWifiAuthInfoHdr, *cgoAllocMap) {
	if x.ref879b4dbc != nil {
		return *x.ref879b4dbc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiAuthInfoHdr) Deref() {
	if x.ref879b4dbc == nil {
		return
	}
	x.U8Type = (byte)(x.ref879b4dbc.u8Type)
	x.Au8Rsv = *(*[3]byte)(unsafe.Pointer(&x.ref879b4dbc.au8Rsv))
	x.U16InfoPos = (uint16)(x.ref879b4dbc.u16InfoPos)
	x.U16InfoLen = (uint16)(x.ref879b4dbc.u16InfoLen)
}

// allocM2mWifiConnHdrMemory allocates memory for type C.tstrM2mWifiConnHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiConnHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiConnHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiConnHdrValue = unsafe.Sizeof([1]C.tstrM2mWifiConnHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiConnHdr) Ref() *C.tstrM2mWifiConnHdr {
	if x == nil {
		return nil
	}
	return x.ref3ce06260
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiConnHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref3ce06260)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiConnHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiConnHdr) Free() {
	if x != nil && x.allocs3ce06260 != nil {
		x.allocs3ce06260.(*cgoAllocMap).Free()
		x.ref3ce06260 = nil
	}
}

// NewM2mWifiConnHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiConnHdrRef(ref unsafe.Pointer) *M2mWifiConnHdr {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiConnHdr)
	obj.ref3ce06260 = (*C.tstrM2mWifiConnHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiConnHdr) PassRef() (*C.tstrM2mWifiConnHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3ce06260 != nil {
		return x.ref3ce06260, nil
	}
	mem3ce06260 := allocM2mWifiConnHdrMemory(1)
	ref3ce06260 := (*C.tstrM2mWifiConnHdr)(mem3ce06260)
	allocs3ce06260 := new(cgoAllocMap)
	allocs3ce06260.Add(mem3ce06260)

	var cstrConnCredHdr_allocs *cgoAllocMap
	ref3ce06260.strConnCredHdr, cstrConnCredHdr_allocs = x.StrConnCredHdr.PassValue()
	allocs3ce06260.Borrow(cstrConnCredHdr_allocs)

	var cstrConnCredCmn_allocs *cgoAllocMap
	ref3ce06260.strConnCredCmn, cstrConnCredCmn_allocs = x.StrConnCredCmn.PassValue()
	allocs3ce06260.Borrow(cstrConnCredCmn_allocs)

	x.ref3ce06260 = ref3ce06260
	x.allocs3ce06260 = allocs3ce06260
	return ref3ce06260, allocs3ce06260

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiConnHdr) PassValue() (C.tstrM2mWifiConnHdr, *cgoAllocMap) {
	if x.ref3ce06260 != nil {
		return *x.ref3ce06260, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiConnHdr) Deref() {
	if x.ref3ce06260 == nil {
		return
	}
	x.StrConnCredHdr = *NewM2mConnCredHdrRef(unsafe.Pointer(&x.ref3ce06260.strConnCredHdr))
	x.StrConnCredCmn = *NewM2mConnCredCmnRef(unsafe.Pointer(&x.ref3ce06260.strConnCredCmn))
}

// allocM2mWifiApIdMemory allocates memory for type C.tstrM2mWifiApId in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiApIdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiApIdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiApIdValue = unsafe.Sizeof([1]C.tstrM2mWifiApId{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiApId) Ref() *C.tstrM2mWifiApId {
	if x == nil {
		return nil
	}
	return x.refb4484f46
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiApId) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refb4484f46)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiApId) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiApId) Free() {
	if x != nil && x.allocsb4484f46 != nil {
		x.allocsb4484f46.(*cgoAllocMap).Free()
		x.refb4484f46 = nil
	}
}

// NewM2mWifiApIdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiApIdRef(ref unsafe.Pointer) *M2mWifiApId {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiApId)
	obj.refb4484f46 = (*C.tstrM2mWifiApId)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiApId) PassRef() (*C.tstrM2mWifiApId, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb4484f46 != nil {
		return x.refb4484f46, nil
	}
	memb4484f46 := allocM2mWifiApIdMemory(1)
	refb4484f46 := (*C.tstrM2mWifiApId)(memb4484f46)
	allocsb4484f46 := new(cgoAllocMap)
	allocsb4484f46.Add(memb4484f46)

	var cau8SSID_allocs *cgoAllocMap
	refb4484f46.au8SSID, cau8SSID_allocs = *(*[33]C.uint8_t)(unsafe.Pointer(&x.Au8SSID)), cgoAllocsUnknown
	allocsb4484f46.Borrow(cau8SSID_allocs)

	var c__PAD___allocs *cgoAllocMap
	refb4484f46.__PAD__, c__PAD___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD__)), cgoAllocsUnknown
	allocsb4484f46.Borrow(c__PAD___allocs)

	x.refb4484f46 = refb4484f46
	x.allocsb4484f46 = allocsb4484f46
	return refb4484f46, allocsb4484f46

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiApId) PassValue() (C.tstrM2mWifiApId, *cgoAllocMap) {
	if x.refb4484f46 != nil {
		return *x.refb4484f46, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiApId) Deref() {
	if x.refb4484f46 == nil {
		return
	}
	x.Au8SSID = *(*[33]byte)(unsafe.Pointer(&x.refb4484f46.au8SSID))
	x.__PAD__ = *(*[3]byte)(unsafe.Pointer(&x.refb4484f46.__PAD__))
}

// allocM2MGenericRespMemory allocates memory for type C.tstrM2MGenericResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MGenericRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MGenericRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MGenericRespValue = unsafe.Sizeof([1]C.tstrM2MGenericResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MGenericResp) Ref() *C.tstrM2MGenericResp {
	if x == nil {
		return nil
	}
	return x.ref3d54d4d0
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MGenericResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref3d54d4d0)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MGenericResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MGenericResp) Free() {
	if x != nil && x.allocs3d54d4d0 != nil {
		x.allocs3d54d4d0.(*cgoAllocMap).Free()
		x.ref3d54d4d0 = nil
	}
}

// NewM2MGenericRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MGenericRespRef(ref unsafe.Pointer) *M2MGenericResp {
	if ref == nil {
		return nil
	}
	obj := new(M2MGenericResp)
	obj.ref3d54d4d0 = (*C.tstrM2MGenericResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MGenericResp) PassRef() (*C.tstrM2MGenericResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3d54d4d0 != nil {
		return x.ref3d54d4d0, nil
	}
	mem3d54d4d0 := allocM2MGenericRespMemory(1)
	ref3d54d4d0 := (*C.tstrM2MGenericResp)(mem3d54d4d0)
	allocs3d54d4d0 := new(cgoAllocMap)
	allocs3d54d4d0.Add(mem3d54d4d0)

	var cs8ErrorCode_allocs *cgoAllocMap
	ref3d54d4d0.s8ErrorCode, cs8ErrorCode_allocs = (C.int8_t)(x.S8ErrorCode), cgoAllocsUnknown
	allocs3d54d4d0.Borrow(cs8ErrorCode_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref3d54d4d0.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs3d54d4d0.Borrow(c__PAD24___allocs)

	x.ref3d54d4d0 = ref3d54d4d0
	x.allocs3d54d4d0 = allocs3d54d4d0
	return ref3d54d4d0, allocs3d54d4d0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MGenericResp) PassValue() (C.tstrM2MGenericResp, *cgoAllocMap) {
	if x.ref3d54d4d0 != nil {
		return *x.ref3d54d4d0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MGenericResp) Deref() {
	if x.ref3d54d4d0 == nil {
		return
	}
	x.S8ErrorCode = (int8)(x.ref3d54d4d0.s8ErrorCode)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref3d54d4d0.__PAD24__))
}

// allocM2MWPSConnectMemory allocates memory for type C.tstrM2MWPSConnect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MWPSConnectMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MWPSConnectValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MWPSConnectValue = unsafe.Sizeof([1]C.tstrM2MWPSConnect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MWPSConnect) Ref() *C.tstrM2MWPSConnect {
	if x == nil {
		return nil
	}
	return x.ref649eedf4
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MWPSConnect) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref649eedf4)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MWPSConnect) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MWPSConnect) Free() {
	if x != nil && x.allocs649eedf4 != nil {
		x.allocs649eedf4.(*cgoAllocMap).Free()
		x.ref649eedf4 = nil
	}
}

// NewM2MWPSConnectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MWPSConnectRef(ref unsafe.Pointer) *M2MWPSConnect {
	if ref == nil {
		return nil
	}
	obj := new(M2MWPSConnect)
	obj.ref649eedf4 = (*C.tstrM2MWPSConnect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MWPSConnect) PassRef() (*C.tstrM2MWPSConnect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref649eedf4 != nil {
		return x.ref649eedf4, nil
	}
	mem649eedf4 := allocM2MWPSConnectMemory(1)
	ref649eedf4 := (*C.tstrM2MWPSConnect)(mem649eedf4)
	allocs649eedf4 := new(cgoAllocMap)
	allocs649eedf4.Add(mem649eedf4)

	var cu8TriggerType_allocs *cgoAllocMap
	ref649eedf4.u8TriggerType, cu8TriggerType_allocs = (C.uint8_t)(x.U8TriggerType), cgoAllocsUnknown
	allocs649eedf4.Borrow(cu8TriggerType_allocs)

	var cacPinNumber_allocs *cgoAllocMap
	ref649eedf4.acPinNumber, cacPinNumber_allocs = *(*[8]C.char)(unsafe.Pointer(&x.AcPinNumber)), cgoAllocsUnknown
	allocs649eedf4.Borrow(cacPinNumber_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref649eedf4.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs649eedf4.Borrow(c__PAD24___allocs)

	x.ref649eedf4 = ref649eedf4
	x.allocs649eedf4 = allocs649eedf4
	return ref649eedf4, allocs649eedf4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MWPSConnect) PassValue() (C.tstrM2MWPSConnect, *cgoAllocMap) {
	if x.ref649eedf4 != nil {
		return *x.ref649eedf4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MWPSConnect) Deref() {
	if x.ref649eedf4 == nil {
		return
	}
	x.U8TriggerType = (byte)(x.ref649eedf4.u8TriggerType)
	x.AcPinNumber = *(*[8]byte)(unsafe.Pointer(&x.ref649eedf4.acPinNumber))
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref649eedf4.__PAD24__))
}

// allocM2MWPSInfoMemory allocates memory for type C.tstrM2MWPSInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MWPSInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MWPSInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MWPSInfoValue = unsafe.Sizeof([1]C.tstrM2MWPSInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MWPSInfo) Ref() *C.tstrM2MWPSInfo {
	if x == nil {
		return nil
	}
	return x.refa2ef9cb2
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MWPSInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refa2ef9cb2)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MWPSInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MWPSInfo) Free() {
	if x != nil && x.allocsa2ef9cb2 != nil {
		x.allocsa2ef9cb2.(*cgoAllocMap).Free()
		x.refa2ef9cb2 = nil
	}
}

// NewM2MWPSInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MWPSInfoRef(ref unsafe.Pointer) *M2MWPSInfo {
	if ref == nil {
		return nil
	}
	obj := new(M2MWPSInfo)
	obj.refa2ef9cb2 = (*C.tstrM2MWPSInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MWPSInfo) PassRef() (*C.tstrM2MWPSInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa2ef9cb2 != nil {
		return x.refa2ef9cb2, nil
	}
	mema2ef9cb2 := allocM2MWPSInfoMemory(1)
	refa2ef9cb2 := (*C.tstrM2MWPSInfo)(mema2ef9cb2)
	allocsa2ef9cb2 := new(cgoAllocMap)
	allocsa2ef9cb2.Add(mema2ef9cb2)

	var cu8AuthType_allocs *cgoAllocMap
	refa2ef9cb2.u8AuthType, cu8AuthType_allocs = (C.uint8_t)(x.U8AuthType), cgoAllocsUnknown
	allocsa2ef9cb2.Borrow(cu8AuthType_allocs)

	var cu8Ch_allocs *cgoAllocMap
	refa2ef9cb2.u8Ch, cu8Ch_allocs = (C.uint8_t)(x.U8Ch), cgoAllocsUnknown
	allocsa2ef9cb2.Borrow(cu8Ch_allocs)

	var cau8SSID_allocs *cgoAllocMap
	refa2ef9cb2.au8SSID, cau8SSID_allocs = *(*[33]C.uint8_t)(unsafe.Pointer(&x.Au8SSID)), cgoAllocsUnknown
	allocsa2ef9cb2.Borrow(cau8SSID_allocs)

	var cau8PSK_allocs *cgoAllocMap
	refa2ef9cb2.au8PSK, cau8PSK_allocs = *(*[65]C.uint8_t)(unsafe.Pointer(&x.Au8PSK)), cgoAllocsUnknown
	allocsa2ef9cb2.Borrow(cau8PSK_allocs)

	x.refa2ef9cb2 = refa2ef9cb2
	x.allocsa2ef9cb2 = allocsa2ef9cb2
	return refa2ef9cb2, allocsa2ef9cb2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MWPSInfo) PassValue() (C.tstrM2MWPSInfo, *cgoAllocMap) {
	if x.refa2ef9cb2 != nil {
		return *x.refa2ef9cb2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MWPSInfo) Deref() {
	if x.refa2ef9cb2 == nil {
		return
	}
	x.U8AuthType = (byte)(x.refa2ef9cb2.u8AuthType)
	x.U8Ch = (byte)(x.refa2ef9cb2.u8Ch)
	x.Au8SSID = *(*[33]byte)(unsafe.Pointer(&x.refa2ef9cb2.au8SSID))
	x.Au8PSK = *(*[65]byte)(unsafe.Pointer(&x.refa2ef9cb2.au8PSK))
}

// allocM2MDefaultConnRespMemory allocates memory for type C.tstrM2MDefaultConnResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MDefaultConnRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MDefaultConnRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MDefaultConnRespValue = unsafe.Sizeof([1]C.tstrM2MDefaultConnResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MDefaultConnResp) Ref() *C.tstrM2MDefaultConnResp {
	if x == nil {
		return nil
	}
	return x.ref4b129f8a
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MDefaultConnResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref4b129f8a)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MDefaultConnResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MDefaultConnResp) Free() {
	if x != nil && x.allocs4b129f8a != nil {
		x.allocs4b129f8a.(*cgoAllocMap).Free()
		x.ref4b129f8a = nil
	}
}

// NewM2MDefaultConnRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MDefaultConnRespRef(ref unsafe.Pointer) *M2MDefaultConnResp {
	if ref == nil {
		return nil
	}
	obj := new(M2MDefaultConnResp)
	obj.ref4b129f8a = (*C.tstrM2MDefaultConnResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MDefaultConnResp) PassRef() (*C.tstrM2MDefaultConnResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b129f8a != nil {
		return x.ref4b129f8a, nil
	}
	mem4b129f8a := allocM2MDefaultConnRespMemory(1)
	ref4b129f8a := (*C.tstrM2MDefaultConnResp)(mem4b129f8a)
	allocs4b129f8a := new(cgoAllocMap)
	allocs4b129f8a.Add(mem4b129f8a)

	var cs8ErrorCode_allocs *cgoAllocMap
	ref4b129f8a.s8ErrorCode, cs8ErrorCode_allocs = (C.int8_t)(x.S8ErrorCode), cgoAllocsUnknown
	allocs4b129f8a.Borrow(cs8ErrorCode_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref4b129f8a.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs4b129f8a.Borrow(c__PAD24___allocs)

	x.ref4b129f8a = ref4b129f8a
	x.allocs4b129f8a = allocs4b129f8a
	return ref4b129f8a, allocs4b129f8a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MDefaultConnResp) PassValue() (C.tstrM2MDefaultConnResp, *cgoAllocMap) {
	if x.ref4b129f8a != nil {
		return *x.ref4b129f8a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MDefaultConnResp) Deref() {
	if x.ref4b129f8a == nil {
		return
	}
	x.S8ErrorCode = (int8)(x.ref4b129f8a.s8ErrorCode)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref4b129f8a.__PAD24__))
}

// allocM2MScanOptionMemory allocates memory for type C.tstrM2MScanOption in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MScanOptionMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MScanOptionValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MScanOptionValue = unsafe.Sizeof([1]C.tstrM2MScanOption{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MScanOption) Ref() *C.tstrM2MScanOption {
	if x == nil {
		return nil
	}
	return x.refac5e69f9
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MScanOption) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refac5e69f9)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MScanOption) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MScanOption) Free() {
	if x != nil && x.allocsac5e69f9 != nil {
		x.allocsac5e69f9.(*cgoAllocMap).Free()
		x.refac5e69f9 = nil
	}
}

// NewM2MScanOptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MScanOptionRef(ref unsafe.Pointer) *M2MScanOption {
	if ref == nil {
		return nil
	}
	obj := new(M2MScanOption)
	obj.refac5e69f9 = (*C.tstrM2MScanOption)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MScanOption) PassRef() (*C.tstrM2MScanOption, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refac5e69f9 != nil {
		return x.refac5e69f9, nil
	}
	memac5e69f9 := allocM2MScanOptionMemory(1)
	refac5e69f9 := (*C.tstrM2MScanOption)(memac5e69f9)
	allocsac5e69f9 := new(cgoAllocMap)
	allocsac5e69f9.Add(memac5e69f9)

	var cu8NumOfSlot_allocs *cgoAllocMap
	refac5e69f9.u8NumOfSlot, cu8NumOfSlot_allocs = (C.uint8_t)(x.U8NumOfSlot), cgoAllocsUnknown
	allocsac5e69f9.Borrow(cu8NumOfSlot_allocs)

	var cu8SlotTime_allocs *cgoAllocMap
	refac5e69f9.u8SlotTime, cu8SlotTime_allocs = (C.uint8_t)(x.U8SlotTime), cgoAllocsUnknown
	allocsac5e69f9.Borrow(cu8SlotTime_allocs)

	var cu8ProbesPerSlot_allocs *cgoAllocMap
	refac5e69f9.u8ProbesPerSlot, cu8ProbesPerSlot_allocs = (C.uint8_t)(x.U8ProbesPerSlot), cgoAllocsUnknown
	allocsac5e69f9.Borrow(cu8ProbesPerSlot_allocs)

	var cs8RssiThresh_allocs *cgoAllocMap
	refac5e69f9.s8RssiThresh, cs8RssiThresh_allocs = (C.int8_t)(x.S8RssiThresh), cgoAllocsUnknown
	allocsac5e69f9.Borrow(cs8RssiThresh_allocs)

	x.refac5e69f9 = refac5e69f9
	x.allocsac5e69f9 = allocsac5e69f9
	return refac5e69f9, allocsac5e69f9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MScanOption) PassValue() (C.tstrM2MScanOption, *cgoAllocMap) {
	if x.refac5e69f9 != nil {
		return *x.refac5e69f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MScanOption) Deref() {
	if x.refac5e69f9 == nil {
		return
	}
	x.U8NumOfSlot = (byte)(x.refac5e69f9.u8NumOfSlot)
	x.U8SlotTime = (byte)(x.refac5e69f9.u8SlotTime)
	x.U8ProbesPerSlot = (byte)(x.refac5e69f9.u8ProbesPerSlot)
	x.S8RssiThresh = (int8)(x.refac5e69f9.s8RssiThresh)
}

// allocM2MStopScanOptionMemory allocates memory for type C.tstrM2MStopScanOption in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MStopScanOptionMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MStopScanOptionValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MStopScanOptionValue = unsafe.Sizeof([1]C.tstrM2MStopScanOption{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MStopScanOption) Ref() *C.tstrM2MStopScanOption {
	if x == nil {
		return nil
	}
	return x.refd0dabb43
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MStopScanOption) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refd0dabb43)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MStopScanOption) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MStopScanOption) Free() {
	if x != nil && x.allocsd0dabb43 != nil {
		x.allocsd0dabb43.(*cgoAllocMap).Free()
		x.refd0dabb43 = nil
	}
}

// NewM2MStopScanOptionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MStopScanOptionRef(ref unsafe.Pointer) *M2MStopScanOption {
	if ref == nil {
		return nil
	}
	obj := new(M2MStopScanOption)
	obj.refd0dabb43 = (*C.tstrM2MStopScanOption)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MStopScanOption) PassRef() (*C.tstrM2MStopScanOption, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd0dabb43 != nil {
		return x.refd0dabb43, nil
	}
	memd0dabb43 := allocM2MStopScanOptionMemory(1)
	refd0dabb43 := (*C.tstrM2MStopScanOption)(memd0dabb43)
	allocsd0dabb43 := new(cgoAllocMap)
	allocsd0dabb43.Add(memd0dabb43)

	var cu8StopOnFirstResult_allocs *cgoAllocMap
	refd0dabb43.u8StopOnFirstResult, cu8StopOnFirstResult_allocs = (C.uint8_t)(x.U8StopOnFirstResult), cgoAllocsUnknown
	allocsd0dabb43.Borrow(cu8StopOnFirstResult_allocs)

	var cau8Rsv_allocs *cgoAllocMap
	refd0dabb43.au8Rsv, cau8Rsv_allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.Au8Rsv)), cgoAllocsUnknown
	allocsd0dabb43.Borrow(cau8Rsv_allocs)

	x.refd0dabb43 = refd0dabb43
	x.allocsd0dabb43 = allocsd0dabb43
	return refd0dabb43, allocsd0dabb43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MStopScanOption) PassValue() (C.tstrM2MStopScanOption, *cgoAllocMap) {
	if x.refd0dabb43 != nil {
		return *x.refd0dabb43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MStopScanOption) Deref() {
	if x.refd0dabb43 == nil {
		return
	}
	x.U8StopOnFirstResult = (byte)(x.refd0dabb43.u8StopOnFirstResult)
	x.Au8Rsv = *(*[3]byte)(unsafe.Pointer(&x.refd0dabb43.au8Rsv))
}

// allocM2MScanRegionMemory allocates memory for type C.tstrM2MScanRegion in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MScanRegionMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MScanRegionValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MScanRegionValue = unsafe.Sizeof([1]C.tstrM2MScanRegion{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MScanRegion) Ref() *C.tstrM2MScanRegion {
	if x == nil {
		return nil
	}
	return x.reff9ba983f
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MScanRegion) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reff9ba983f)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MScanRegion) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MScanRegion) Free() {
	if x != nil && x.allocsf9ba983f != nil {
		x.allocsf9ba983f.(*cgoAllocMap).Free()
		x.reff9ba983f = nil
	}
}

// NewM2MScanRegionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MScanRegionRef(ref unsafe.Pointer) *M2MScanRegion {
	if ref == nil {
		return nil
	}
	obj := new(M2MScanRegion)
	obj.reff9ba983f = (*C.tstrM2MScanRegion)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MScanRegion) PassRef() (*C.tstrM2MScanRegion, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff9ba983f != nil {
		return x.reff9ba983f, nil
	}
	memf9ba983f := allocM2MScanRegionMemory(1)
	reff9ba983f := (*C.tstrM2MScanRegion)(memf9ba983f)
	allocsf9ba983f := new(cgoAllocMap)
	allocsf9ba983f.Add(memf9ba983f)

	var cu16ScanRegion_allocs *cgoAllocMap
	reff9ba983f.u16ScanRegion, cu16ScanRegion_allocs = (C.uint16_t)(x.U16ScanRegion), cgoAllocsUnknown
	allocsf9ba983f.Borrow(cu16ScanRegion_allocs)

	var c__PAD16___allocs *cgoAllocMap
	reff9ba983f.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocsf9ba983f.Borrow(c__PAD16___allocs)

	x.reff9ba983f = reff9ba983f
	x.allocsf9ba983f = allocsf9ba983f
	return reff9ba983f, allocsf9ba983f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MScanRegion) PassValue() (C.tstrM2MScanRegion, *cgoAllocMap) {
	if x.reff9ba983f != nil {
		return *x.reff9ba983f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MScanRegion) Deref() {
	if x.reff9ba983f == nil {
		return
	}
	x.U16ScanRegion = (uint16)(x.reff9ba983f.u16ScanRegion)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.reff9ba983f.__PAD16__))
}

// allocM2MScanMemory allocates memory for type C.tstrM2MScan in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MScanMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MScanValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MScanValue = unsafe.Sizeof([1]C.tstrM2MScan{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MScan) Ref() *C.tstrM2MScan {
	if x == nil {
		return nil
	}
	return x.reff2f04759
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MScan) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reff2f04759)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MScan) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MScan) Free() {
	if x != nil && x.allocsf2f04759 != nil {
		x.allocsf2f04759.(*cgoAllocMap).Free()
		x.reff2f04759 = nil
	}
}

// NewM2MScanRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MScanRef(ref unsafe.Pointer) *M2MScan {
	if ref == nil {
		return nil
	}
	obj := new(M2MScan)
	obj.reff2f04759 = (*C.tstrM2MScan)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MScan) PassRef() (*C.tstrM2MScan, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff2f04759 != nil {
		return x.reff2f04759, nil
	}
	memf2f04759 := allocM2MScanMemory(1)
	reff2f04759 := (*C.tstrM2MScan)(memf2f04759)
	allocsf2f04759 := new(cgoAllocMap)
	allocsf2f04759.Add(memf2f04759)

	var cu8ChNum_allocs *cgoAllocMap
	reff2f04759.u8ChNum, cu8ChNum_allocs = (C.uint8_t)(x.U8ChNum), cgoAllocsUnknown
	allocsf2f04759.Borrow(cu8ChNum_allocs)

	var c__RSVD8___allocs *cgoAllocMap
	reff2f04759.__RSVD8__, c__RSVD8___allocs = *(*[1]C.uint8_t)(unsafe.Pointer(&x.__RSVD8__)), cgoAllocsUnknown
	allocsf2f04759.Borrow(c__RSVD8___allocs)

	var cu16PassiveScanTime_allocs *cgoAllocMap
	reff2f04759.u16PassiveScanTime, cu16PassiveScanTime_allocs = (C.uint16_t)(x.U16PassiveScanTime), cgoAllocsUnknown
	allocsf2f04759.Borrow(cu16PassiveScanTime_allocs)

	x.reff2f04759 = reff2f04759
	x.allocsf2f04759 = allocsf2f04759
	return reff2f04759, allocsf2f04759

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MScan) PassValue() (C.tstrM2MScan, *cgoAllocMap) {
	if x.reff2f04759 != nil {
		return *x.reff2f04759, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MScan) Deref() {
	if x.reff2f04759 == nil {
		return
	}
	x.U8ChNum = (byte)(x.reff2f04759.u8ChNum)
	x.__RSVD8__ = *(*[1]byte)(unsafe.Pointer(&x.reff2f04759.__RSVD8__))
	x.U16PassiveScanTime = (uint16)(x.reff2f04759.u16PassiveScanTime)
}

// allocCyptoRespMemory allocates memory for type C.tstrCyptoResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCyptoRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfCyptoRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfCyptoRespValue = unsafe.Sizeof([1]C.tstrCyptoResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CyptoResp) Ref() *C.tstrCyptoResp {
	if x == nil {
		return nil
	}
	return x.refd21c28b2
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *CyptoResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refd21c28b2)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *CyptoResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CyptoResp) Free() {
	if x != nil && x.allocsd21c28b2 != nil {
		x.allocsd21c28b2.(*cgoAllocMap).Free()
		x.refd21c28b2 = nil
	}
}

// NewCyptoRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCyptoRespRef(ref unsafe.Pointer) *CyptoResp {
	if ref == nil {
		return nil
	}
	obj := new(CyptoResp)
	obj.refd21c28b2 = (*C.tstrCyptoResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CyptoResp) PassRef() (*C.tstrCyptoResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd21c28b2 != nil {
		return x.refd21c28b2, nil
	}
	memd21c28b2 := allocCyptoRespMemory(1)
	refd21c28b2 := (*C.tstrCyptoResp)(memd21c28b2)
	allocsd21c28b2 := new(cgoAllocMap)
	allocsd21c28b2.Add(memd21c28b2)

	var cs8Resp_allocs *cgoAllocMap
	refd21c28b2.s8Resp, cs8Resp_allocs = (C.int8_t)(x.S8Resp), cgoAllocsUnknown
	allocsd21c28b2.Borrow(cs8Resp_allocs)

	var c__PAD24___allocs *cgoAllocMap
	refd21c28b2.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocsd21c28b2.Borrow(c__PAD24___allocs)

	x.refd21c28b2 = refd21c28b2
	x.allocsd21c28b2 = allocsd21c28b2
	return refd21c28b2, allocsd21c28b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CyptoResp) PassValue() (C.tstrCyptoResp, *cgoAllocMap) {
	if x.refd21c28b2 != nil {
		return *x.refd21c28b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CyptoResp) Deref() {
	if x.refd21c28b2 == nil {
		return
	}
	x.S8Resp = (int8)(x.refd21c28b2.s8Resp)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.refd21c28b2.__PAD24__))
}

// allocM2mScanDoneMemory allocates memory for type C.tstrM2mScanDone in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mScanDoneMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mScanDoneValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mScanDoneValue = unsafe.Sizeof([1]C.tstrM2mScanDone{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mScanDone) Ref() *C.tstrM2mScanDone {
	if x == nil {
		return nil
	}
	return x.refb63164d6
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mScanDone) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refb63164d6)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mScanDone) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mScanDone) Free() {
	if x != nil && x.allocsb63164d6 != nil {
		x.allocsb63164d6.(*cgoAllocMap).Free()
		x.refb63164d6 = nil
	}
}

// NewM2mScanDoneRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mScanDoneRef(ref unsafe.Pointer) *M2mScanDone {
	if ref == nil {
		return nil
	}
	obj := new(M2mScanDone)
	obj.refb63164d6 = (*C.tstrM2mScanDone)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mScanDone) PassRef() (*C.tstrM2mScanDone, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb63164d6 != nil {
		return x.refb63164d6, nil
	}
	memb63164d6 := allocM2mScanDoneMemory(1)
	refb63164d6 := (*C.tstrM2mScanDone)(memb63164d6)
	allocsb63164d6 := new(cgoAllocMap)
	allocsb63164d6.Add(memb63164d6)

	var cu8NumofCh_allocs *cgoAllocMap
	refb63164d6.u8NumofCh, cu8NumofCh_allocs = (C.uint8_t)(x.U8NumofCh), cgoAllocsUnknown
	allocsb63164d6.Borrow(cu8NumofCh_allocs)

	var cs8ScanState_allocs *cgoAllocMap
	refb63164d6.s8ScanState, cs8ScanState_allocs = (C.int8_t)(x.S8ScanState), cgoAllocsUnknown
	allocsb63164d6.Borrow(cs8ScanState_allocs)

	var c__PAD16___allocs *cgoAllocMap
	refb63164d6.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocsb63164d6.Borrow(c__PAD16___allocs)

	x.refb63164d6 = refb63164d6
	x.allocsb63164d6 = allocsb63164d6
	return refb63164d6, allocsb63164d6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mScanDone) PassValue() (C.tstrM2mScanDone, *cgoAllocMap) {
	if x.refb63164d6 != nil {
		return *x.refb63164d6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mScanDone) Deref() {
	if x.refb63164d6 == nil {
		return
	}
	x.U8NumofCh = (byte)(x.refb63164d6.u8NumofCh)
	x.S8ScanState = (int8)(x.refb63164d6.s8ScanState)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.refb63164d6.__PAD16__))
}

// allocM2mReqScanResultMemory allocates memory for type C.tstrM2mReqScanResult in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mReqScanResultMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mReqScanResultValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mReqScanResultValue = unsafe.Sizeof([1]C.tstrM2mReqScanResult{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mReqScanResult) Ref() *C.tstrM2mReqScanResult {
	if x == nil {
		return nil
	}
	return x.refec922c38
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mReqScanResult) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refec922c38)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mReqScanResult) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mReqScanResult) Free() {
	if x != nil && x.allocsec922c38 != nil {
		x.allocsec922c38.(*cgoAllocMap).Free()
		x.refec922c38 = nil
	}
}

// NewM2mReqScanResultRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mReqScanResultRef(ref unsafe.Pointer) *M2mReqScanResult {
	if ref == nil {
		return nil
	}
	obj := new(M2mReqScanResult)
	obj.refec922c38 = (*C.tstrM2mReqScanResult)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mReqScanResult) PassRef() (*C.tstrM2mReqScanResult, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refec922c38 != nil {
		return x.refec922c38, nil
	}
	memec922c38 := allocM2mReqScanResultMemory(1)
	refec922c38 := (*C.tstrM2mReqScanResult)(memec922c38)
	allocsec922c38 := new(cgoAllocMap)
	allocsec922c38.Add(memec922c38)

	var cu8Index_allocs *cgoAllocMap
	refec922c38.u8Index, cu8Index_allocs = (C.uint8_t)(x.U8Index), cgoAllocsUnknown
	allocsec922c38.Borrow(cu8Index_allocs)

	var c__PAD24___allocs *cgoAllocMap
	refec922c38.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocsec922c38.Borrow(c__PAD24___allocs)

	x.refec922c38 = refec922c38
	x.allocsec922c38 = allocsec922c38
	return refec922c38, allocsec922c38

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mReqScanResult) PassValue() (C.tstrM2mReqScanResult, *cgoAllocMap) {
	if x.refec922c38 != nil {
		return *x.refec922c38, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mReqScanResult) Deref() {
	if x.refec922c38 == nil {
		return
	}
	x.U8Index = (byte)(x.refec922c38.u8Index)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.refec922c38.__PAD24__))
}

// allocM2mWifiscanResultMemory allocates memory for type C.tstrM2mWifiscanResult in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiscanResultMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiscanResultValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiscanResultValue = unsafe.Sizeof([1]C.tstrM2mWifiscanResult{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiscanResult) Ref() *C.tstrM2mWifiscanResult {
	if x == nil {
		return nil
	}
	return x.reffc3bcece
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiscanResult) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reffc3bcece)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiscanResult) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiscanResult) Free() {
	if x != nil && x.allocsfc3bcece != nil {
		x.allocsfc3bcece.(*cgoAllocMap).Free()
		x.reffc3bcece = nil
	}
}

// NewM2mWifiscanResultRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiscanResultRef(ref unsafe.Pointer) *M2mWifiscanResult {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiscanResult)
	obj.reffc3bcece = (*C.tstrM2mWifiscanResult)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiscanResult) PassRef() (*C.tstrM2mWifiscanResult, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reffc3bcece != nil {
		return x.reffc3bcece, nil
	}
	memfc3bcece := allocM2mWifiscanResultMemory(1)
	reffc3bcece := (*C.tstrM2mWifiscanResult)(memfc3bcece)
	allocsfc3bcece := new(cgoAllocMap)
	allocsfc3bcece.Add(memfc3bcece)

	var cu8index_allocs *cgoAllocMap
	reffc3bcece.u8index, cu8index_allocs = (C.uint8_t)(x.U8index), cgoAllocsUnknown
	allocsfc3bcece.Borrow(cu8index_allocs)

	var cs8rssi_allocs *cgoAllocMap
	reffc3bcece.s8rssi, cs8rssi_allocs = (C.int8_t)(x.S8rssi), cgoAllocsUnknown
	allocsfc3bcece.Borrow(cs8rssi_allocs)

	var cu8AuthType_allocs *cgoAllocMap
	reffc3bcece.u8AuthType, cu8AuthType_allocs = (C.uint8_t)(x.U8AuthType), cgoAllocsUnknown
	allocsfc3bcece.Borrow(cu8AuthType_allocs)

	var cu8ch_allocs *cgoAllocMap
	reffc3bcece.u8ch, cu8ch_allocs = (C.uint8_t)(x.U8ch), cgoAllocsUnknown
	allocsfc3bcece.Borrow(cu8ch_allocs)

	var cau8BSSID_allocs *cgoAllocMap
	reffc3bcece.au8BSSID, cau8BSSID_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8BSSID)), cgoAllocsUnknown
	allocsfc3bcece.Borrow(cau8BSSID_allocs)

	var cau8SSID_allocs *cgoAllocMap
	reffc3bcece.au8SSID, cau8SSID_allocs = *(*[33]C.uint8_t)(unsafe.Pointer(&x.Au8SSID)), cgoAllocsUnknown
	allocsfc3bcece.Borrow(cau8SSID_allocs)

	var c_PAD8__allocs *cgoAllocMap
	reffc3bcece._PAD8_, c_PAD8__allocs = (C.uint8_t)(x._PAD8_), cgoAllocsUnknown
	allocsfc3bcece.Borrow(c_PAD8__allocs)

	x.reffc3bcece = reffc3bcece
	x.allocsfc3bcece = allocsfc3bcece
	return reffc3bcece, allocsfc3bcece

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiscanResult) PassValue() (C.tstrM2mWifiscanResult, *cgoAllocMap) {
	if x.reffc3bcece != nil {
		return *x.reffc3bcece, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiscanResult) Deref() {
	if x.reffc3bcece == nil {
		return
	}
	x.U8index = (byte)(x.reffc3bcece.u8index)
	x.S8rssi = (int8)(x.reffc3bcece.s8rssi)
	x.U8AuthType = (byte)(x.reffc3bcece.u8AuthType)
	x.U8ch = (byte)(x.reffc3bcece.u8ch)
	x.Au8BSSID = *(*[6]byte)(unsafe.Pointer(&x.reffc3bcece.au8BSSID))
	x.Au8SSID = *(*[33]byte)(unsafe.Pointer(&x.reffc3bcece.au8SSID))
	x._PAD8_ = (byte)(x.reffc3bcece._PAD8_)
}

// allocM2mWifiStateChangedMemory allocates memory for type C.tstrM2mWifiStateChanged in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mWifiStateChangedMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mWifiStateChangedValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mWifiStateChangedValue = unsafe.Sizeof([1]C.tstrM2mWifiStateChanged{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mWifiStateChanged) Ref() *C.tstrM2mWifiStateChanged {
	if x == nil {
		return nil
	}
	return x.reff7464335
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mWifiStateChanged) SizeOf() uintptr {
	return unsafe.Sizeof(*x.reff7464335)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mWifiStateChanged) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mWifiStateChanged) Free() {
	if x != nil && x.allocsf7464335 != nil {
		x.allocsf7464335.(*cgoAllocMap).Free()
		x.reff7464335 = nil
	}
}

// NewM2mWifiStateChangedRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mWifiStateChangedRef(ref unsafe.Pointer) *M2mWifiStateChanged {
	if ref == nil {
		return nil
	}
	obj := new(M2mWifiStateChanged)
	obj.reff7464335 = (*C.tstrM2mWifiStateChanged)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mWifiStateChanged) PassRef() (*C.tstrM2mWifiStateChanged, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff7464335 != nil {
		return x.reff7464335, nil
	}
	memf7464335 := allocM2mWifiStateChangedMemory(1)
	reff7464335 := (*C.tstrM2mWifiStateChanged)(memf7464335)
	allocsf7464335 := new(cgoAllocMap)
	allocsf7464335.Add(memf7464335)

	var cu8CurrState_allocs *cgoAllocMap
	reff7464335.u8CurrState, cu8CurrState_allocs = (C.uint8_t)(x.U8CurrState), cgoAllocsUnknown
	allocsf7464335.Borrow(cu8CurrState_allocs)

	var cu8ErrCode_allocs *cgoAllocMap
	reff7464335.u8ErrCode, cu8ErrCode_allocs = (C.uint8_t)(x.U8ErrCode), cgoAllocsUnknown
	allocsf7464335.Borrow(cu8ErrCode_allocs)

	var c__PAD16___allocs *cgoAllocMap
	reff7464335.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocsf7464335.Borrow(c__PAD16___allocs)

	x.reff7464335 = reff7464335
	x.allocsf7464335 = allocsf7464335
	return reff7464335, allocsf7464335

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mWifiStateChanged) PassValue() (C.tstrM2mWifiStateChanged, *cgoAllocMap) {
	if x.reff7464335 != nil {
		return *x.reff7464335, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mWifiStateChanged) Deref() {
	if x.reff7464335 == nil {
		return
	}
	x.U8CurrState = (byte)(x.reff7464335.u8CurrState)
	x.U8ErrCode = (byte)(x.reff7464335.u8ErrCode)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.reff7464335.__PAD16__))
}

// allocM2mPsTypeMemory allocates memory for type C.tstrM2mPsType in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mPsTypeMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mPsTypeValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mPsTypeValue = unsafe.Sizeof([1]C.tstrM2mPsType{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mPsType) Ref() *C.tstrM2mPsType {
	if x == nil {
		return nil
	}
	return x.ref27aa5fd6
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mPsType) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref27aa5fd6)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mPsType) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mPsType) Free() {
	if x != nil && x.allocs27aa5fd6 != nil {
		x.allocs27aa5fd6.(*cgoAllocMap).Free()
		x.ref27aa5fd6 = nil
	}
}

// NewM2mPsTypeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mPsTypeRef(ref unsafe.Pointer) *M2mPsType {
	if ref == nil {
		return nil
	}
	obj := new(M2mPsType)
	obj.ref27aa5fd6 = (*C.tstrM2mPsType)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mPsType) PassRef() (*C.tstrM2mPsType, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref27aa5fd6 != nil {
		return x.ref27aa5fd6, nil
	}
	mem27aa5fd6 := allocM2mPsTypeMemory(1)
	ref27aa5fd6 := (*C.tstrM2mPsType)(mem27aa5fd6)
	allocs27aa5fd6 := new(cgoAllocMap)
	allocs27aa5fd6.Add(mem27aa5fd6)

	var cu8PsType_allocs *cgoAllocMap
	ref27aa5fd6.u8PsType, cu8PsType_allocs = (C.uint8_t)(x.U8PsType), cgoAllocsUnknown
	allocs27aa5fd6.Borrow(cu8PsType_allocs)

	var cu8BcastEn_allocs *cgoAllocMap
	ref27aa5fd6.u8BcastEn, cu8BcastEn_allocs = (C.uint8_t)(x.U8BcastEn), cgoAllocsUnknown
	allocs27aa5fd6.Borrow(cu8BcastEn_allocs)

	var c__PAD16___allocs *cgoAllocMap
	ref27aa5fd6.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocs27aa5fd6.Borrow(c__PAD16___allocs)

	x.ref27aa5fd6 = ref27aa5fd6
	x.allocs27aa5fd6 = allocs27aa5fd6
	return ref27aa5fd6, allocs27aa5fd6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mPsType) PassValue() (C.tstrM2mPsType, *cgoAllocMap) {
	if x.ref27aa5fd6 != nil {
		return *x.ref27aa5fd6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mPsType) Deref() {
	if x.ref27aa5fd6 == nil {
		return
	}
	x.U8PsType = (byte)(x.ref27aa5fd6.u8PsType)
	x.U8BcastEn = (byte)(x.ref27aa5fd6.u8BcastEn)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.ref27aa5fd6.__PAD16__))
}

// allocM2mSlpReqTimeMemory allocates memory for type C.tstrM2mSlpReqTime in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mSlpReqTimeMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mSlpReqTimeValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mSlpReqTimeValue = unsafe.Sizeof([1]C.tstrM2mSlpReqTime{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mSlpReqTime) Ref() *C.tstrM2mSlpReqTime {
	if x == nil {
		return nil
	}
	return x.refb428ccb8
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mSlpReqTime) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refb428ccb8)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mSlpReqTime) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mSlpReqTime) Free() {
	if x != nil && x.allocsb428ccb8 != nil {
		x.allocsb428ccb8.(*cgoAllocMap).Free()
		x.refb428ccb8 = nil
	}
}

// NewM2mSlpReqTimeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mSlpReqTimeRef(ref unsafe.Pointer) *M2mSlpReqTime {
	if ref == nil {
		return nil
	}
	obj := new(M2mSlpReqTime)
	obj.refb428ccb8 = (*C.tstrM2mSlpReqTime)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mSlpReqTime) PassRef() (*C.tstrM2mSlpReqTime, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb428ccb8 != nil {
		return x.refb428ccb8, nil
	}
	memb428ccb8 := allocM2mSlpReqTimeMemory(1)
	refb428ccb8 := (*C.tstrM2mSlpReqTime)(memb428ccb8)
	allocsb428ccb8 := new(cgoAllocMap)
	allocsb428ccb8.Add(memb428ccb8)

	var cu32SleepTime_allocs *cgoAllocMap
	refb428ccb8.u32SleepTime, cu32SleepTime_allocs = (C.uint32_t)(x.U32SleepTime), cgoAllocsUnknown
	allocsb428ccb8.Borrow(cu32SleepTime_allocs)

	x.refb428ccb8 = refb428ccb8
	x.allocsb428ccb8 = allocsb428ccb8
	return refb428ccb8, allocsb428ccb8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mSlpReqTime) PassValue() (C.tstrM2mSlpReqTime, *cgoAllocMap) {
	if x.refb428ccb8 != nil {
		return *x.refb428ccb8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mSlpReqTime) Deref() {
	if x.refb428ccb8 == nil {
		return
	}
	x.U32SleepTime = (uint32)(x.refb428ccb8.u32SleepTime)
}

// allocM2mLsnIntMemory allocates memory for type C.tstrM2mLsnInt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mLsnIntMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mLsnIntValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mLsnIntValue = unsafe.Sizeof([1]C.tstrM2mLsnInt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mLsnInt) Ref() *C.tstrM2mLsnInt {
	if x == nil {
		return nil
	}
	return x.ref56b27f4e
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mLsnInt) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref56b27f4e)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mLsnInt) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mLsnInt) Free() {
	if x != nil && x.allocs56b27f4e != nil {
		x.allocs56b27f4e.(*cgoAllocMap).Free()
		x.ref56b27f4e = nil
	}
}

// NewM2mLsnIntRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mLsnIntRef(ref unsafe.Pointer) *M2mLsnInt {
	if ref == nil {
		return nil
	}
	obj := new(M2mLsnInt)
	obj.ref56b27f4e = (*C.tstrM2mLsnInt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mLsnInt) PassRef() (*C.tstrM2mLsnInt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56b27f4e != nil {
		return x.ref56b27f4e, nil
	}
	mem56b27f4e := allocM2mLsnIntMemory(1)
	ref56b27f4e := (*C.tstrM2mLsnInt)(mem56b27f4e)
	allocs56b27f4e := new(cgoAllocMap)
	allocs56b27f4e.Add(mem56b27f4e)

	var cu16LsnInt_allocs *cgoAllocMap
	ref56b27f4e.u16LsnInt, cu16LsnInt_allocs = (C.uint16_t)(x.U16LsnInt), cgoAllocsUnknown
	allocs56b27f4e.Borrow(cu16LsnInt_allocs)

	var c__PAD16___allocs *cgoAllocMap
	ref56b27f4e.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocs56b27f4e.Borrow(c__PAD16___allocs)

	x.ref56b27f4e = ref56b27f4e
	x.allocs56b27f4e = allocs56b27f4e
	return ref56b27f4e, allocs56b27f4e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mLsnInt) PassValue() (C.tstrM2mLsnInt, *cgoAllocMap) {
	if x.ref56b27f4e != nil {
		return *x.ref56b27f4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mLsnInt) Deref() {
	if x.ref56b27f4e == nil {
		return
	}
	x.U16LsnInt = (uint16)(x.ref56b27f4e.u16LsnInt)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.ref56b27f4e.__PAD16__))
}

// allocM2MWifiMonitorModeCtrlMemory allocates memory for type C.tstrM2MWifiMonitorModeCtrl in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MWifiMonitorModeCtrlMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MWifiMonitorModeCtrlValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MWifiMonitorModeCtrlValue = unsafe.Sizeof([1]C.tstrM2MWifiMonitorModeCtrl{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MWifiMonitorModeCtrl) Ref() *C.tstrM2MWifiMonitorModeCtrl {
	if x == nil {
		return nil
	}
	return x.refc77b0df
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MWifiMonitorModeCtrl) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refc77b0df)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MWifiMonitorModeCtrl) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MWifiMonitorModeCtrl) Free() {
	if x != nil && x.allocsc77b0df != nil {
		x.allocsc77b0df.(*cgoAllocMap).Free()
		x.refc77b0df = nil
	}
}

// NewM2MWifiMonitorModeCtrlRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MWifiMonitorModeCtrlRef(ref unsafe.Pointer) *M2MWifiMonitorModeCtrl {
	if ref == nil {
		return nil
	}
	obj := new(M2MWifiMonitorModeCtrl)
	obj.refc77b0df = (*C.tstrM2MWifiMonitorModeCtrl)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MWifiMonitorModeCtrl) PassRef() (*C.tstrM2MWifiMonitorModeCtrl, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc77b0df != nil {
		return x.refc77b0df, nil
	}
	memc77b0df := allocM2MWifiMonitorModeCtrlMemory(1)
	refc77b0df := (*C.tstrM2MWifiMonitorModeCtrl)(memc77b0df)
	allocsc77b0df := new(cgoAllocMap)
	allocsc77b0df.Add(memc77b0df)

	var cu8ChannelID_allocs *cgoAllocMap
	refc77b0df.u8ChannelID, cu8ChannelID_allocs = (C.uint8_t)(x.U8ChannelID), cgoAllocsUnknown
	allocsc77b0df.Borrow(cu8ChannelID_allocs)

	var cu8FrameType_allocs *cgoAllocMap
	refc77b0df.u8FrameType, cu8FrameType_allocs = (C.uint8_t)(x.U8FrameType), cgoAllocsUnknown
	allocsc77b0df.Borrow(cu8FrameType_allocs)

	var cu8FrameSubtype_allocs *cgoAllocMap
	refc77b0df.u8FrameSubtype, cu8FrameSubtype_allocs = (C.uint8_t)(x.U8FrameSubtype), cgoAllocsUnknown
	allocsc77b0df.Borrow(cu8FrameSubtype_allocs)

	var cau8SrcMacAddress_allocs *cgoAllocMap
	refc77b0df.au8SrcMacAddress, cau8SrcMacAddress_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8SrcMacAddress)), cgoAllocsUnknown
	allocsc77b0df.Borrow(cau8SrcMacAddress_allocs)

	var cau8DstMacAddress_allocs *cgoAllocMap
	refc77b0df.au8DstMacAddress, cau8DstMacAddress_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8DstMacAddress)), cgoAllocsUnknown
	allocsc77b0df.Borrow(cau8DstMacAddress_allocs)

	var cau8BSSID_allocs *cgoAllocMap
	refc77b0df.au8BSSID, cau8BSSID_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8BSSID)), cgoAllocsUnknown
	allocsc77b0df.Borrow(cau8BSSID_allocs)

	var cu8EnRecvHdr_allocs *cgoAllocMap
	refc77b0df.u8EnRecvHdr, cu8EnRecvHdr_allocs = (C.uint8_t)(x.U8EnRecvHdr), cgoAllocsUnknown
	allocsc77b0df.Borrow(cu8EnRecvHdr_allocs)

	var c__PAD16___allocs *cgoAllocMap
	refc77b0df.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocsc77b0df.Borrow(c__PAD16___allocs)

	x.refc77b0df = refc77b0df
	x.allocsc77b0df = allocsc77b0df
	return refc77b0df, allocsc77b0df

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MWifiMonitorModeCtrl) PassValue() (C.tstrM2MWifiMonitorModeCtrl, *cgoAllocMap) {
	if x.refc77b0df != nil {
		return *x.refc77b0df, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MWifiMonitorModeCtrl) Deref() {
	if x.refc77b0df == nil {
		return
	}
	x.U8ChannelID = (byte)(x.refc77b0df.u8ChannelID)
	x.U8FrameType = (byte)(x.refc77b0df.u8FrameType)
	x.U8FrameSubtype = (byte)(x.refc77b0df.u8FrameSubtype)
	x.Au8SrcMacAddress = *(*[6]byte)(unsafe.Pointer(&x.refc77b0df.au8SrcMacAddress))
	x.Au8DstMacAddress = *(*[6]byte)(unsafe.Pointer(&x.refc77b0df.au8DstMacAddress))
	x.Au8BSSID = *(*[6]byte)(unsafe.Pointer(&x.refc77b0df.au8BSSID))
	x.U8EnRecvHdr = (byte)(x.refc77b0df.u8EnRecvHdr)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.refc77b0df.__PAD16__))
}

// allocM2MWifiRxPacketInfoMemory allocates memory for type C.tstrM2MWifiRxPacketInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MWifiRxPacketInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MWifiRxPacketInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MWifiRxPacketInfoValue = unsafe.Sizeof([1]C.tstrM2MWifiRxPacketInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MWifiRxPacketInfo) Ref() *C.tstrM2MWifiRxPacketInfo {
	if x == nil {
		return nil
	}
	return x.ref8954124c
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MWifiRxPacketInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref8954124c)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MWifiRxPacketInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MWifiRxPacketInfo) Free() {
	if x != nil && x.allocs8954124c != nil {
		x.allocs8954124c.(*cgoAllocMap).Free()
		x.ref8954124c = nil
	}
}

// NewM2MWifiRxPacketInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MWifiRxPacketInfoRef(ref unsafe.Pointer) *M2MWifiRxPacketInfo {
	if ref == nil {
		return nil
	}
	obj := new(M2MWifiRxPacketInfo)
	obj.ref8954124c = (*C.tstrM2MWifiRxPacketInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MWifiRxPacketInfo) PassRef() (*C.tstrM2MWifiRxPacketInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8954124c != nil {
		return x.ref8954124c, nil
	}
	mem8954124c := allocM2MWifiRxPacketInfoMemory(1)
	ref8954124c := (*C.tstrM2MWifiRxPacketInfo)(mem8954124c)
	allocs8954124c := new(cgoAllocMap)
	allocs8954124c.Add(mem8954124c)

	var cu8FrameType_allocs *cgoAllocMap
	ref8954124c.u8FrameType, cu8FrameType_allocs = (C.uint8_t)(x.U8FrameType), cgoAllocsUnknown
	allocs8954124c.Borrow(cu8FrameType_allocs)

	var cu8FrameSubtype_allocs *cgoAllocMap
	ref8954124c.u8FrameSubtype, cu8FrameSubtype_allocs = (C.uint8_t)(x.U8FrameSubtype), cgoAllocsUnknown
	allocs8954124c.Borrow(cu8FrameSubtype_allocs)

	var cu8ServiceClass_allocs *cgoAllocMap
	ref8954124c.u8ServiceClass, cu8ServiceClass_allocs = (C.uint8_t)(x.U8ServiceClass), cgoAllocsUnknown
	allocs8954124c.Borrow(cu8ServiceClass_allocs)

	var cu8Priority_allocs *cgoAllocMap
	ref8954124c.u8Priority, cu8Priority_allocs = (C.uint8_t)(x.U8Priority), cgoAllocsUnknown
	allocs8954124c.Borrow(cu8Priority_allocs)

	var cu8HeaderLength_allocs *cgoAllocMap
	ref8954124c.u8HeaderLength, cu8HeaderLength_allocs = (C.uint8_t)(x.U8HeaderLength), cgoAllocsUnknown
	allocs8954124c.Borrow(cu8HeaderLength_allocs)

	var cu8CipherType_allocs *cgoAllocMap
	ref8954124c.u8CipherType, cu8CipherType_allocs = (C.uint8_t)(x.U8CipherType), cgoAllocsUnknown
	allocs8954124c.Borrow(cu8CipherType_allocs)

	var cau8SrcMacAddress_allocs *cgoAllocMap
	ref8954124c.au8SrcMacAddress, cau8SrcMacAddress_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8SrcMacAddress)), cgoAllocsUnknown
	allocs8954124c.Borrow(cau8SrcMacAddress_allocs)

	var cau8DstMacAddress_allocs *cgoAllocMap
	ref8954124c.au8DstMacAddress, cau8DstMacAddress_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8DstMacAddress)), cgoAllocsUnknown
	allocs8954124c.Borrow(cau8DstMacAddress_allocs)

	var cau8BSSID_allocs *cgoAllocMap
	ref8954124c.au8BSSID, cau8BSSID_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8BSSID)), cgoAllocsUnknown
	allocs8954124c.Borrow(cau8BSSID_allocs)

	var cu16DataLength_allocs *cgoAllocMap
	ref8954124c.u16DataLength, cu16DataLength_allocs = (C.uint16_t)(x.U16DataLength), cgoAllocsUnknown
	allocs8954124c.Borrow(cu16DataLength_allocs)

	var cu16FrameLength_allocs *cgoAllocMap
	ref8954124c.u16FrameLength, cu16FrameLength_allocs = (C.uint16_t)(x.U16FrameLength), cgoAllocsUnknown
	allocs8954124c.Borrow(cu16FrameLength_allocs)

	var cu32DataRateKbps_allocs *cgoAllocMap
	ref8954124c.u32DataRateKbps, cu32DataRateKbps_allocs = (C.uint32_t)(x.U32DataRateKbps), cgoAllocsUnknown
	allocs8954124c.Borrow(cu32DataRateKbps_allocs)

	var cs8RSSI_allocs *cgoAllocMap
	ref8954124c.s8RSSI, cs8RSSI_allocs = (C.int8_t)(x.S8RSSI), cgoAllocsUnknown
	allocs8954124c.Borrow(cs8RSSI_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref8954124c.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs8954124c.Borrow(c__PAD24___allocs)

	x.ref8954124c = ref8954124c
	x.allocs8954124c = allocs8954124c
	return ref8954124c, allocs8954124c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MWifiRxPacketInfo) PassValue() (C.tstrM2MWifiRxPacketInfo, *cgoAllocMap) {
	if x.ref8954124c != nil {
		return *x.ref8954124c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MWifiRxPacketInfo) Deref() {
	if x.ref8954124c == nil {
		return
	}
	x.U8FrameType = (byte)(x.ref8954124c.u8FrameType)
	x.U8FrameSubtype = (byte)(x.ref8954124c.u8FrameSubtype)
	x.U8ServiceClass = (byte)(x.ref8954124c.u8ServiceClass)
	x.U8Priority = (byte)(x.ref8954124c.u8Priority)
	x.U8HeaderLength = (byte)(x.ref8954124c.u8HeaderLength)
	x.U8CipherType = (byte)(x.ref8954124c.u8CipherType)
	x.Au8SrcMacAddress = *(*[6]byte)(unsafe.Pointer(&x.ref8954124c.au8SrcMacAddress))
	x.Au8DstMacAddress = *(*[6]byte)(unsafe.Pointer(&x.ref8954124c.au8DstMacAddress))
	x.Au8BSSID = *(*[6]byte)(unsafe.Pointer(&x.ref8954124c.au8BSSID))
	x.U16DataLength = (uint16)(x.ref8954124c.u16DataLength)
	x.U16FrameLength = (uint16)(x.ref8954124c.u16FrameLength)
	x.U32DataRateKbps = (uint32)(x.ref8954124c.u32DataRateKbps)
	x.S8RSSI = (int8)(x.ref8954124c.s8RSSI)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref8954124c.__PAD24__))
}

// allocM2MWifiTxPacketInfoMemory allocates memory for type C.tstrM2MWifiTxPacketInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MWifiTxPacketInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MWifiTxPacketInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MWifiTxPacketInfoValue = unsafe.Sizeof([1]C.tstrM2MWifiTxPacketInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MWifiTxPacketInfo) Ref() *C.tstrM2MWifiTxPacketInfo {
	if x == nil {
		return nil
	}
	return x.ref6669b7ac
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MWifiTxPacketInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref6669b7ac)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MWifiTxPacketInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MWifiTxPacketInfo) Free() {
	if x != nil && x.allocs6669b7ac != nil {
		x.allocs6669b7ac.(*cgoAllocMap).Free()
		x.ref6669b7ac = nil
	}
}

// NewM2MWifiTxPacketInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MWifiTxPacketInfoRef(ref unsafe.Pointer) *M2MWifiTxPacketInfo {
	if ref == nil {
		return nil
	}
	obj := new(M2MWifiTxPacketInfo)
	obj.ref6669b7ac = (*C.tstrM2MWifiTxPacketInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MWifiTxPacketInfo) PassRef() (*C.tstrM2MWifiTxPacketInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6669b7ac != nil {
		return x.ref6669b7ac, nil
	}
	mem6669b7ac := allocM2MWifiTxPacketInfoMemory(1)
	ref6669b7ac := (*C.tstrM2MWifiTxPacketInfo)(mem6669b7ac)
	allocs6669b7ac := new(cgoAllocMap)
	allocs6669b7ac.Add(mem6669b7ac)

	var cu16PacketSize_allocs *cgoAllocMap
	ref6669b7ac.u16PacketSize, cu16PacketSize_allocs = (C.uint16_t)(x.U16PacketSize), cgoAllocsUnknown
	allocs6669b7ac.Borrow(cu16PacketSize_allocs)

	var cu16HeaderLength_allocs *cgoAllocMap
	ref6669b7ac.u16HeaderLength, cu16HeaderLength_allocs = (C.uint16_t)(x.U16HeaderLength), cgoAllocsUnknown
	allocs6669b7ac.Borrow(cu16HeaderLength_allocs)

	x.ref6669b7ac = ref6669b7ac
	x.allocs6669b7ac = allocs6669b7ac
	return ref6669b7ac, allocs6669b7ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MWifiTxPacketInfo) PassValue() (C.tstrM2MWifiTxPacketInfo, *cgoAllocMap) {
	if x.ref6669b7ac != nil {
		return *x.ref6669b7ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MWifiTxPacketInfo) Deref() {
	if x.ref6669b7ac == nil {
		return
	}
	x.U16PacketSize = (uint16)(x.ref6669b7ac.u16PacketSize)
	x.U16HeaderLength = (uint16)(x.ref6669b7ac.u16HeaderLength)
}

// allocM2MAPConfigMemory allocates memory for type C.tstrM2MAPConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MAPConfigMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MAPConfigValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MAPConfigValue = unsafe.Sizeof([1]C.tstrM2MAPConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MAPConfig) Ref() *C.tstrM2MAPConfig {
	if x == nil {
		return nil
	}
	return x.ref85c0615f
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MAPConfig) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref85c0615f)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MAPConfig) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MAPConfig) Free() {
	if x != nil && x.allocs85c0615f != nil {
		x.allocs85c0615f.(*cgoAllocMap).Free()
		x.ref85c0615f = nil
	}
}

// NewM2MAPConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MAPConfigRef(ref unsafe.Pointer) *M2MAPConfig {
	if ref == nil {
		return nil
	}
	obj := new(M2MAPConfig)
	obj.ref85c0615f = (*C.tstrM2MAPConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MAPConfig) PassRef() (*C.tstrM2MAPConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c0615f != nil {
		return x.ref85c0615f, nil
	}
	mem85c0615f := allocM2MAPConfigMemory(1)
	ref85c0615f := (*C.tstrM2MAPConfig)(mem85c0615f)
	allocs85c0615f := new(cgoAllocMap)
	allocs85c0615f.Add(mem85c0615f)

	var cau8SSID_allocs *cgoAllocMap
	ref85c0615f.au8SSID, cau8SSID_allocs = *(*[33]C.uint8_t)(unsafe.Pointer(&x.Au8SSID)), cgoAllocsUnknown
	allocs85c0615f.Borrow(cau8SSID_allocs)

	var cu8ListenChannel_allocs *cgoAllocMap
	ref85c0615f.u8ListenChannel, cu8ListenChannel_allocs = (C.uint8_t)(x.U8ListenChannel), cgoAllocsUnknown
	allocs85c0615f.Borrow(cu8ListenChannel_allocs)

	var cu8KeyIndx_allocs *cgoAllocMap
	ref85c0615f.u8KeyIndx, cu8KeyIndx_allocs = (C.uint8_t)(x.U8KeyIndx), cgoAllocsUnknown
	allocs85c0615f.Borrow(cu8KeyIndx_allocs)

	var cu8KeySz_allocs *cgoAllocMap
	ref85c0615f.u8KeySz, cu8KeySz_allocs = (C.uint8_t)(x.U8KeySz), cgoAllocsUnknown
	allocs85c0615f.Borrow(cu8KeySz_allocs)

	var cau8WepKey_allocs *cgoAllocMap
	ref85c0615f.au8WepKey, cau8WepKey_allocs = *(*[27]C.uint8_t)(unsafe.Pointer(&x.Au8WepKey)), cgoAllocsUnknown
	allocs85c0615f.Borrow(cau8WepKey_allocs)

	var cu8SecType_allocs *cgoAllocMap
	ref85c0615f.u8SecType, cu8SecType_allocs = (C.uint8_t)(x.U8SecType), cgoAllocsUnknown
	allocs85c0615f.Borrow(cu8SecType_allocs)

	var cu8SsidHide_allocs *cgoAllocMap
	ref85c0615f.u8SsidHide, cu8SsidHide_allocs = (C.uint8_t)(x.U8SsidHide), cgoAllocsUnknown
	allocs85c0615f.Borrow(cu8SsidHide_allocs)

	var cau8DHCPServerIP_allocs *cgoAllocMap
	ref85c0615f.au8DHCPServerIP, cau8DHCPServerIP_allocs = *(*[4]C.uint8_t)(unsafe.Pointer(&x.Au8DHCPServerIP)), cgoAllocsUnknown
	allocs85c0615f.Borrow(cau8DHCPServerIP_allocs)

	var cau8Key_allocs *cgoAllocMap
	ref85c0615f.au8Key, cau8Key_allocs = *(*[65]C.uint8_t)(unsafe.Pointer(&x.Au8Key)), cgoAllocsUnknown
	allocs85c0615f.Borrow(cau8Key_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref85c0615f.__PAD24__, c__PAD24___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs85c0615f.Borrow(c__PAD24___allocs)

	x.ref85c0615f = ref85c0615f
	x.allocs85c0615f = allocs85c0615f
	return ref85c0615f, allocs85c0615f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MAPConfig) PassValue() (C.tstrM2MAPConfig, *cgoAllocMap) {
	if x.ref85c0615f != nil {
		return *x.ref85c0615f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MAPConfig) Deref() {
	if x.ref85c0615f == nil {
		return
	}
	x.Au8SSID = *(*[33]byte)(unsafe.Pointer(&x.ref85c0615f.au8SSID))
	x.U8ListenChannel = (byte)(x.ref85c0615f.u8ListenChannel)
	x.U8KeyIndx = (byte)(x.ref85c0615f.u8KeyIndx)
	x.U8KeySz = (byte)(x.ref85c0615f.u8KeySz)
	x.Au8WepKey = *(*[27]byte)(unsafe.Pointer(&x.ref85c0615f.au8WepKey))
	x.U8SecType = (byte)(x.ref85c0615f.u8SecType)
	x.U8SsidHide = (byte)(x.ref85c0615f.u8SsidHide)
	x.Au8DHCPServerIP = *(*[4]byte)(unsafe.Pointer(&x.ref85c0615f.au8DHCPServerIP))
	x.Au8Key = *(*[65]byte)(unsafe.Pointer(&x.ref85c0615f.au8Key))
	x.__PAD24__ = *(*[2]byte)(unsafe.Pointer(&x.ref85c0615f.__PAD24__))
}

// allocM2MAPConfigExtMemory allocates memory for type C.tstrM2MAPConfigExt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MAPConfigExtMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MAPConfigExtValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MAPConfigExtValue = unsafe.Sizeof([1]C.tstrM2MAPConfigExt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MAPConfigExt) Ref() *C.tstrM2MAPConfigExt {
	if x == nil {
		return nil
	}
	return x.refb9fc21bc
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MAPConfigExt) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refb9fc21bc)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MAPConfigExt) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MAPConfigExt) Free() {
	if x != nil && x.allocsb9fc21bc != nil {
		x.allocsb9fc21bc.(*cgoAllocMap).Free()
		x.refb9fc21bc = nil
	}
}

// NewM2MAPConfigExtRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MAPConfigExtRef(ref unsafe.Pointer) *M2MAPConfigExt {
	if ref == nil {
		return nil
	}
	obj := new(M2MAPConfigExt)
	obj.refb9fc21bc = (*C.tstrM2MAPConfigExt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MAPConfigExt) PassRef() (*C.tstrM2MAPConfigExt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb9fc21bc != nil {
		return x.refb9fc21bc, nil
	}
	memb9fc21bc := allocM2MAPConfigExtMemory(1)
	refb9fc21bc := (*C.tstrM2MAPConfigExt)(memb9fc21bc)
	allocsb9fc21bc := new(cgoAllocMap)
	allocsb9fc21bc.Add(memb9fc21bc)

	var cau8DefRouterIP_allocs *cgoAllocMap
	refb9fc21bc.au8DefRouterIP, cau8DefRouterIP_allocs = *(*[4]C.uint8_t)(unsafe.Pointer(&x.Au8DefRouterIP)), cgoAllocsUnknown
	allocsb9fc21bc.Borrow(cau8DefRouterIP_allocs)

	var cau8DNSServerIP_allocs *cgoAllocMap
	refb9fc21bc.au8DNSServerIP, cau8DNSServerIP_allocs = *(*[4]C.uint8_t)(unsafe.Pointer(&x.Au8DNSServerIP)), cgoAllocsUnknown
	allocsb9fc21bc.Borrow(cau8DNSServerIP_allocs)

	var cau8SubnetMask_allocs *cgoAllocMap
	refb9fc21bc.au8SubnetMask, cau8SubnetMask_allocs = *(*[4]C.uint8_t)(unsafe.Pointer(&x.Au8SubnetMask)), cgoAllocsUnknown
	allocsb9fc21bc.Borrow(cau8SubnetMask_allocs)

	x.refb9fc21bc = refb9fc21bc
	x.allocsb9fc21bc = allocsb9fc21bc
	return refb9fc21bc, allocsb9fc21bc

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MAPConfigExt) PassValue() (C.tstrM2MAPConfigExt, *cgoAllocMap) {
	if x.refb9fc21bc != nil {
		return *x.refb9fc21bc, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MAPConfigExt) Deref() {
	if x.refb9fc21bc == nil {
		return
	}
	x.Au8DefRouterIP = *(*[4]byte)(unsafe.Pointer(&x.refb9fc21bc.au8DefRouterIP))
	x.Au8DNSServerIP = *(*[4]byte)(unsafe.Pointer(&x.refb9fc21bc.au8DNSServerIP))
	x.Au8SubnetMask = *(*[4]byte)(unsafe.Pointer(&x.refb9fc21bc.au8SubnetMask))
}

// allocM2MAPModeConfigMemory allocates memory for type C.tstrM2MAPModeConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MAPModeConfigMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MAPModeConfigValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MAPModeConfigValue = unsafe.Sizeof([1]C.tstrM2MAPModeConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MAPModeConfig) Ref() *C.tstrM2MAPModeConfig {
	if x == nil {
		return nil
	}
	return x.ref75fb89de
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MAPModeConfig) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref75fb89de)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MAPModeConfig) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MAPModeConfig) Free() {
	if x != nil && x.allocs75fb89de != nil {
		x.allocs75fb89de.(*cgoAllocMap).Free()
		x.ref75fb89de = nil
	}
}

// NewM2MAPModeConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MAPModeConfigRef(ref unsafe.Pointer) *M2MAPModeConfig {
	if ref == nil {
		return nil
	}
	obj := new(M2MAPModeConfig)
	obj.ref75fb89de = (*C.tstrM2MAPModeConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MAPModeConfig) PassRef() (*C.tstrM2MAPModeConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref75fb89de != nil {
		return x.ref75fb89de, nil
	}
	mem75fb89de := allocM2MAPModeConfigMemory(1)
	ref75fb89de := (*C.tstrM2MAPModeConfig)(mem75fb89de)
	allocs75fb89de := new(cgoAllocMap)
	allocs75fb89de.Add(mem75fb89de)

	var cstrApConfig_allocs *cgoAllocMap
	ref75fb89de.strApConfig, cstrApConfig_allocs = x.StrApConfig.PassValue()
	allocs75fb89de.Borrow(cstrApConfig_allocs)

	var cstrApConfigExt_allocs *cgoAllocMap
	ref75fb89de.strApConfigExt, cstrApConfigExt_allocs = x.StrApConfigExt.PassValue()
	allocs75fb89de.Borrow(cstrApConfigExt_allocs)

	x.ref75fb89de = ref75fb89de
	x.allocs75fb89de = allocs75fb89de
	return ref75fb89de, allocs75fb89de

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MAPModeConfig) PassValue() (C.tstrM2MAPModeConfig, *cgoAllocMap) {
	if x.ref75fb89de != nil {
		return *x.ref75fb89de, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MAPModeConfig) Deref() {
	if x.ref75fb89de == nil {
		return
	}
	x.StrApConfig = *NewM2MAPConfigRef(unsafe.Pointer(&x.ref75fb89de.strApConfig))
	x.StrApConfigExt = *NewM2MAPConfigExtRef(unsafe.Pointer(&x.ref75fb89de.strApConfigExt))
}

// allocM2mServerInitMemory allocates memory for type C.tstrM2mServerInit in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mServerInitMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mServerInitValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mServerInitValue = unsafe.Sizeof([1]C.tstrM2mServerInit{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mServerInit) Ref() *C.tstrM2mServerInit {
	if x == nil {
		return nil
	}
	return x.ref8f1c66f0
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mServerInit) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref8f1c66f0)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mServerInit) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mServerInit) Free() {
	if x != nil && x.allocs8f1c66f0 != nil {
		x.allocs8f1c66f0.(*cgoAllocMap).Free()
		x.ref8f1c66f0 = nil
	}
}

// NewM2mServerInitRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mServerInitRef(ref unsafe.Pointer) *M2mServerInit {
	if ref == nil {
		return nil
	}
	obj := new(M2mServerInit)
	obj.ref8f1c66f0 = (*C.tstrM2mServerInit)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mServerInit) PassRef() (*C.tstrM2mServerInit, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8f1c66f0 != nil {
		return x.ref8f1c66f0, nil
	}
	mem8f1c66f0 := allocM2mServerInitMemory(1)
	ref8f1c66f0 := (*C.tstrM2mServerInit)(mem8f1c66f0)
	allocs8f1c66f0 := new(cgoAllocMap)
	allocs8f1c66f0.Add(mem8f1c66f0)

	var cu8Channel_allocs *cgoAllocMap
	ref8f1c66f0.u8Channel, cu8Channel_allocs = (C.uint8_t)(x.U8Channel), cgoAllocsUnknown
	allocs8f1c66f0.Borrow(cu8Channel_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref8f1c66f0.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs8f1c66f0.Borrow(c__PAD24___allocs)

	x.ref8f1c66f0 = ref8f1c66f0
	x.allocs8f1c66f0 = allocs8f1c66f0
	return ref8f1c66f0, allocs8f1c66f0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mServerInit) PassValue() (C.tstrM2mServerInit, *cgoAllocMap) {
	if x.ref8f1c66f0 != nil {
		return *x.ref8f1c66f0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mServerInit) Deref() {
	if x.ref8f1c66f0 == nil {
		return
	}
	x.U8Channel = (byte)(x.ref8f1c66f0.u8Channel)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref8f1c66f0.__PAD24__))
}

// allocM2mClientStateMemory allocates memory for type C.tstrM2mClientState in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mClientStateMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mClientStateValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mClientStateValue = unsafe.Sizeof([1]C.tstrM2mClientState{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mClientState) Ref() *C.tstrM2mClientState {
	if x == nil {
		return nil
	}
	return x.ref13134fc2
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mClientState) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref13134fc2)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mClientState) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mClientState) Free() {
	if x != nil && x.allocs13134fc2 != nil {
		x.allocs13134fc2.(*cgoAllocMap).Free()
		x.ref13134fc2 = nil
	}
}

// NewM2mClientStateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mClientStateRef(ref unsafe.Pointer) *M2mClientState {
	if ref == nil {
		return nil
	}
	obj := new(M2mClientState)
	obj.ref13134fc2 = (*C.tstrM2mClientState)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mClientState) PassRef() (*C.tstrM2mClientState, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref13134fc2 != nil {
		return x.ref13134fc2, nil
	}
	mem13134fc2 := allocM2mClientStateMemory(1)
	ref13134fc2 := (*C.tstrM2mClientState)(mem13134fc2)
	allocs13134fc2 := new(cgoAllocMap)
	allocs13134fc2.Add(mem13134fc2)

	var cu8State_allocs *cgoAllocMap
	ref13134fc2.u8State, cu8State_allocs = (C.uint8_t)(x.U8State), cgoAllocsUnknown
	allocs13134fc2.Borrow(cu8State_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref13134fc2.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs13134fc2.Borrow(c__PAD24___allocs)

	x.ref13134fc2 = ref13134fc2
	x.allocs13134fc2 = allocs13134fc2
	return ref13134fc2, allocs13134fc2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mClientState) PassValue() (C.tstrM2mClientState, *cgoAllocMap) {
	if x.ref13134fc2 != nil {
		return *x.ref13134fc2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mClientState) Deref() {
	if x.ref13134fc2 == nil {
		return
	}
	x.U8State = (byte)(x.ref13134fc2.u8State)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref13134fc2.__PAD24__))
}

// allocM2MservercmdMemory allocates memory for type C.tstrM2Mservercmd in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MservercmdMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MservercmdValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MservercmdValue = unsafe.Sizeof([1]C.tstrM2Mservercmd{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2Mservercmd) Ref() *C.tstrM2Mservercmd {
	if x == nil {
		return nil
	}
	return x.refdb7812b5
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2Mservercmd) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refdb7812b5)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2Mservercmd) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2Mservercmd) Free() {
	if x != nil && x.allocsdb7812b5 != nil {
		x.allocsdb7812b5.(*cgoAllocMap).Free()
		x.refdb7812b5 = nil
	}
}

// NewM2MservercmdRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MservercmdRef(ref unsafe.Pointer) *M2Mservercmd {
	if ref == nil {
		return nil
	}
	obj := new(M2Mservercmd)
	obj.refdb7812b5 = (*C.tstrM2Mservercmd)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2Mservercmd) PassRef() (*C.tstrM2Mservercmd, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb7812b5 != nil {
		return x.refdb7812b5, nil
	}
	memdb7812b5 := allocM2MservercmdMemory(1)
	refdb7812b5 := (*C.tstrM2Mservercmd)(memdb7812b5)
	allocsdb7812b5 := new(cgoAllocMap)
	allocsdb7812b5.Add(memdb7812b5)

	var cu8cmd_allocs *cgoAllocMap
	refdb7812b5.u8cmd, cu8cmd_allocs = (C.uint8_t)(x.U8cmd), cgoAllocsUnknown
	allocsdb7812b5.Borrow(cu8cmd_allocs)

	var c__PAD24___allocs *cgoAllocMap
	refdb7812b5.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocsdb7812b5.Borrow(c__PAD24___allocs)

	x.refdb7812b5 = refdb7812b5
	x.allocsdb7812b5 = allocsdb7812b5
	return refdb7812b5, allocsdb7812b5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2Mservercmd) PassValue() (C.tstrM2Mservercmd, *cgoAllocMap) {
	if x.refdb7812b5 != nil {
		return *x.refdb7812b5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2Mservercmd) Deref() {
	if x.refdb7812b5 == nil {
		return
	}
	x.U8cmd = (byte)(x.refdb7812b5.u8cmd)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.refdb7812b5.__PAD24__))
}

// allocM2mSetMacAddressMemory allocates memory for type C.tstrM2mSetMacAddress in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mSetMacAddressMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mSetMacAddressValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mSetMacAddressValue = unsafe.Sizeof([1]C.tstrM2mSetMacAddress{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mSetMacAddress) Ref() *C.tstrM2mSetMacAddress {
	if x == nil {
		return nil
	}
	return x.ref34f51c02
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mSetMacAddress) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref34f51c02)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mSetMacAddress) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mSetMacAddress) Free() {
	if x != nil && x.allocs34f51c02 != nil {
		x.allocs34f51c02.(*cgoAllocMap).Free()
		x.ref34f51c02 = nil
	}
}

// NewM2mSetMacAddressRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mSetMacAddressRef(ref unsafe.Pointer) *M2mSetMacAddress {
	if ref == nil {
		return nil
	}
	obj := new(M2mSetMacAddress)
	obj.ref34f51c02 = (*C.tstrM2mSetMacAddress)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mSetMacAddress) PassRef() (*C.tstrM2mSetMacAddress, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref34f51c02 != nil {
		return x.ref34f51c02, nil
	}
	mem34f51c02 := allocM2mSetMacAddressMemory(1)
	ref34f51c02 := (*C.tstrM2mSetMacAddress)(mem34f51c02)
	allocs34f51c02 := new(cgoAllocMap)
	allocs34f51c02.Add(mem34f51c02)

	var cau8Mac_allocs *cgoAllocMap
	ref34f51c02.au8Mac, cau8Mac_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8Mac)), cgoAllocsUnknown
	allocs34f51c02.Borrow(cau8Mac_allocs)

	var c__PAD16___allocs *cgoAllocMap
	ref34f51c02.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocs34f51c02.Borrow(c__PAD16___allocs)

	x.ref34f51c02 = ref34f51c02
	x.allocs34f51c02 = allocs34f51c02
	return ref34f51c02, allocs34f51c02

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mSetMacAddress) PassValue() (C.tstrM2mSetMacAddress, *cgoAllocMap) {
	if x.ref34f51c02 != nil {
		return *x.ref34f51c02, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mSetMacAddress) Deref() {
	if x.ref34f51c02 == nil {
		return
	}
	x.Au8Mac = *(*[6]byte)(unsafe.Pointer(&x.ref34f51c02.au8Mac))
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.ref34f51c02.__PAD16__))
}

// allocM2MDeviceNameConfigMemory allocates memory for type C.tstrM2MDeviceNameConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MDeviceNameConfigMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MDeviceNameConfigValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MDeviceNameConfigValue = unsafe.Sizeof([1]C.tstrM2MDeviceNameConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MDeviceNameConfig) Ref() *C.tstrM2MDeviceNameConfig {
	if x == nil {
		return nil
	}
	return x.ref8fb03441
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MDeviceNameConfig) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref8fb03441)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MDeviceNameConfig) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MDeviceNameConfig) Free() {
	if x != nil && x.allocs8fb03441 != nil {
		x.allocs8fb03441.(*cgoAllocMap).Free()
		x.ref8fb03441 = nil
	}
}

// NewM2MDeviceNameConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MDeviceNameConfigRef(ref unsafe.Pointer) *M2MDeviceNameConfig {
	if ref == nil {
		return nil
	}
	obj := new(M2MDeviceNameConfig)
	obj.ref8fb03441 = (*C.tstrM2MDeviceNameConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MDeviceNameConfig) PassRef() (*C.tstrM2MDeviceNameConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8fb03441 != nil {
		return x.ref8fb03441, nil
	}
	mem8fb03441 := allocM2MDeviceNameConfigMemory(1)
	ref8fb03441 := (*C.tstrM2MDeviceNameConfig)(mem8fb03441)
	allocs8fb03441 := new(cgoAllocMap)
	allocs8fb03441.Add(mem8fb03441)

	var cau8DeviceName_allocs *cgoAllocMap
	ref8fb03441.au8DeviceName, cau8DeviceName_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Au8DeviceName)), cgoAllocsUnknown
	allocs8fb03441.Borrow(cau8DeviceName_allocs)

	x.ref8fb03441 = ref8fb03441
	x.allocs8fb03441 = allocs8fb03441
	return ref8fb03441, allocs8fb03441

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MDeviceNameConfig) PassValue() (C.tstrM2MDeviceNameConfig, *cgoAllocMap) {
	if x.ref8fb03441 != nil {
		return *x.ref8fb03441, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MDeviceNameConfig) Deref() {
	if x.ref8fb03441 == nil {
		return
	}
	x.Au8DeviceName = *(*[48]byte)(unsafe.Pointer(&x.ref8fb03441.au8DeviceName))
}

// allocM2MIPConfigMemory allocates memory for type C.tstrM2MIPConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MIPConfigMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MIPConfigValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MIPConfigValue = unsafe.Sizeof([1]C.tstrM2MIPConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MIPConfig) Ref() *C.tstrM2MIPConfig {
	if x == nil {
		return nil
	}
	return x.ref56257aea
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MIPConfig) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref56257aea)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MIPConfig) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MIPConfig) Free() {
	if x != nil && x.allocs56257aea != nil {
		x.allocs56257aea.(*cgoAllocMap).Free()
		x.ref56257aea = nil
	}
}

// NewM2MIPConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MIPConfigRef(ref unsafe.Pointer) *M2MIPConfig {
	if ref == nil {
		return nil
	}
	obj := new(M2MIPConfig)
	obj.ref56257aea = (*C.tstrM2MIPConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MIPConfig) PassRef() (*C.tstrM2MIPConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref56257aea != nil {
		return x.ref56257aea, nil
	}
	mem56257aea := allocM2MIPConfigMemory(1)
	ref56257aea := (*C.tstrM2MIPConfig)(mem56257aea)
	allocs56257aea := new(cgoAllocMap)
	allocs56257aea.Add(mem56257aea)

	var cu32StaticIP_allocs *cgoAllocMap
	ref56257aea.u32StaticIP, cu32StaticIP_allocs = (C.uint32_t)(x.U32StaticIP), cgoAllocsUnknown
	allocs56257aea.Borrow(cu32StaticIP_allocs)

	var cu32Gateway_allocs *cgoAllocMap
	ref56257aea.u32Gateway, cu32Gateway_allocs = (C.uint32_t)(x.U32Gateway), cgoAllocsUnknown
	allocs56257aea.Borrow(cu32Gateway_allocs)

	var cu32DNS_allocs *cgoAllocMap
	ref56257aea.u32DNS, cu32DNS_allocs = (C.uint32_t)(x.U32DNS), cgoAllocsUnknown
	allocs56257aea.Borrow(cu32DNS_allocs)

	var cu32AlternateDNS_allocs *cgoAllocMap
	ref56257aea.u32AlternateDNS, cu32AlternateDNS_allocs = (C.uint32_t)(x.U32AlternateDNS), cgoAllocsUnknown
	allocs56257aea.Borrow(cu32AlternateDNS_allocs)

	var cu32SubnetMask_allocs *cgoAllocMap
	ref56257aea.u32SubnetMask, cu32SubnetMask_allocs = (C.uint32_t)(x.U32SubnetMask), cgoAllocsUnknown
	allocs56257aea.Borrow(cu32SubnetMask_allocs)

	var cu32DhcpLeaseTime_allocs *cgoAllocMap
	ref56257aea.u32DhcpLeaseTime, cu32DhcpLeaseTime_allocs = (C.uint32_t)(x.U32DhcpLeaseTime), cgoAllocsUnknown
	allocs56257aea.Borrow(cu32DhcpLeaseTime_allocs)

	x.ref56257aea = ref56257aea
	x.allocs56257aea = allocs56257aea
	return ref56257aea, allocs56257aea

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MIPConfig) PassValue() (C.tstrM2MIPConfig, *cgoAllocMap) {
	if x.ref56257aea != nil {
		return *x.ref56257aea, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MIPConfig) Deref() {
	if x.ref56257aea == nil {
		return
	}
	x.U32StaticIP = (uint32)(x.ref56257aea.u32StaticIP)
	x.U32Gateway = (uint32)(x.ref56257aea.u32Gateway)
	x.U32DNS = (uint32)(x.ref56257aea.u32DNS)
	x.U32AlternateDNS = (uint32)(x.ref56257aea.u32AlternateDNS)
	x.U32SubnetMask = (uint32)(x.ref56257aea.u32SubnetMask)
	x.U32DhcpLeaseTime = (uint32)(x.ref56257aea.u32DhcpLeaseTime)
}

// allocM2mIpRsvdPktMemory allocates memory for type C.tstrM2mIpRsvdPkt in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2mIpRsvdPktMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2mIpRsvdPktValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2mIpRsvdPktValue = unsafe.Sizeof([1]C.tstrM2mIpRsvdPkt{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2mIpRsvdPkt) Ref() *C.tstrM2mIpRsvdPkt {
	if x == nil {
		return nil
	}
	return x.refbbe3c573
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2mIpRsvdPkt) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refbbe3c573)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2mIpRsvdPkt) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2mIpRsvdPkt) Free() {
	if x != nil && x.allocsbbe3c573 != nil {
		x.allocsbbe3c573.(*cgoAllocMap).Free()
		x.refbbe3c573 = nil
	}
}

// NewM2mIpRsvdPktRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2mIpRsvdPktRef(ref unsafe.Pointer) *M2mIpRsvdPkt {
	if ref == nil {
		return nil
	}
	obj := new(M2mIpRsvdPkt)
	obj.refbbe3c573 = (*C.tstrM2mIpRsvdPkt)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2mIpRsvdPkt) PassRef() (*C.tstrM2mIpRsvdPkt, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refbbe3c573 != nil {
		return x.refbbe3c573, nil
	}
	membbe3c573 := allocM2mIpRsvdPktMemory(1)
	refbbe3c573 := (*C.tstrM2mIpRsvdPkt)(membbe3c573)
	allocsbbe3c573 := new(cgoAllocMap)
	allocsbbe3c573.Add(membbe3c573)

	var cu16PktSz_allocs *cgoAllocMap
	refbbe3c573.u16PktSz, cu16PktSz_allocs = (C.uint16_t)(x.U16PktSz), cgoAllocsUnknown
	allocsbbe3c573.Borrow(cu16PktSz_allocs)

	var cu16PktOffset_allocs *cgoAllocMap
	refbbe3c573.u16PktOffset, cu16PktOffset_allocs = (C.uint16_t)(x.U16PktOffset), cgoAllocsUnknown
	allocsbbe3c573.Borrow(cu16PktOffset_allocs)

	x.refbbe3c573 = refbbe3c573
	x.allocsbbe3c573 = allocsbbe3c573
	return refbbe3c573, allocsbbe3c573

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2mIpRsvdPkt) PassValue() (C.tstrM2mIpRsvdPkt, *cgoAllocMap) {
	if x.refbbe3c573 != nil {
		return *x.refbbe3c573, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2mIpRsvdPkt) Deref() {
	if x.refbbe3c573 == nil {
		return
	}
	x.U16PktSz = (uint16)(x.refbbe3c573.u16PktSz)
	x.U16PktOffset = (uint16)(x.refbbe3c573.u16PktOffset)
}

// allocM2MProvisionModeConfigMemory allocates memory for type C.tstrM2MProvisionModeConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MProvisionModeConfigMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MProvisionModeConfigValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MProvisionModeConfigValue = unsafe.Sizeof([1]C.tstrM2MProvisionModeConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MProvisionModeConfig) Ref() *C.tstrM2MProvisionModeConfig {
	if x == nil {
		return nil
	}
	return x.ref7bc66fe8
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MProvisionModeConfig) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref7bc66fe8)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MProvisionModeConfig) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MProvisionModeConfig) Free() {
	if x != nil && x.allocs7bc66fe8 != nil {
		x.allocs7bc66fe8.(*cgoAllocMap).Free()
		x.ref7bc66fe8 = nil
	}
}

// NewM2MProvisionModeConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MProvisionModeConfigRef(ref unsafe.Pointer) *M2MProvisionModeConfig {
	if ref == nil {
		return nil
	}
	obj := new(M2MProvisionModeConfig)
	obj.ref7bc66fe8 = (*C.tstrM2MProvisionModeConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MProvisionModeConfig) PassRef() (*C.tstrM2MProvisionModeConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7bc66fe8 != nil {
		return x.ref7bc66fe8, nil
	}
	mem7bc66fe8 := allocM2MProvisionModeConfigMemory(1)
	ref7bc66fe8 := (*C.tstrM2MProvisionModeConfig)(mem7bc66fe8)
	allocs7bc66fe8 := new(cgoAllocMap)
	allocs7bc66fe8.Add(mem7bc66fe8)

	var cstrApConfig_allocs *cgoAllocMap
	ref7bc66fe8.strApConfig, cstrApConfig_allocs = x.StrApConfig.PassValue()
	allocs7bc66fe8.Borrow(cstrApConfig_allocs)

	var cacHttpServerDomainName_allocs *cgoAllocMap
	ref7bc66fe8.acHttpServerDomainName, cacHttpServerDomainName_allocs = *(*[64]C.char)(unsafe.Pointer(&x.AcHttpServerDomainName)), cgoAllocsUnknown
	allocs7bc66fe8.Borrow(cacHttpServerDomainName_allocs)

	var cu8EnableRedirect_allocs *cgoAllocMap
	ref7bc66fe8.u8EnableRedirect, cu8EnableRedirect_allocs = (C.uint8_t)(x.U8EnableRedirect), cgoAllocsUnknown
	allocs7bc66fe8.Borrow(cu8EnableRedirect_allocs)

	var cstrApConfigExt_allocs *cgoAllocMap
	ref7bc66fe8.strApConfigExt, cstrApConfigExt_allocs = x.StrApConfigExt.PassValue()
	allocs7bc66fe8.Borrow(cstrApConfigExt_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref7bc66fe8.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs7bc66fe8.Borrow(c__PAD24___allocs)

	x.ref7bc66fe8 = ref7bc66fe8
	x.allocs7bc66fe8 = allocs7bc66fe8
	return ref7bc66fe8, allocs7bc66fe8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MProvisionModeConfig) PassValue() (C.tstrM2MProvisionModeConfig, *cgoAllocMap) {
	if x.ref7bc66fe8 != nil {
		return *x.ref7bc66fe8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MProvisionModeConfig) Deref() {
	if x.ref7bc66fe8 == nil {
		return
	}
	x.StrApConfig = *NewM2MAPConfigRef(unsafe.Pointer(&x.ref7bc66fe8.strApConfig))
	x.AcHttpServerDomainName = *(*[64]byte)(unsafe.Pointer(&x.ref7bc66fe8.acHttpServerDomainName))
	x.U8EnableRedirect = (byte)(x.ref7bc66fe8.u8EnableRedirect)
	x.StrApConfigExt = *NewM2MAPConfigExtRef(unsafe.Pointer(&x.ref7bc66fe8.strApConfigExt))
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref7bc66fe8.__PAD24__))
}

// allocM2MProvisionInfoMemory allocates memory for type C.tstrM2MProvisionInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MProvisionInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MProvisionInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MProvisionInfoValue = unsafe.Sizeof([1]C.tstrM2MProvisionInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MProvisionInfo) Ref() *C.tstrM2MProvisionInfo {
	if x == nil {
		return nil
	}
	return x.ref32921097
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MProvisionInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref32921097)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MProvisionInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MProvisionInfo) Free() {
	if x != nil && x.allocs32921097 != nil {
		x.allocs32921097.(*cgoAllocMap).Free()
		x.ref32921097 = nil
	}
}

// NewM2MProvisionInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MProvisionInfoRef(ref unsafe.Pointer) *M2MProvisionInfo {
	if ref == nil {
		return nil
	}
	obj := new(M2MProvisionInfo)
	obj.ref32921097 = (*C.tstrM2MProvisionInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MProvisionInfo) PassRef() (*C.tstrM2MProvisionInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref32921097 != nil {
		return x.ref32921097, nil
	}
	mem32921097 := allocM2MProvisionInfoMemory(1)
	ref32921097 := (*C.tstrM2MProvisionInfo)(mem32921097)
	allocs32921097 := new(cgoAllocMap)
	allocs32921097.Add(mem32921097)

	var cau8SSID_allocs *cgoAllocMap
	ref32921097.au8SSID, cau8SSID_allocs = *(*[33]C.uint8_t)(unsafe.Pointer(&x.Au8SSID)), cgoAllocsUnknown
	allocs32921097.Borrow(cau8SSID_allocs)

	var cau8Password_allocs *cgoAllocMap
	ref32921097.au8Password, cau8Password_allocs = *(*[65]C.uint8_t)(unsafe.Pointer(&x.Au8Password)), cgoAllocsUnknown
	allocs32921097.Borrow(cau8Password_allocs)

	var cu8SecType_allocs *cgoAllocMap
	ref32921097.u8SecType, cu8SecType_allocs = (C.uint8_t)(x.U8SecType), cgoAllocsUnknown
	allocs32921097.Borrow(cu8SecType_allocs)

	var cu8Status_allocs *cgoAllocMap
	ref32921097.u8Status, cu8Status_allocs = (C.uint8_t)(x.U8Status), cgoAllocsUnknown
	allocs32921097.Borrow(cu8Status_allocs)

	x.ref32921097 = ref32921097
	x.allocs32921097 = allocs32921097
	return ref32921097, allocs32921097

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MProvisionInfo) PassValue() (C.tstrM2MProvisionInfo, *cgoAllocMap) {
	if x.ref32921097 != nil {
		return *x.ref32921097, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MProvisionInfo) Deref() {
	if x.ref32921097 == nil {
		return
	}
	x.Au8SSID = *(*[33]byte)(unsafe.Pointer(&x.ref32921097.au8SSID))
	x.Au8Password = *(*[65]byte)(unsafe.Pointer(&x.ref32921097.au8Password))
	x.U8SecType = (byte)(x.ref32921097.u8SecType)
	x.U8Status = (byte)(x.ref32921097.u8Status)
}

// allocM2MConnInfoMemory allocates memory for type C.tstrM2MConnInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MConnInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MConnInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MConnInfoValue = unsafe.Sizeof([1]C.tstrM2MConnInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MConnInfo) Ref() *C.tstrM2MConnInfo {
	if x == nil {
		return nil
	}
	return x.refa529de03
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MConnInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refa529de03)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MConnInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MConnInfo) Free() {
	if x != nil && x.allocsa529de03 != nil {
		x.allocsa529de03.(*cgoAllocMap).Free()
		x.refa529de03 = nil
	}
}

// NewM2MConnInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MConnInfoRef(ref unsafe.Pointer) *M2MConnInfo {
	if ref == nil {
		return nil
	}
	obj := new(M2MConnInfo)
	obj.refa529de03 = (*C.tstrM2MConnInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MConnInfo) PassRef() (*C.tstrM2MConnInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa529de03 != nil {
		return x.refa529de03, nil
	}
	mema529de03 := allocM2MConnInfoMemory(1)
	refa529de03 := (*C.tstrM2MConnInfo)(mema529de03)
	allocsa529de03 := new(cgoAllocMap)
	allocsa529de03.Add(mema529de03)

	var cacSSID_allocs *cgoAllocMap
	refa529de03.acSSID, cacSSID_allocs = *(*[33]C.char)(unsafe.Pointer(&x.AcSSID)), cgoAllocsUnknown
	allocsa529de03.Borrow(cacSSID_allocs)

	var cu8SecType_allocs *cgoAllocMap
	refa529de03.u8SecType, cu8SecType_allocs = (C.uint8_t)(x.U8SecType), cgoAllocsUnknown
	allocsa529de03.Borrow(cu8SecType_allocs)

	var cau8IPAddr_allocs *cgoAllocMap
	refa529de03.au8IPAddr, cau8IPAddr_allocs = *(*[4]C.uint8_t)(unsafe.Pointer(&x.Au8IPAddr)), cgoAllocsUnknown
	allocsa529de03.Borrow(cau8IPAddr_allocs)

	var cau8MACAddress_allocs *cgoAllocMap
	refa529de03.au8MACAddress, cau8MACAddress_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8MACAddress)), cgoAllocsUnknown
	allocsa529de03.Borrow(cau8MACAddress_allocs)

	var cs8RSSI_allocs *cgoAllocMap
	refa529de03.s8RSSI, cs8RSSI_allocs = (C.int8_t)(x.S8RSSI), cgoAllocsUnknown
	allocsa529de03.Borrow(cs8RSSI_allocs)

	var cu8CurrChannel_allocs *cgoAllocMap
	refa529de03.u8CurrChannel, cu8CurrChannel_allocs = (C.uint8_t)(x.U8CurrChannel), cgoAllocsUnknown
	allocsa529de03.Borrow(cu8CurrChannel_allocs)

	var c__PAD16___allocs *cgoAllocMap
	refa529de03.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocsa529de03.Borrow(c__PAD16___allocs)

	x.refa529de03 = refa529de03
	x.allocsa529de03 = allocsa529de03
	return refa529de03, allocsa529de03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MConnInfo) PassValue() (C.tstrM2MConnInfo, *cgoAllocMap) {
	if x.refa529de03 != nil {
		return *x.refa529de03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MConnInfo) Deref() {
	if x.refa529de03 == nil {
		return
	}
	x.AcSSID = *(*[33]byte)(unsafe.Pointer(&x.refa529de03.acSSID))
	x.U8SecType = (byte)(x.refa529de03.u8SecType)
	x.Au8IPAddr = *(*[4]byte)(unsafe.Pointer(&x.refa529de03.au8IPAddr))
	x.Au8MACAddress = *(*[6]byte)(unsafe.Pointer(&x.refa529de03.au8MACAddress))
	x.S8RSSI = (int8)(x.refa529de03.s8RSSI)
	x.U8CurrChannel = (byte)(x.refa529de03.u8CurrChannel)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.refa529de03.__PAD16__))
}

// allocM2MP2PConnectMemory allocates memory for type C.tstrM2MP2PConnect in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MP2PConnectMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MP2PConnectValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MP2PConnectValue = unsafe.Sizeof([1]C.tstrM2MP2PConnect{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MP2PConnect) Ref() *C.tstrM2MP2PConnect {
	if x == nil {
		return nil
	}
	return x.ref7a58584c
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MP2PConnect) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref7a58584c)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MP2PConnect) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MP2PConnect) Free() {
	if x != nil && x.allocs7a58584c != nil {
		x.allocs7a58584c.(*cgoAllocMap).Free()
		x.ref7a58584c = nil
	}
}

// NewM2MP2PConnectRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MP2PConnectRef(ref unsafe.Pointer) *M2MP2PConnect {
	if ref == nil {
		return nil
	}
	obj := new(M2MP2PConnect)
	obj.ref7a58584c = (*C.tstrM2MP2PConnect)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MP2PConnect) PassRef() (*C.tstrM2MP2PConnect, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a58584c != nil {
		return x.ref7a58584c, nil
	}
	mem7a58584c := allocM2MP2PConnectMemory(1)
	ref7a58584c := (*C.tstrM2MP2PConnect)(mem7a58584c)
	allocs7a58584c := new(cgoAllocMap)
	allocs7a58584c.Add(mem7a58584c)

	var cu8ListenChannel_allocs *cgoAllocMap
	ref7a58584c.u8ListenChannel, cu8ListenChannel_allocs = (C.uint8_t)(x.U8ListenChannel), cgoAllocsUnknown
	allocs7a58584c.Borrow(cu8ListenChannel_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref7a58584c.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs7a58584c.Borrow(c__PAD24___allocs)

	x.ref7a58584c = ref7a58584c
	x.allocs7a58584c = allocs7a58584c
	return ref7a58584c, allocs7a58584c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MP2PConnect) PassValue() (C.tstrM2MP2PConnect, *cgoAllocMap) {
	if x.ref7a58584c != nil {
		return *x.ref7a58584c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MP2PConnect) Deref() {
	if x.ref7a58584c == nil {
		return
	}
	x.U8ListenChannel = (byte)(x.ref7a58584c.u8ListenChannel)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref7a58584c.__PAD24__))
}

// allocM2MSNTPConfigMemory allocates memory for type C.tstrM2MSNTPConfig in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MSNTPConfigMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MSNTPConfigValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MSNTPConfigValue = unsafe.Sizeof([1]C.tstrM2MSNTPConfig{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MSNTPConfig) Ref() *C.tstrM2MSNTPConfig {
	if x == nil {
		return nil
	}
	return x.ref649da0d7
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MSNTPConfig) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref649da0d7)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MSNTPConfig) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MSNTPConfig) Free() {
	if x != nil && x.allocs649da0d7 != nil {
		x.allocs649da0d7.(*cgoAllocMap).Free()
		x.ref649da0d7 = nil
	}
}

// NewM2MSNTPConfigRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MSNTPConfigRef(ref unsafe.Pointer) *M2MSNTPConfig {
	if ref == nil {
		return nil
	}
	obj := new(M2MSNTPConfig)
	obj.ref649da0d7 = (*C.tstrM2MSNTPConfig)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MSNTPConfig) PassRef() (*C.tstrM2MSNTPConfig, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref649da0d7 != nil {
		return x.ref649da0d7, nil
	}
	mem649da0d7 := allocM2MSNTPConfigMemory(1)
	ref649da0d7 := (*C.tstrM2MSNTPConfig)(mem649da0d7)
	allocs649da0d7 := new(cgoAllocMap)
	allocs649da0d7.Add(mem649da0d7)

	var cacNTPServer_allocs *cgoAllocMap
	ref649da0d7.acNTPServer, cacNTPServer_allocs = *(*[33]C.char)(unsafe.Pointer(&x.AcNTPServer)), cgoAllocsUnknown
	allocs649da0d7.Borrow(cacNTPServer_allocs)

	var cenuUseDHCP_allocs *cgoAllocMap
	ref649da0d7.enuUseDHCP, cenuUseDHCP_allocs = (C.tenuSNTPUseDHCP)(x.EnuUseDHCP), cgoAllocsUnknown
	allocs649da0d7.Borrow(cenuUseDHCP_allocs)

	var c__PAD8___allocs *cgoAllocMap
	ref649da0d7.__PAD8__, c__PAD8___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD8__)), cgoAllocsUnknown
	allocs649da0d7.Borrow(c__PAD8___allocs)

	x.ref649da0d7 = ref649da0d7
	x.allocs649da0d7 = allocs649da0d7
	return ref649da0d7, allocs649da0d7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MSNTPConfig) PassValue() (C.tstrM2MSNTPConfig, *cgoAllocMap) {
	if x.ref649da0d7 != nil {
		return *x.ref649da0d7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MSNTPConfig) Deref() {
	if x.ref649da0d7 == nil {
		return
	}
	x.AcNTPServer = *(*[33]byte)(unsafe.Pointer(&x.ref649da0d7.acNTPServer))
	x.EnuUseDHCP = (EnumSNTPUseDHCP)(x.ref649da0d7.enuUseDHCP)
	x.__PAD8__ = *(*[2]byte)(unsafe.Pointer(&x.ref649da0d7.__PAD8__))
}

// allocSystemTimeMemory allocates memory for type C.tstrSystemTime in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSystemTimeMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSystemTimeValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSystemTimeValue = unsafe.Sizeof([1]C.tstrSystemTime{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SystemTime) Ref() *C.tstrSystemTime {
	if x == nil {
		return nil
	}
	return x.ref47e6eb96
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SystemTime) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref47e6eb96)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SystemTime) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SystemTime) Free() {
	if x != nil && x.allocs47e6eb96 != nil {
		x.allocs47e6eb96.(*cgoAllocMap).Free()
		x.ref47e6eb96 = nil
	}
}

// NewSystemTimeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSystemTimeRef(ref unsafe.Pointer) *SystemTime {
	if ref == nil {
		return nil
	}
	obj := new(SystemTime)
	obj.ref47e6eb96 = (*C.tstrSystemTime)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SystemTime) PassRef() (*C.tstrSystemTime, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref47e6eb96 != nil {
		return x.ref47e6eb96, nil
	}
	mem47e6eb96 := allocSystemTimeMemory(1)
	ref47e6eb96 := (*C.tstrSystemTime)(mem47e6eb96)
	allocs47e6eb96 := new(cgoAllocMap)
	allocs47e6eb96.Add(mem47e6eb96)

	var cu16Year_allocs *cgoAllocMap
	ref47e6eb96.u16Year, cu16Year_allocs = (C.uint16_t)(x.U16Year), cgoAllocsUnknown
	allocs47e6eb96.Borrow(cu16Year_allocs)

	var cu8Month_allocs *cgoAllocMap
	ref47e6eb96.u8Month, cu8Month_allocs = (C.uint8_t)(x.U8Month), cgoAllocsUnknown
	allocs47e6eb96.Borrow(cu8Month_allocs)

	var cu8Day_allocs *cgoAllocMap
	ref47e6eb96.u8Day, cu8Day_allocs = (C.uint8_t)(x.U8Day), cgoAllocsUnknown
	allocs47e6eb96.Borrow(cu8Day_allocs)

	var cu8Hour_allocs *cgoAllocMap
	ref47e6eb96.u8Hour, cu8Hour_allocs = (C.uint8_t)(x.U8Hour), cgoAllocsUnknown
	allocs47e6eb96.Borrow(cu8Hour_allocs)

	var cu8Minute_allocs *cgoAllocMap
	ref47e6eb96.u8Minute, cu8Minute_allocs = (C.uint8_t)(x.U8Minute), cgoAllocsUnknown
	allocs47e6eb96.Borrow(cu8Minute_allocs)

	var cu8Second_allocs *cgoAllocMap
	ref47e6eb96.u8Second, cu8Second_allocs = (C.uint8_t)(x.U8Second), cgoAllocsUnknown
	allocs47e6eb96.Borrow(cu8Second_allocs)

	var c__PAD8___allocs *cgoAllocMap
	ref47e6eb96.__PAD8__, c__PAD8___allocs = (C.uint8_t)(x.__PAD8__), cgoAllocsUnknown
	allocs47e6eb96.Borrow(c__PAD8___allocs)

	x.ref47e6eb96 = ref47e6eb96
	x.allocs47e6eb96 = allocs47e6eb96
	return ref47e6eb96, allocs47e6eb96

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SystemTime) PassValue() (C.tstrSystemTime, *cgoAllocMap) {
	if x.ref47e6eb96 != nil {
		return *x.ref47e6eb96, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SystemTime) Deref() {
	if x.ref47e6eb96 == nil {
		return
	}
	x.U16Year = (uint16)(x.ref47e6eb96.u16Year)
	x.U8Month = (byte)(x.ref47e6eb96.u8Month)
	x.U8Day = (byte)(x.ref47e6eb96.u8Day)
	x.U8Hour = (byte)(x.ref47e6eb96.u8Hour)
	x.U8Minute = (byte)(x.ref47e6eb96.u8Minute)
	x.U8Second = (byte)(x.ref47e6eb96.u8Second)
	x.__PAD8__ = (byte)(x.ref47e6eb96.__PAD8__)
}

// allocM2MMulticastMacMemory allocates memory for type C.tstrM2MMulticastMac in C.
// The caller is responsible for freeing the this memory via C.free.
func allocM2MMulticastMacMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfM2MMulticastMacValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfM2MMulticastMacValue = unsafe.Sizeof([1]C.tstrM2MMulticastMac{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *M2MMulticastMac) Ref() *C.tstrM2MMulticastMac {
	if x == nil {
		return nil
	}
	return x.refda99fd36
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *M2MMulticastMac) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refda99fd36)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *M2MMulticastMac) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *M2MMulticastMac) Free() {
	if x != nil && x.allocsda99fd36 != nil {
		x.allocsda99fd36.(*cgoAllocMap).Free()
		x.refda99fd36 = nil
	}
}

// NewM2MMulticastMacRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewM2MMulticastMacRef(ref unsafe.Pointer) *M2MMulticastMac {
	if ref == nil {
		return nil
	}
	obj := new(M2MMulticastMac)
	obj.refda99fd36 = (*C.tstrM2MMulticastMac)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *M2MMulticastMac) PassRef() (*C.tstrM2MMulticastMac, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refda99fd36 != nil {
		return x.refda99fd36, nil
	}
	memda99fd36 := allocM2MMulticastMacMemory(1)
	refda99fd36 := (*C.tstrM2MMulticastMac)(memda99fd36)
	allocsda99fd36 := new(cgoAllocMap)
	allocsda99fd36.Add(memda99fd36)

	var cau8macaddress_allocs *cgoAllocMap
	refda99fd36.au8macaddress, cau8macaddress_allocs = *(*[6]C.uint8_t)(unsafe.Pointer(&x.Au8macaddress)), cgoAllocsUnknown
	allocsda99fd36.Borrow(cau8macaddress_allocs)

	var cu8AddRemove_allocs *cgoAllocMap
	refda99fd36.u8AddRemove, cu8AddRemove_allocs = (C.uint8_t)(x.U8AddRemove), cgoAllocsUnknown
	allocsda99fd36.Borrow(cu8AddRemove_allocs)

	var c__PAD8___allocs *cgoAllocMap
	refda99fd36.__PAD8__, c__PAD8___allocs = (C.uint8_t)(x.__PAD8__), cgoAllocsUnknown
	allocsda99fd36.Borrow(c__PAD8___allocs)

	x.refda99fd36 = refda99fd36
	x.allocsda99fd36 = allocsda99fd36
	return refda99fd36, allocsda99fd36

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x M2MMulticastMac) PassValue() (C.tstrM2MMulticastMac, *cgoAllocMap) {
	if x.refda99fd36 != nil {
		return *x.refda99fd36, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *M2MMulticastMac) Deref() {
	if x.refda99fd36 == nil {
		return
	}
	x.Au8macaddress = *(*[6]byte)(unsafe.Pointer(&x.refda99fd36.au8macaddress))
	x.U8AddRemove = (byte)(x.refda99fd36.u8AddRemove)
	x.__PAD8__ = (byte)(x.refda99fd36.__PAD8__)
}

// allocPrngMemory allocates memory for type C.tstrPrng in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPrngMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfPrngValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfPrngValue = unsafe.Sizeof([1]C.tstrPrng{})

// copyPUint8_tBytes copies the data from Go slice as *C.uint8_t.
func copyPUint8_tBytes(slice *sliceHeader) (*C.uint8_t, *cgoAllocMap) {
	allocs := new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := unsafe.Pointer(C.CBytes(*(*[]byte)(unsafe.Pointer(&sliceHeader{
		Data: slice.Data,
		Len:  int(sizeOfUint8_tValue) * slice.Len,
		Cap:  int(sizeOfUint8_tValue) * slice.Len,
	}))))
	allocs.Add(mem0)

	return (*C.uint8_t)(mem0), allocs
}

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocUint8_tMemory allocates memory for type C.uint8_t in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUint8_tMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfUint8_tValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfUint8_tValue = unsafe.Sizeof([1]C.uint8_t{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Prng) Ref() *C.tstrPrng {
	if x == nil {
		return nil
	}
	return x.ref37c97783
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *Prng) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref37c97783)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *Prng) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Prng) Free() {
	if x != nil && x.allocs37c97783 != nil {
		x.allocs37c97783.(*cgoAllocMap).Free()
		x.ref37c97783 = nil
	}
}

// NewPrngRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPrngRef(ref unsafe.Pointer) *Prng {
	if ref == nil {
		return nil
	}
	obj := new(Prng)
	obj.ref37c97783 = (*C.tstrPrng)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Prng) PassRef() (*C.tstrPrng, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref37c97783 != nil {
		return x.ref37c97783, nil
	}
	mem37c97783 := allocPrngMemory(1)
	ref37c97783 := (*C.tstrPrng)(mem37c97783)
	allocs37c97783 := new(cgoAllocMap)
	allocs37c97783.Add(mem37c97783)

	var cpu8RngBuff_allocs *cgoAllocMap
	ref37c97783.pu8RngBuff, cpu8RngBuff_allocs = copyPUint8_tBytes((*sliceHeader)(unsafe.Pointer(&x.Pu8RngBuff)))
	allocs37c97783.Borrow(cpu8RngBuff_allocs)

	var cu16PrngSize_allocs *cgoAllocMap
	ref37c97783.u16PrngSize, cu16PrngSize_allocs = (C.uint16_t)(x.U16PrngSize), cgoAllocsUnknown
	allocs37c97783.Borrow(cu16PrngSize_allocs)

	var c__PAD16___allocs *cgoAllocMap
	ref37c97783.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocs37c97783.Borrow(c__PAD16___allocs)

	x.ref37c97783 = ref37c97783
	x.allocs37c97783 = allocs37c97783
	return ref37c97783, allocs37c97783

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Prng) PassValue() (C.tstrPrng, *cgoAllocMap) {
	if x.ref37c97783 != nil {
		return *x.ref37c97783, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Prng) Deref() {
	if x.ref37c97783 == nil {
		return
	}
	hxfc4425b := (*sliceHeader)(unsafe.Pointer(&x.Pu8RngBuff))
	hxfc4425b.Data = unsafe.Pointer(x.ref37c97783.pu8RngBuff)
	hxfc4425b.Cap = 0x7fffffff
	// hxfc4425b.Len = ?

	x.U16PrngSize = (uint16)(x.ref37c97783.u16PrngSize)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.ref37c97783.__PAD16__))
}

// allocConfAutoRateMemory allocates memory for type C.tstrConfAutoRate in C.
// The caller is responsible for freeing the this memory via C.free.
func allocConfAutoRateMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfConfAutoRateValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfConfAutoRateValue = unsafe.Sizeof([1]C.tstrConfAutoRate{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ConfAutoRate) Ref() *C.tstrConfAutoRate {
	if x == nil {
		return nil
	}
	return x.ref330ce733
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ConfAutoRate) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref330ce733)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ConfAutoRate) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ConfAutoRate) Free() {
	if x != nil && x.allocs330ce733 != nil {
		x.allocs330ce733.(*cgoAllocMap).Free()
		x.ref330ce733 = nil
	}
}

// NewConfAutoRateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewConfAutoRateRef(ref unsafe.Pointer) *ConfAutoRate {
	if ref == nil {
		return nil
	}
	obj := new(ConfAutoRate)
	obj.ref330ce733 = (*C.tstrConfAutoRate)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ConfAutoRate) PassRef() (*C.tstrConfAutoRate, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref330ce733 != nil {
		return x.ref330ce733, nil
	}
	mem330ce733 := allocConfAutoRateMemory(1)
	ref330ce733 := (*C.tstrConfAutoRate)(mem330ce733)
	allocs330ce733 := new(cgoAllocMap)
	allocs330ce733.Add(mem330ce733)

	var cu16ArMaxRecoveryFailThreshold_allocs *cgoAllocMap
	ref330ce733.u16ArMaxRecoveryFailThreshold, cu16ArMaxRecoveryFailThreshold_allocs = (C.uint16_t)(x.U16ArMaxRecoveryFailThreshold), cgoAllocsUnknown
	allocs330ce733.Borrow(cu16ArMaxRecoveryFailThreshold_allocs)

	var cu16ArMinRecoveryFailThreshold_allocs *cgoAllocMap
	ref330ce733.u16ArMinRecoveryFailThreshold, cu16ArMinRecoveryFailThreshold_allocs = (C.uint16_t)(x.U16ArMinRecoveryFailThreshold), cgoAllocsUnknown
	allocs330ce733.Borrow(cu16ArMinRecoveryFailThreshold_allocs)

	var cenuWlanTxRate_allocs *cgoAllocMap
	ref330ce733.enuWlanTxRate, cenuWlanTxRate_allocs = (C.tenuWlanTxRate)(x.EnuWlanTxRate), cgoAllocsUnknown
	allocs330ce733.Borrow(cenuWlanTxRate_allocs)

	var cenuArInitialRateSel_allocs *cgoAllocMap
	ref330ce733.enuArInitialRateSel, cenuArInitialRateSel_allocs = (C.tenuWlanTxRate)(x.EnuArInitialRateSel), cgoAllocsUnknown
	allocs330ce733.Borrow(cenuArInitialRateSel_allocs)

	var cu8ArEnoughTxThreshold_allocs *cgoAllocMap
	ref330ce733.u8ArEnoughTxThreshold, cu8ArEnoughTxThreshold_allocs = (C.uint8_t)(x.U8ArEnoughTxThreshold), cgoAllocsUnknown
	allocs330ce733.Borrow(cu8ArEnoughTxThreshold_allocs)

	var cu8ArSuccessTXThreshold_allocs *cgoAllocMap
	ref330ce733.u8ArSuccessTXThreshold, cu8ArSuccessTXThreshold_allocs = (C.uint8_t)(x.U8ArSuccessTXThreshold), cgoAllocsUnknown
	allocs330ce733.Borrow(cu8ArSuccessTXThreshold_allocs)

	var cu8ArFailTxThreshold_allocs *cgoAllocMap
	ref330ce733.u8ArFailTxThreshold, cu8ArFailTxThreshold_allocs = (C.uint8_t)(x.U8ArFailTxThreshold), cgoAllocsUnknown
	allocs330ce733.Borrow(cu8ArFailTxThreshold_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref330ce733.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs330ce733.Borrow(c__PAD24___allocs)

	x.ref330ce733 = ref330ce733
	x.allocs330ce733 = allocs330ce733
	return ref330ce733, allocs330ce733

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ConfAutoRate) PassValue() (C.tstrConfAutoRate, *cgoAllocMap) {
	if x.ref330ce733 != nil {
		return *x.ref330ce733, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ConfAutoRate) Deref() {
	if x.ref330ce733 == nil {
		return
	}
	x.U16ArMaxRecoveryFailThreshold = (uint16)(x.ref330ce733.u16ArMaxRecoveryFailThreshold)
	x.U16ArMinRecoveryFailThreshold = (uint16)(x.ref330ce733.u16ArMinRecoveryFailThreshold)
	x.EnuWlanTxRate = (EnumWlanTxRate)(x.ref330ce733.enuWlanTxRate)
	x.EnuArInitialRateSel = (EnumWlanTxRate)(x.ref330ce733.enuArInitialRateSel)
	x.U8ArEnoughTxThreshold = (byte)(x.ref330ce733.u8ArEnoughTxThreshold)
	x.U8ArSuccessTXThreshold = (byte)(x.ref330ce733.u8ArSuccessTXThreshold)
	x.U8ArFailTxThreshold = (byte)(x.ref330ce733.u8ArFailTxThreshold)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref330ce733.__PAD24__))
}

// allocTlsCrlEntryMemory allocates memory for type C.tstrTlsCrlEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTlsCrlEntryMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfTlsCrlEntryValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfTlsCrlEntryValue = unsafe.Sizeof([1]C.tstrTlsCrlEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TlsCrlEntry) Ref() *C.tstrTlsCrlEntry {
	if x == nil {
		return nil
	}
	return x.ref3a4218c3
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *TlsCrlEntry) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref3a4218c3)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *TlsCrlEntry) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TlsCrlEntry) Free() {
	if x != nil && x.allocs3a4218c3 != nil {
		x.allocs3a4218c3.(*cgoAllocMap).Free()
		x.ref3a4218c3 = nil
	}
}

// NewTlsCrlEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTlsCrlEntryRef(ref unsafe.Pointer) *TlsCrlEntry {
	if ref == nil {
		return nil
	}
	obj := new(TlsCrlEntry)
	obj.ref3a4218c3 = (*C.tstrTlsCrlEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TlsCrlEntry) PassRef() (*C.tstrTlsCrlEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a4218c3 != nil {
		return x.ref3a4218c3, nil
	}
	mem3a4218c3 := allocTlsCrlEntryMemory(1)
	ref3a4218c3 := (*C.tstrTlsCrlEntry)(mem3a4218c3)
	allocs3a4218c3 := new(cgoAllocMap)
	allocs3a4218c3.Add(mem3a4218c3)

	var cu8DataLen_allocs *cgoAllocMap
	ref3a4218c3.u8DataLen, cu8DataLen_allocs = (C.uint8_t)(x.U8DataLen), cgoAllocsUnknown
	allocs3a4218c3.Borrow(cu8DataLen_allocs)

	var cau8Data_allocs *cgoAllocMap
	ref3a4218c3.au8Data, cau8Data_allocs = *(*[64]C.uint8_t)(unsafe.Pointer(&x.Au8Data)), cgoAllocsUnknown
	allocs3a4218c3.Borrow(cau8Data_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref3a4218c3.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs3a4218c3.Borrow(c__PAD24___allocs)

	x.ref3a4218c3 = ref3a4218c3
	x.allocs3a4218c3 = allocs3a4218c3
	return ref3a4218c3, allocs3a4218c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TlsCrlEntry) PassValue() (C.tstrTlsCrlEntry, *cgoAllocMap) {
	if x.ref3a4218c3 != nil {
		return *x.ref3a4218c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TlsCrlEntry) Deref() {
	if x.ref3a4218c3 == nil {
		return
	}
	x.U8DataLen = (byte)(x.ref3a4218c3.u8DataLen)
	x.Au8Data = *(*[64]byte)(unsafe.Pointer(&x.ref3a4218c3.au8Data))
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref3a4218c3.__PAD24__))
}

// allocTlsCrlInfoMemory allocates memory for type C.tstrTlsCrlInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTlsCrlInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfTlsCrlInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfTlsCrlInfoValue = unsafe.Sizeof([1]C.tstrTlsCrlInfo{})

// allocA10TlsCrlEntryMemory allocates memory for type [10]C.tstrTlsCrlEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA10TlsCrlEntryMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfA10TlsCrlEntryValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfA10TlsCrlEntryValue = unsafe.Sizeof([1][10]C.tstrTlsCrlEntry{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA10TlsCrlEntry transforms a sliced Go data structure into plain C format.
func unpackA10TlsCrlEntry(x [10]TlsCrlEntry) (unpacked [10]C.tstrTlsCrlEntry, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA10TlsCrlEntryMemory(1)
	allocs.Add(mem0)
	v0 := (*[10]C.tstrTlsCrlEntry)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[10]C.tstrTlsCrlEntry)(mem0)
	return
}

// packA10TlsCrlEntry reads sliced Go data structure out from plain C format.
func packA10TlsCrlEntry(v *[10]TlsCrlEntry, ptr0 *[10]C.tstrTlsCrlEntry) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTlsCrlEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TlsCrlInfo) Ref() *C.tstrTlsCrlInfo {
	if x == nil {
		return nil
	}
	return x.refa907de8c
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *TlsCrlInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refa907de8c)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *TlsCrlInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TlsCrlInfo) Free() {
	if x != nil && x.allocsa907de8c != nil {
		x.allocsa907de8c.(*cgoAllocMap).Free()
		x.refa907de8c = nil
	}
}

// NewTlsCrlInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTlsCrlInfoRef(ref unsafe.Pointer) *TlsCrlInfo {
	if ref == nil {
		return nil
	}
	obj := new(TlsCrlInfo)
	obj.refa907de8c = (*C.tstrTlsCrlInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TlsCrlInfo) PassRef() (*C.tstrTlsCrlInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa907de8c != nil {
		return x.refa907de8c, nil
	}
	mema907de8c := allocTlsCrlInfoMemory(1)
	refa907de8c := (*C.tstrTlsCrlInfo)(mema907de8c)
	allocsa907de8c := new(cgoAllocMap)
	allocsa907de8c.Add(mema907de8c)

	var cu8CrlType_allocs *cgoAllocMap
	refa907de8c.u8CrlType, cu8CrlType_allocs = (C.uint8_t)(x.U8CrlType), cgoAllocsUnknown
	allocsa907de8c.Borrow(cu8CrlType_allocs)

	var cu8Rsv1_allocs *cgoAllocMap
	refa907de8c.u8Rsv1, cu8Rsv1_allocs = (C.uint8_t)(x.U8Rsv1), cgoAllocsUnknown
	allocsa907de8c.Borrow(cu8Rsv1_allocs)

	var cu8Rsv2_allocs *cgoAllocMap
	refa907de8c.u8Rsv2, cu8Rsv2_allocs = (C.uint8_t)(x.U8Rsv2), cgoAllocsUnknown
	allocsa907de8c.Borrow(cu8Rsv2_allocs)

	var cu8Rsv3_allocs *cgoAllocMap
	refa907de8c.u8Rsv3, cu8Rsv3_allocs = (C.uint8_t)(x.U8Rsv3), cgoAllocsUnknown
	allocsa907de8c.Borrow(cu8Rsv3_allocs)

	var castrTlsCrl_allocs *cgoAllocMap
	refa907de8c.astrTlsCrl, castrTlsCrl_allocs = unpackA10TlsCrlEntry(x.AstrTlsCrl)
	allocsa907de8c.Borrow(castrTlsCrl_allocs)

	x.refa907de8c = refa907de8c
	x.allocsa907de8c = allocsa907de8c
	return refa907de8c, allocsa907de8c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TlsCrlInfo) PassValue() (C.tstrTlsCrlInfo, *cgoAllocMap) {
	if x.refa907de8c != nil {
		return *x.refa907de8c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TlsCrlInfo) Deref() {
	if x.refa907de8c == nil {
		return
	}
	x.U8CrlType = (byte)(x.refa907de8c.u8CrlType)
	x.U8Rsv1 = (byte)(x.refa907de8c.u8Rsv1)
	x.U8Rsv2 = (byte)(x.refa907de8c.u8Rsv2)
	x.U8Rsv3 = (byte)(x.refa907de8c.u8Rsv3)
	packA10TlsCrlEntry(&x.AstrTlsCrl, (*[10]C.tstrTlsCrlEntry)(unsafe.Pointer(&x.refa907de8c.astrTlsCrl)))
}

// allocTlsSrvSecFileEntryMemory allocates memory for type C.tstrTlsSrvSecFileEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTlsSrvSecFileEntryMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfTlsSrvSecFileEntryValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfTlsSrvSecFileEntryValue = unsafe.Sizeof([1]C.tstrTlsSrvSecFileEntry{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TlsSrvSecFileEntry) Ref() *C.tstrTlsSrvSecFileEntry {
	if x == nil {
		return nil
	}
	return x.refca7e9eec
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *TlsSrvSecFileEntry) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refca7e9eec)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *TlsSrvSecFileEntry) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TlsSrvSecFileEntry) Free() {
	if x != nil && x.allocsca7e9eec != nil {
		x.allocsca7e9eec.(*cgoAllocMap).Free()
		x.refca7e9eec = nil
	}
}

// NewTlsSrvSecFileEntryRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTlsSrvSecFileEntryRef(ref unsafe.Pointer) *TlsSrvSecFileEntry {
	if ref == nil {
		return nil
	}
	obj := new(TlsSrvSecFileEntry)
	obj.refca7e9eec = (*C.tstrTlsSrvSecFileEntry)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TlsSrvSecFileEntry) PassRef() (*C.tstrTlsSrvSecFileEntry, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refca7e9eec != nil {
		return x.refca7e9eec, nil
	}
	memca7e9eec := allocTlsSrvSecFileEntryMemory(1)
	refca7e9eec := (*C.tstrTlsSrvSecFileEntry)(memca7e9eec)
	allocsca7e9eec := new(cgoAllocMap)
	allocsca7e9eec.Add(memca7e9eec)

	var cacFileName_allocs *cgoAllocMap
	refca7e9eec.acFileName, cacFileName_allocs = *(*[48]C.char)(unsafe.Pointer(&x.AcFileName)), cgoAllocsUnknown
	allocsca7e9eec.Borrow(cacFileName_allocs)

	var cu32FileSize_allocs *cgoAllocMap
	refca7e9eec.u32FileSize, cu32FileSize_allocs = (C.uint32_t)(x.U32FileSize), cgoAllocsUnknown
	allocsca7e9eec.Borrow(cu32FileSize_allocs)

	var cu32FileAddr_allocs *cgoAllocMap
	refca7e9eec.u32FileAddr, cu32FileAddr_allocs = (C.uint32_t)(x.U32FileAddr), cgoAllocsUnknown
	allocsca7e9eec.Borrow(cu32FileAddr_allocs)

	x.refca7e9eec = refca7e9eec
	x.allocsca7e9eec = allocsca7e9eec
	return refca7e9eec, allocsca7e9eec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TlsSrvSecFileEntry) PassValue() (C.tstrTlsSrvSecFileEntry, *cgoAllocMap) {
	if x.refca7e9eec != nil {
		return *x.refca7e9eec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TlsSrvSecFileEntry) Deref() {
	if x.refca7e9eec == nil {
		return
	}
	x.AcFileName = *(*[48]byte)(unsafe.Pointer(&x.refca7e9eec.acFileName))
	x.U32FileSize = (uint32)(x.refca7e9eec.u32FileSize)
	x.U32FileAddr = (uint32)(x.refca7e9eec.u32FileAddr)
}

// allocTlsSrvSecHdrMemory allocates memory for type C.tstrTlsSrvSecHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTlsSrvSecHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfTlsSrvSecHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfTlsSrvSecHdrValue = unsafe.Sizeof([1]C.tstrTlsSrvSecHdr{})

// allocA8TlsSrvSecFileEntryMemory allocates memory for type [8]C.tstrTlsSrvSecFileEntry in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA8TlsSrvSecFileEntryMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfA8TlsSrvSecFileEntryValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfA8TlsSrvSecFileEntryValue = unsafe.Sizeof([1][8]C.tstrTlsSrvSecFileEntry{})

// unpackA8TlsSrvSecFileEntry transforms a sliced Go data structure into plain C format.
func unpackA8TlsSrvSecFileEntry(x [8]TlsSrvSecFileEntry) (unpacked [8]C.tstrTlsSrvSecFileEntry, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(allocs, func(a *cgoAllocMap) {
		go a.Free()
	})

	mem0 := allocA8TlsSrvSecFileEntryMemory(1)
	allocs.Add(mem0)
	v0 := (*[8]C.tstrTlsSrvSecFileEntry)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[8]C.tstrTlsSrvSecFileEntry)(mem0)
	return
}

// packA8TlsSrvSecFileEntry reads sliced Go data structure out from plain C format.
func packA8TlsSrvSecFileEntry(v *[8]TlsSrvSecFileEntry, ptr0 *[8]C.tstrTlsSrvSecFileEntry) {
	for i0 := range v {
		ptr1 := ptr0[i0]
		v[i0] = *NewTlsSrvSecFileEntryRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TlsSrvSecHdr) Ref() *C.tstrTlsSrvSecHdr {
	if x == nil {
		return nil
	}
	return x.refb8311c95
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *TlsSrvSecHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refb8311c95)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *TlsSrvSecHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TlsSrvSecHdr) Free() {
	if x != nil && x.allocsb8311c95 != nil {
		x.allocsb8311c95.(*cgoAllocMap).Free()
		x.refb8311c95 = nil
	}
}

// NewTlsSrvSecHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTlsSrvSecHdrRef(ref unsafe.Pointer) *TlsSrvSecHdr {
	if ref == nil {
		return nil
	}
	obj := new(TlsSrvSecHdr)
	obj.refb8311c95 = (*C.tstrTlsSrvSecHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TlsSrvSecHdr) PassRef() (*C.tstrTlsSrvSecHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8311c95 != nil {
		return x.refb8311c95, nil
	}
	memb8311c95 := allocTlsSrvSecHdrMemory(1)
	refb8311c95 := (*C.tstrTlsSrvSecHdr)(memb8311c95)
	allocsb8311c95 := new(cgoAllocMap)
	allocsb8311c95.Add(memb8311c95)

	var cau8SecStartPattern_allocs *cgoAllocMap
	refb8311c95.au8SecStartPattern, cau8SecStartPattern_allocs = *(*[8]C.uint8_t)(unsafe.Pointer(&x.Au8SecStartPattern)), cgoAllocsUnknown
	allocsb8311c95.Borrow(cau8SecStartPattern_allocs)

	var cu32nEntries_allocs *cgoAllocMap
	refb8311c95.u32nEntries, cu32nEntries_allocs = (C.uint32_t)(x.U32nEntries), cgoAllocsUnknown
	allocsb8311c95.Borrow(cu32nEntries_allocs)

	var cu32NextWriteAddr_allocs *cgoAllocMap
	refb8311c95.u32NextWriteAddr, cu32NextWriteAddr_allocs = (C.uint32_t)(x.U32NextWriteAddr), cgoAllocsUnknown
	allocsb8311c95.Borrow(cu32NextWriteAddr_allocs)

	var castrEntries_allocs *cgoAllocMap
	refb8311c95.astrEntries, castrEntries_allocs = unpackA8TlsSrvSecFileEntry(x.AstrEntries)
	allocsb8311c95.Borrow(castrEntries_allocs)

	var cu32CRC_allocs *cgoAllocMap
	refb8311c95.u32CRC, cu32CRC_allocs = (C.uint32_t)(x.U32CRC), cgoAllocsUnknown
	allocsb8311c95.Borrow(cu32CRC_allocs)

	x.refb8311c95 = refb8311c95
	x.allocsb8311c95 = allocsb8311c95
	return refb8311c95, allocsb8311c95

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TlsSrvSecHdr) PassValue() (C.tstrTlsSrvSecHdr, *cgoAllocMap) {
	if x.refb8311c95 != nil {
		return *x.refb8311c95, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TlsSrvSecHdr) Deref() {
	if x.refb8311c95 == nil {
		return
	}
	x.Au8SecStartPattern = *(*[8]byte)(unsafe.Pointer(&x.refb8311c95.au8SecStartPattern))
	x.U32nEntries = (uint32)(x.refb8311c95.u32nEntries)
	x.U32NextWriteAddr = (uint32)(x.refb8311c95.u32NextWriteAddr)
	packA8TlsSrvSecFileEntry(&x.AstrEntries, (*[8]C.tstrTlsSrvSecFileEntry)(unsafe.Pointer(&x.refb8311c95.astrEntries)))
	x.U32CRC = (uint32)(x.refb8311c95.u32CRC)
}

// allocTlsSrvChunkHdrMemory allocates memory for type C.tstrTlsSrvChunkHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTlsSrvChunkHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfTlsSrvChunkHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfTlsSrvChunkHdrValue = unsafe.Sizeof([1]C.tstrTlsSrvChunkHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TlsSrvChunkHdr) Ref() *C.tstrTlsSrvChunkHdr {
	if x == nil {
		return nil
	}
	return x.ref11892db4
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *TlsSrvChunkHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref11892db4)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *TlsSrvChunkHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TlsSrvChunkHdr) Free() {
	if x != nil && x.allocs11892db4 != nil {
		x.allocs11892db4.(*cgoAllocMap).Free()
		x.ref11892db4 = nil
	}
}

// NewTlsSrvChunkHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTlsSrvChunkHdrRef(ref unsafe.Pointer) *TlsSrvChunkHdr {
	if ref == nil {
		return nil
	}
	obj := new(TlsSrvChunkHdr)
	obj.ref11892db4 = (*C.tstrTlsSrvChunkHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TlsSrvChunkHdr) PassRef() (*C.tstrTlsSrvChunkHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref11892db4 != nil {
		return x.ref11892db4, nil
	}
	mem11892db4 := allocTlsSrvChunkHdrMemory(1)
	ref11892db4 := (*C.tstrTlsSrvChunkHdr)(mem11892db4)
	allocs11892db4 := new(cgoAllocMap)
	allocs11892db4.Add(mem11892db4)

	var cu16Sig_allocs *cgoAllocMap
	ref11892db4.u16Sig, cu16Sig_allocs = (C.uint16_t)(x.U16Sig), cgoAllocsUnknown
	allocs11892db4.Borrow(cu16Sig_allocs)

	var cu16TotalSize32_allocs *cgoAllocMap
	ref11892db4.u16TotalSize32, cu16TotalSize32_allocs = (C.uint16_t)(x.U16TotalSize32), cgoAllocsUnknown
	allocs11892db4.Borrow(cu16TotalSize32_allocs)

	var cu16Offset32_allocs *cgoAllocMap
	ref11892db4.u16Offset32, cu16Offset32_allocs = (C.uint16_t)(x.U16Offset32), cgoAllocsUnknown
	allocs11892db4.Borrow(cu16Offset32_allocs)

	var cu16Size32_allocs *cgoAllocMap
	ref11892db4.u16Size32, cu16Size32_allocs = (C.uint16_t)(x.U16Size32), cgoAllocsUnknown
	allocs11892db4.Borrow(cu16Size32_allocs)

	x.ref11892db4 = ref11892db4
	x.allocs11892db4 = allocs11892db4
	return ref11892db4, allocs11892db4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TlsSrvChunkHdr) PassValue() (C.tstrTlsSrvChunkHdr, *cgoAllocMap) {
	if x.ref11892db4 != nil {
		return *x.ref11892db4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *TlsSrvChunkHdr) Deref() {
	if x.ref11892db4 == nil {
		return
	}
	x.U16Sig = (uint16)(x.ref11892db4.u16Sig)
	x.U16TotalSize32 = (uint16)(x.ref11892db4.u16TotalSize32)
	x.U16Offset32 = (uint16)(x.ref11892db4.u16Offset32)
	x.U16Size32 = (uint16)(x.ref11892db4.u16Size32)
}

// allocSslSetActiveCsListMemory allocates memory for type C.tstrSslSetActiveCsList in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSslSetActiveCsListMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSslSetActiveCsListValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSslSetActiveCsListValue = unsafe.Sizeof([1]C.tstrSslSetActiveCsList{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SslSetActiveCsList) Ref() *C.tstrSslSetActiveCsList {
	if x == nil {
		return nil
	}
	return x.refd739fd93
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SslSetActiveCsList) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refd739fd93)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SslSetActiveCsList) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SslSetActiveCsList) Free() {
	if x != nil && x.allocsd739fd93 != nil {
		x.allocsd739fd93.(*cgoAllocMap).Free()
		x.refd739fd93 = nil
	}
}

// NewSslSetActiveCsListRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSslSetActiveCsListRef(ref unsafe.Pointer) *SslSetActiveCsList {
	if ref == nil {
		return nil
	}
	obj := new(SslSetActiveCsList)
	obj.refd739fd93 = (*C.tstrSslSetActiveCsList)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SslSetActiveCsList) PassRef() (*C.tstrSslSetActiveCsList, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd739fd93 != nil {
		return x.refd739fd93, nil
	}
	memd739fd93 := allocSslSetActiveCsListMemory(1)
	refd739fd93 := (*C.tstrSslSetActiveCsList)(memd739fd93)
	allocsd739fd93 := new(cgoAllocMap)
	allocsd739fd93.Add(memd739fd93)

	var cu32CsBMP_allocs *cgoAllocMap
	refd739fd93.u32CsBMP, cu32CsBMP_allocs = (C.uint32_t)(x.U32CsBMP), cgoAllocsUnknown
	allocsd739fd93.Borrow(cu32CsBMP_allocs)

	x.refd739fd93 = refd739fd93
	x.allocsd739fd93 = allocsd739fd93
	return refd739fd93, allocsd739fd93

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SslSetActiveCsList) PassValue() (C.tstrSslSetActiveCsList, *cgoAllocMap) {
	if x.refd739fd93 != nil {
		return *x.refd739fd93, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SslSetActiveCsList) Deref() {
	if x.refd739fd93 == nil {
		return
	}
	x.U32CsBMP = (uint32)(x.refd739fd93.u32CsBMP)
}

// allocOtaInitHdrMemory allocates memory for type C.tstrOtaInitHdr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaInitHdrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaInitHdrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaInitHdrValue = unsafe.Sizeof([1]C.tstrOtaInitHdr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaInitHdr) Ref() *C.tstrOtaInitHdr {
	if x == nil {
		return nil
	}
	return x.ref28fa7407
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaInitHdr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref28fa7407)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaInitHdr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaInitHdr) Free() {
	if x != nil && x.allocs28fa7407 != nil {
		x.allocs28fa7407.(*cgoAllocMap).Free()
		x.ref28fa7407 = nil
	}
}

// NewOtaInitHdrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaInitHdrRef(ref unsafe.Pointer) *OtaInitHdr {
	if ref == nil {
		return nil
	}
	obj := new(OtaInitHdr)
	obj.ref28fa7407 = (*C.tstrOtaInitHdr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaInitHdr) PassRef() (*C.tstrOtaInitHdr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref28fa7407 != nil {
		return x.ref28fa7407, nil
	}
	mem28fa7407 := allocOtaInitHdrMemory(1)
	ref28fa7407 := (*C.tstrOtaInitHdr)(mem28fa7407)
	allocs28fa7407 := new(cgoAllocMap)
	allocs28fa7407.Add(mem28fa7407)

	var cu32OtaMagicValue_allocs *cgoAllocMap
	ref28fa7407.u32OtaMagicValue, cu32OtaMagicValue_allocs = (C.uint32_t)(x.U32OtaMagicValue), cgoAllocsUnknown
	allocs28fa7407.Borrow(cu32OtaMagicValue_allocs)

	var cu32OtaPayloadSize_allocs *cgoAllocMap
	ref28fa7407.u32OtaPayloadSize, cu32OtaPayloadSize_allocs = (C.uint32_t)(x.U32OtaPayloadSize), cgoAllocsUnknown
	allocs28fa7407.Borrow(cu32OtaPayloadSize_allocs)

	x.ref28fa7407 = ref28fa7407
	x.allocs28fa7407 = allocs28fa7407
	return ref28fa7407, allocs28fa7407

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaInitHdr) PassValue() (C.tstrOtaInitHdr, *cgoAllocMap) {
	if x.ref28fa7407 != nil {
		return *x.ref28fa7407, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaInitHdr) Deref() {
	if x.ref28fa7407 == nil {
		return
	}
	x.U32OtaMagicValue = (uint32)(x.ref28fa7407.u32OtaMagicValue)
	x.U32OtaPayloadSize = (uint32)(x.ref28fa7407.u32OtaPayloadSize)
}

// allocOtaControlSecMemory allocates memory for type C.tstrOtaControlSec in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaControlSecMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaControlSecValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaControlSecValue = unsafe.Sizeof([1]C.tstrOtaControlSec{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaControlSec) Ref() *C.tstrOtaControlSec {
	if x == nil {
		return nil
	}
	return x.ref2695ef43
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaControlSec) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref2695ef43)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaControlSec) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaControlSec) Free() {
	if x != nil && x.allocs2695ef43 != nil {
		x.allocs2695ef43.(*cgoAllocMap).Free()
		x.ref2695ef43 = nil
	}
}

// NewOtaControlSecRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaControlSecRef(ref unsafe.Pointer) *OtaControlSec {
	if ref == nil {
		return nil
	}
	obj := new(OtaControlSec)
	obj.ref2695ef43 = (*C.tstrOtaControlSec)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaControlSec) PassRef() (*C.tstrOtaControlSec, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2695ef43 != nil {
		return x.ref2695ef43, nil
	}
	mem2695ef43 := allocOtaControlSecMemory(1)
	ref2695ef43 := (*C.tstrOtaControlSec)(mem2695ef43)
	allocs2695ef43 := new(cgoAllocMap)
	allocs2695ef43.Add(mem2695ef43)

	var cu32OtaMagicValue_allocs *cgoAllocMap
	ref2695ef43.u32OtaMagicValue, cu32OtaMagicValue_allocs = (C.uint32_t)(x.U32OtaMagicValue), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaMagicValue_allocs)

	var cu32OtaFormatVersion_allocs *cgoAllocMap
	ref2695ef43.u32OtaFormatVersion, cu32OtaFormatVersion_allocs = (C.uint32_t)(x.U32OtaFormatVersion), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaFormatVersion_allocs)

	var cu32OtaSequenceNumber_allocs *cgoAllocMap
	ref2695ef43.u32OtaSequenceNumber, cu32OtaSequenceNumber_allocs = (C.uint32_t)(x.U32OtaSequenceNumber), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaSequenceNumber_allocs)

	var cu32OtaLastCheckTime_allocs *cgoAllocMap
	ref2695ef43.u32OtaLastCheckTime, cu32OtaLastCheckTime_allocs = (C.uint32_t)(x.U32OtaLastCheckTime), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaLastCheckTime_allocs)

	var cu32OtaCurrentWorkingImagOffset_allocs *cgoAllocMap
	ref2695ef43.u32OtaCurrentWorkingImagOffset, cu32OtaCurrentWorkingImagOffset_allocs = (C.uint32_t)(x.U32OtaCurrentWorkingImagOffset), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCurrentWorkingImagOffset_allocs)

	var cu32OtaCurrentworkingImagFirmwareVer_allocs *cgoAllocMap
	ref2695ef43.u32OtaCurrentworkingImagFirmwareVer, cu32OtaCurrentworkingImagFirmwareVer_allocs = (C.uint32_t)(x.U32OtaCurrentworkingImagFirmwareVer), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCurrentworkingImagFirmwareVer_allocs)

	var cu32OtaRollbackImageOffset_allocs *cgoAllocMap
	ref2695ef43.u32OtaRollbackImageOffset, cu32OtaRollbackImageOffset_allocs = (C.uint32_t)(x.U32OtaRollbackImageOffset), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaRollbackImageOffset_allocs)

	var cu32OtaRollbackImageValidStatus_allocs *cgoAllocMap
	ref2695ef43.u32OtaRollbackImageValidStatus, cu32OtaRollbackImageValidStatus_allocs = (C.uint32_t)(x.U32OtaRollbackImageValidStatus), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaRollbackImageValidStatus_allocs)

	var cu32OtaRollbackImagFirmwareVer_allocs *cgoAllocMap
	ref2695ef43.u32OtaRollbackImagFirmwareVer, cu32OtaRollbackImagFirmwareVer_allocs = (C.uint32_t)(x.U32OtaRollbackImagFirmwareVer), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaRollbackImagFirmwareVer_allocs)

	var cu32OtaCortusAppWorkingOffset_allocs *cgoAllocMap
	ref2695ef43.u32OtaCortusAppWorkingOffset, cu32OtaCortusAppWorkingOffset_allocs = (C.uint32_t)(x.U32OtaCortusAppWorkingOffset), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCortusAppWorkingOffset_allocs)

	var cu32OtaCortusAppWorkingValidSts_allocs *cgoAllocMap
	ref2695ef43.u32OtaCortusAppWorkingValidSts, cu32OtaCortusAppWorkingValidSts_allocs = (C.uint32_t)(x.U32OtaCortusAppWorkingValidSts), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCortusAppWorkingValidSts_allocs)

	var cu32OtaCortusAppWorkingVer_allocs *cgoAllocMap
	ref2695ef43.u32OtaCortusAppWorkingVer, cu32OtaCortusAppWorkingVer_allocs = (C.uint32_t)(x.U32OtaCortusAppWorkingVer), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCortusAppWorkingVer_allocs)

	var cu32OtaCortusAppRollbackOffset_allocs *cgoAllocMap
	ref2695ef43.u32OtaCortusAppRollbackOffset, cu32OtaCortusAppRollbackOffset_allocs = (C.uint32_t)(x.U32OtaCortusAppRollbackOffset), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCortusAppRollbackOffset_allocs)

	var cu32OtaCortusAppRollbackValidSts_allocs *cgoAllocMap
	ref2695ef43.u32OtaCortusAppRollbackValidSts, cu32OtaCortusAppRollbackValidSts_allocs = (C.uint32_t)(x.U32OtaCortusAppRollbackValidSts), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCortusAppRollbackValidSts_allocs)

	var cu32OtaCortusAppRollbackVer_allocs *cgoAllocMap
	ref2695ef43.u32OtaCortusAppRollbackVer, cu32OtaCortusAppRollbackVer_allocs = (C.uint32_t)(x.U32OtaCortusAppRollbackVer), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaCortusAppRollbackVer_allocs)

	var cu32OtaControlSecCrc_allocs *cgoAllocMap
	ref2695ef43.u32OtaControlSecCrc, cu32OtaControlSecCrc_allocs = (C.uint32_t)(x.U32OtaControlSecCrc), cgoAllocsUnknown
	allocs2695ef43.Borrow(cu32OtaControlSecCrc_allocs)

	x.ref2695ef43 = ref2695ef43
	x.allocs2695ef43 = allocs2695ef43
	return ref2695ef43, allocs2695ef43

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaControlSec) PassValue() (C.tstrOtaControlSec, *cgoAllocMap) {
	if x.ref2695ef43 != nil {
		return *x.ref2695ef43, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaControlSec) Deref() {
	if x.ref2695ef43 == nil {
		return
	}
	x.U32OtaMagicValue = (uint32)(x.ref2695ef43.u32OtaMagicValue)
	x.U32OtaFormatVersion = (uint32)(x.ref2695ef43.u32OtaFormatVersion)
	x.U32OtaSequenceNumber = (uint32)(x.ref2695ef43.u32OtaSequenceNumber)
	x.U32OtaLastCheckTime = (uint32)(x.ref2695ef43.u32OtaLastCheckTime)
	x.U32OtaCurrentWorkingImagOffset = (uint32)(x.ref2695ef43.u32OtaCurrentWorkingImagOffset)
	x.U32OtaCurrentworkingImagFirmwareVer = (uint32)(x.ref2695ef43.u32OtaCurrentworkingImagFirmwareVer)
	x.U32OtaRollbackImageOffset = (uint32)(x.ref2695ef43.u32OtaRollbackImageOffset)
	x.U32OtaRollbackImageValidStatus = (uint32)(x.ref2695ef43.u32OtaRollbackImageValidStatus)
	x.U32OtaRollbackImagFirmwareVer = (uint32)(x.ref2695ef43.u32OtaRollbackImagFirmwareVer)
	x.U32OtaCortusAppWorkingOffset = (uint32)(x.ref2695ef43.u32OtaCortusAppWorkingOffset)
	x.U32OtaCortusAppWorkingValidSts = (uint32)(x.ref2695ef43.u32OtaCortusAppWorkingValidSts)
	x.U32OtaCortusAppWorkingVer = (uint32)(x.ref2695ef43.u32OtaCortusAppWorkingVer)
	x.U32OtaCortusAppRollbackOffset = (uint32)(x.ref2695ef43.u32OtaCortusAppRollbackOffset)
	x.U32OtaCortusAppRollbackValidSts = (uint32)(x.ref2695ef43.u32OtaCortusAppRollbackValidSts)
	x.U32OtaCortusAppRollbackVer = (uint32)(x.ref2695ef43.u32OtaCortusAppRollbackVer)
	x.U32OtaControlSecCrc = (uint32)(x.ref2695ef43.u32OtaControlSecCrc)
}

// allocOtaUpdateStatusRespMemory allocates memory for type C.tstrOtaUpdateStatusResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaUpdateStatusRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaUpdateStatusRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaUpdateStatusRespValue = unsafe.Sizeof([1]C.tstrOtaUpdateStatusResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaUpdateStatusResp) Ref() *C.tstrOtaUpdateStatusResp {
	if x == nil {
		return nil
	}
	return x.ref30cc92d6
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaUpdateStatusResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref30cc92d6)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaUpdateStatusResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaUpdateStatusResp) Free() {
	if x != nil && x.allocs30cc92d6 != nil {
		x.allocs30cc92d6.(*cgoAllocMap).Free()
		x.ref30cc92d6 = nil
	}
}

// NewOtaUpdateStatusRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaUpdateStatusRespRef(ref unsafe.Pointer) *OtaUpdateStatusResp {
	if ref == nil {
		return nil
	}
	obj := new(OtaUpdateStatusResp)
	obj.ref30cc92d6 = (*C.tstrOtaUpdateStatusResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaUpdateStatusResp) PassRef() (*C.tstrOtaUpdateStatusResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref30cc92d6 != nil {
		return x.ref30cc92d6, nil
	}
	mem30cc92d6 := allocOtaUpdateStatusRespMemory(1)
	ref30cc92d6 := (*C.tstrOtaUpdateStatusResp)(mem30cc92d6)
	allocs30cc92d6 := new(cgoAllocMap)
	allocs30cc92d6.Add(mem30cc92d6)

	var cu8OtaUpdateStatusType_allocs *cgoAllocMap
	ref30cc92d6.u8OtaUpdateStatusType, cu8OtaUpdateStatusType_allocs = (C.uint8_t)(x.U8OtaUpdateStatusType), cgoAllocsUnknown
	allocs30cc92d6.Borrow(cu8OtaUpdateStatusType_allocs)

	var cu8OtaUpdateStatus_allocs *cgoAllocMap
	ref30cc92d6.u8OtaUpdateStatus, cu8OtaUpdateStatus_allocs = (C.uint8_t)(x.U8OtaUpdateStatus), cgoAllocsUnknown
	allocs30cc92d6.Borrow(cu8OtaUpdateStatus_allocs)

	var c_PAD16__allocs *cgoAllocMap
	ref30cc92d6._PAD16_, c_PAD16__allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x._PAD16_)), cgoAllocsUnknown
	allocs30cc92d6.Borrow(c_PAD16__allocs)

	x.ref30cc92d6 = ref30cc92d6
	x.allocs30cc92d6 = allocs30cc92d6
	return ref30cc92d6, allocs30cc92d6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaUpdateStatusResp) PassValue() (C.tstrOtaUpdateStatusResp, *cgoAllocMap) {
	if x.ref30cc92d6 != nil {
		return *x.ref30cc92d6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaUpdateStatusResp) Deref() {
	if x.ref30cc92d6 == nil {
		return
	}
	x.U8OtaUpdateStatusType = (byte)(x.ref30cc92d6.u8OtaUpdateStatusType)
	x.U8OtaUpdateStatus = (byte)(x.ref30cc92d6.u8OtaUpdateStatus)
	x._PAD16_ = *(*[2]byte)(unsafe.Pointer(&x.ref30cc92d6._PAD16_))
}

// allocOtaUpdateInfoMemory allocates memory for type C.tstrOtaUpdateInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaUpdateInfoMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaUpdateInfoValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaUpdateInfoValue = unsafe.Sizeof([1]C.tstrOtaUpdateInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaUpdateInfo) Ref() *C.tstrOtaUpdateInfo {
	if x == nil {
		return nil
	}
	return x.refde57f176
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaUpdateInfo) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refde57f176)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaUpdateInfo) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaUpdateInfo) Free() {
	if x != nil && x.allocsde57f176 != nil {
		x.allocsde57f176.(*cgoAllocMap).Free()
		x.refde57f176 = nil
	}
}

// NewOtaUpdateInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaUpdateInfoRef(ref unsafe.Pointer) *OtaUpdateInfo {
	if ref == nil {
		return nil
	}
	obj := new(OtaUpdateInfo)
	obj.refde57f176 = (*C.tstrOtaUpdateInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaUpdateInfo) PassRef() (*C.tstrOtaUpdateInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refde57f176 != nil {
		return x.refde57f176, nil
	}
	memde57f176 := allocOtaUpdateInfoMemory(1)
	refde57f176 := (*C.tstrOtaUpdateInfo)(memde57f176)
	allocsde57f176 := new(cgoAllocMap)
	allocsde57f176.Add(memde57f176)

	var cu8NcfUpgradeVersion_allocs *cgoAllocMap
	refde57f176.u8NcfUpgradeVersion, cu8NcfUpgradeVersion_allocs = (C.uint32_t)(x.U8NcfUpgradeVersion), cgoAllocsUnknown
	allocsde57f176.Borrow(cu8NcfUpgradeVersion_allocs)

	var cu8NcfCurrentVersion_allocs *cgoAllocMap
	refde57f176.u8NcfCurrentVersion, cu8NcfCurrentVersion_allocs = (C.uint32_t)(x.U8NcfCurrentVersion), cgoAllocsUnknown
	allocsde57f176.Borrow(cu8NcfCurrentVersion_allocs)

	var cu8NcdUpgradeVersion_allocs *cgoAllocMap
	refde57f176.u8NcdUpgradeVersion, cu8NcdUpgradeVersion_allocs = (C.uint32_t)(x.U8NcdUpgradeVersion), cgoAllocsUnknown
	allocsde57f176.Borrow(cu8NcdUpgradeVersion_allocs)

	var cu8NcdRequiredUpgrade_allocs *cgoAllocMap
	refde57f176.u8NcdRequiredUpgrade, cu8NcdRequiredUpgrade_allocs = (C.uint8_t)(x.U8NcdRequiredUpgrade), cgoAllocsUnknown
	allocsde57f176.Borrow(cu8NcdRequiredUpgrade_allocs)

	var cu8DownloadUrlOffset_allocs *cgoAllocMap
	refde57f176.u8DownloadUrlOffset, cu8DownloadUrlOffset_allocs = (C.uint8_t)(x.U8DownloadUrlOffset), cgoAllocsUnknown
	allocsde57f176.Borrow(cu8DownloadUrlOffset_allocs)

	var cu8DownloadUrlSize_allocs *cgoAllocMap
	refde57f176.u8DownloadUrlSize, cu8DownloadUrlSize_allocs = (C.uint8_t)(x.U8DownloadUrlSize), cgoAllocsUnknown
	allocsde57f176.Borrow(cu8DownloadUrlSize_allocs)

	var c__PAD8___allocs *cgoAllocMap
	refde57f176.__PAD8__, c__PAD8___allocs = (C.uint8_t)(x.__PAD8__), cgoAllocsUnknown
	allocsde57f176.Borrow(c__PAD8___allocs)

	x.refde57f176 = refde57f176
	x.allocsde57f176 = allocsde57f176
	return refde57f176, allocsde57f176

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaUpdateInfo) PassValue() (C.tstrOtaUpdateInfo, *cgoAllocMap) {
	if x.refde57f176 != nil {
		return *x.refde57f176, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaUpdateInfo) Deref() {
	if x.refde57f176 == nil {
		return
	}
	x.U8NcfUpgradeVersion = (uint32)(x.refde57f176.u8NcfUpgradeVersion)
	x.U8NcfCurrentVersion = (uint32)(x.refde57f176.u8NcfCurrentVersion)
	x.U8NcdUpgradeVersion = (uint32)(x.refde57f176.u8NcdUpgradeVersion)
	x.U8NcdRequiredUpgrade = (byte)(x.refde57f176.u8NcdRequiredUpgrade)
	x.U8DownloadUrlOffset = (byte)(x.refde57f176.u8DownloadUrlOffset)
	x.U8DownloadUrlSize = (byte)(x.refde57f176.u8DownloadUrlSize)
	x.__PAD8__ = (byte)(x.refde57f176.__PAD8__)
}

// allocOtaHostFileGetStatusRespMemory allocates memory for type C.tstrOtaHostFileGetStatusResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaHostFileGetStatusRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaHostFileGetStatusRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaHostFileGetStatusRespValue = unsafe.Sizeof([1]C.tstrOtaHostFileGetStatusResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaHostFileGetStatusResp) Ref() *C.tstrOtaHostFileGetStatusResp {
	if x == nil {
		return nil
	}
	return x.ref7a592c76
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaHostFileGetStatusResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref7a592c76)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaHostFileGetStatusResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaHostFileGetStatusResp) Free() {
	if x != nil && x.allocs7a592c76 != nil {
		x.allocs7a592c76.(*cgoAllocMap).Free()
		x.ref7a592c76 = nil
	}
}

// NewOtaHostFileGetStatusRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaHostFileGetStatusRespRef(ref unsafe.Pointer) *OtaHostFileGetStatusResp {
	if ref == nil {
		return nil
	}
	obj := new(OtaHostFileGetStatusResp)
	obj.ref7a592c76 = (*C.tstrOtaHostFileGetStatusResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaHostFileGetStatusResp) PassRef() (*C.tstrOtaHostFileGetStatusResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a592c76 != nil {
		return x.ref7a592c76, nil
	}
	mem7a592c76 := allocOtaHostFileGetStatusRespMemory(1)
	ref7a592c76 := (*C.tstrOtaHostFileGetStatusResp)(mem7a592c76)
	allocs7a592c76 := new(cgoAllocMap)
	allocs7a592c76.Add(mem7a592c76)

	var cu32OtaFileSize_allocs *cgoAllocMap
	ref7a592c76.u32OtaFileSize, cu32OtaFileSize_allocs = (C.uint32_t)(x.U32OtaFileSize), cgoAllocsUnknown
	allocs7a592c76.Borrow(cu32OtaFileSize_allocs)

	var cu8OtaFileGetStatus_allocs *cgoAllocMap
	ref7a592c76.u8OtaFileGetStatus, cu8OtaFileGetStatus_allocs = (C.uint8_t)(x.U8OtaFileGetStatus), cgoAllocsUnknown
	allocs7a592c76.Borrow(cu8OtaFileGetStatus_allocs)

	var cu8CFHandler_allocs *cgoAllocMap
	ref7a592c76.u8CFHandler, cu8CFHandler_allocs = (C.uint8_t)(x.U8CFHandler), cgoAllocsUnknown
	allocs7a592c76.Borrow(cu8CFHandler_allocs)

	var c__PAD16___allocs *cgoAllocMap
	ref7a592c76.__PAD16__, c__PAD16___allocs = *(*[2]C.uint8_t)(unsafe.Pointer(&x.__PAD16__)), cgoAllocsUnknown
	allocs7a592c76.Borrow(c__PAD16___allocs)

	x.ref7a592c76 = ref7a592c76
	x.allocs7a592c76 = allocs7a592c76
	return ref7a592c76, allocs7a592c76

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaHostFileGetStatusResp) PassValue() (C.tstrOtaHostFileGetStatusResp, *cgoAllocMap) {
	if x.ref7a592c76 != nil {
		return *x.ref7a592c76, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaHostFileGetStatusResp) Deref() {
	if x.ref7a592c76 == nil {
		return
	}
	x.U32OtaFileSize = (uint32)(x.ref7a592c76.u32OtaFileSize)
	x.U8OtaFileGetStatus = (byte)(x.ref7a592c76.u8OtaFileGetStatus)
	x.U8CFHandler = (byte)(x.ref7a592c76.u8CFHandler)
	x.__PAD16__ = *(*[2]byte)(unsafe.Pointer(&x.ref7a592c76.__PAD16__))
}

// allocOtaHostFileReadStatusRespMemory allocates memory for type C.tstrOtaHostFileReadStatusResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaHostFileReadStatusRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaHostFileReadStatusRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaHostFileReadStatusRespValue = unsafe.Sizeof([1]C.tstrOtaHostFileReadStatusResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaHostFileReadStatusResp) Ref() *C.tstrOtaHostFileReadStatusResp {
	if x == nil {
		return nil
	}
	return x.refe198073a
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaHostFileReadStatusResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refe198073a)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaHostFileReadStatusResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaHostFileReadStatusResp) Free() {
	if x != nil && x.allocse198073a != nil {
		x.allocse198073a.(*cgoAllocMap).Free()
		x.refe198073a = nil
	}
}

// NewOtaHostFileReadStatusRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaHostFileReadStatusRespRef(ref unsafe.Pointer) *OtaHostFileReadStatusResp {
	if ref == nil {
		return nil
	}
	obj := new(OtaHostFileReadStatusResp)
	obj.refe198073a = (*C.tstrOtaHostFileReadStatusResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaHostFileReadStatusResp) PassRef() (*C.tstrOtaHostFileReadStatusResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refe198073a != nil {
		return x.refe198073a, nil
	}
	meme198073a := allocOtaHostFileReadStatusRespMemory(1)
	refe198073a := (*C.tstrOtaHostFileReadStatusResp)(meme198073a)
	allocse198073a := new(cgoAllocMap)
	allocse198073a.Add(meme198073a)

	var cu16FileBlockSz_allocs *cgoAllocMap
	refe198073a.u16FileBlockSz, cu16FileBlockSz_allocs = (C.uint16_t)(x.U16FileBlockSz), cgoAllocsUnknown
	allocse198073a.Borrow(cu16FileBlockSz_allocs)

	var cu8OtaFileReadStatus_allocs *cgoAllocMap
	refe198073a.u8OtaFileReadStatus, cu8OtaFileReadStatus_allocs = (C.uint8_t)(x.U8OtaFileReadStatus), cgoAllocsUnknown
	allocse198073a.Borrow(cu8OtaFileReadStatus_allocs)

	var c__PAD8___allocs *cgoAllocMap
	refe198073a.__PAD8__, c__PAD8___allocs = (C.uint8_t)(x.__PAD8__), cgoAllocsUnknown
	allocse198073a.Borrow(c__PAD8___allocs)

	var cpFileBuf_allocs *cgoAllocMap
	refe198073a.pFileBuf, cpFileBuf_allocs = *(*[128]C.uint8_t)(unsafe.Pointer(&x.PFileBuf)), cgoAllocsUnknown
	allocse198073a.Borrow(cpFileBuf_allocs)

	x.refe198073a = refe198073a
	x.allocse198073a = allocse198073a
	return refe198073a, allocse198073a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaHostFileReadStatusResp) PassValue() (C.tstrOtaHostFileReadStatusResp, *cgoAllocMap) {
	if x.refe198073a != nil {
		return *x.refe198073a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaHostFileReadStatusResp) Deref() {
	if x.refe198073a == nil {
		return
	}
	x.U16FileBlockSz = (uint16)(x.refe198073a.u16FileBlockSz)
	x.U8OtaFileReadStatus = (byte)(x.refe198073a.u8OtaFileReadStatus)
	x.__PAD8__ = (byte)(x.refe198073a.__PAD8__)
	x.PFileBuf = *(*[128]byte)(unsafe.Pointer(&x.refe198073a.pFileBuf))
}

// allocOtaHostFileEraseStatusRespMemory allocates memory for type C.tstrOtaHostFileEraseStatusResp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaHostFileEraseStatusRespMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaHostFileEraseStatusRespValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaHostFileEraseStatusRespValue = unsafe.Sizeof([1]C.tstrOtaHostFileEraseStatusResp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaHostFileEraseStatusResp) Ref() *C.tstrOtaHostFileEraseStatusResp {
	if x == nil {
		return nil
	}
	return x.ref8dd1de0d
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaHostFileEraseStatusResp) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref8dd1de0d)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaHostFileEraseStatusResp) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaHostFileEraseStatusResp) Free() {
	if x != nil && x.allocs8dd1de0d != nil {
		x.allocs8dd1de0d.(*cgoAllocMap).Free()
		x.ref8dd1de0d = nil
	}
}

// NewOtaHostFileEraseStatusRespRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaHostFileEraseStatusRespRef(ref unsafe.Pointer) *OtaHostFileEraseStatusResp {
	if ref == nil {
		return nil
	}
	obj := new(OtaHostFileEraseStatusResp)
	obj.ref8dd1de0d = (*C.tstrOtaHostFileEraseStatusResp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaHostFileEraseStatusResp) PassRef() (*C.tstrOtaHostFileEraseStatusResp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8dd1de0d != nil {
		return x.ref8dd1de0d, nil
	}
	mem8dd1de0d := allocOtaHostFileEraseStatusRespMemory(1)
	ref8dd1de0d := (*C.tstrOtaHostFileEraseStatusResp)(mem8dd1de0d)
	allocs8dd1de0d := new(cgoAllocMap)
	allocs8dd1de0d.Add(mem8dd1de0d)

	var cu8OtaFileEraseStatus_allocs *cgoAllocMap
	ref8dd1de0d.u8OtaFileEraseStatus, cu8OtaFileEraseStatus_allocs = (C.uint8_t)(x.U8OtaFileEraseStatus), cgoAllocsUnknown
	allocs8dd1de0d.Borrow(cu8OtaFileEraseStatus_allocs)

	var c__PAD24___allocs *cgoAllocMap
	ref8dd1de0d.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocs8dd1de0d.Borrow(c__PAD24___allocs)

	x.ref8dd1de0d = ref8dd1de0d
	x.allocs8dd1de0d = allocs8dd1de0d
	return ref8dd1de0d, allocs8dd1de0d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaHostFileEraseStatusResp) PassValue() (C.tstrOtaHostFileEraseStatusResp, *cgoAllocMap) {
	if x.ref8dd1de0d != nil {
		return *x.ref8dd1de0d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaHostFileEraseStatusResp) Deref() {
	if x.ref8dd1de0d == nil {
		return
	}
	x.U8OtaFileEraseStatus = (byte)(x.ref8dd1de0d.u8OtaFileEraseStatus)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.ref8dd1de0d.__PAD24__))
}

// allocOtaStartMemory allocates memory for type C.tstrOtaStart in C.
// The caller is responsible for freeing the this memory via C.free.
func allocOtaStartMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfOtaStartValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfOtaStartValue = unsafe.Sizeof([1]C.tstrOtaStart{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *OtaStart) Ref() *C.tstrOtaStart {
	if x == nil {
		return nil
	}
	return x.refa906f3b7
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *OtaStart) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refa906f3b7)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *OtaStart) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *OtaStart) Free() {
	if x != nil && x.allocsa906f3b7 != nil {
		x.allocsa906f3b7.(*cgoAllocMap).Free()
		x.refa906f3b7 = nil
	}
}

// NewOtaStartRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewOtaStartRef(ref unsafe.Pointer) *OtaStart {
	if ref == nil {
		return nil
	}
	obj := new(OtaStart)
	obj.refa906f3b7 = (*C.tstrOtaStart)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *OtaStart) PassRef() (*C.tstrOtaStart, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa906f3b7 != nil {
		return x.refa906f3b7, nil
	}
	mema906f3b7 := allocOtaStartMemory(1)
	refa906f3b7 := (*C.tstrOtaStart)(mema906f3b7)
	allocsa906f3b7 := new(cgoAllocMap)
	allocsa906f3b7.Add(mema906f3b7)

	var cu32TotalLen_allocs *cgoAllocMap
	refa906f3b7.u32TotalLen, cu32TotalLen_allocs = (C.uint32_t)(x.U32TotalLen), cgoAllocsUnknown
	allocsa906f3b7.Borrow(cu32TotalLen_allocs)

	var cacUrl_allocs *cgoAllocMap
	refa906f3b7.acUrl, cacUrl_allocs = *(*[256]C.char)(unsafe.Pointer(&x.AcUrl)), cgoAllocsUnknown
	allocsa906f3b7.Borrow(cacUrl_allocs)

	var cacSNI_allocs *cgoAllocMap
	refa906f3b7.acSNI, cacSNI_allocs = *(*[64]C.char)(unsafe.Pointer(&x.AcSNI)), cgoAllocsUnknown
	allocsa906f3b7.Borrow(cacSNI_allocs)

	var cu8SSLFlags_allocs *cgoAllocMap
	refa906f3b7.u8SSLFlags, cu8SSLFlags_allocs = (C.uint8_t)(x.U8SSLFlags), cgoAllocsUnknown
	allocsa906f3b7.Borrow(cu8SSLFlags_allocs)

	var c__PAD24___allocs *cgoAllocMap
	refa906f3b7.__PAD24__, c__PAD24___allocs = *(*[3]C.uint8_t)(unsafe.Pointer(&x.__PAD24__)), cgoAllocsUnknown
	allocsa906f3b7.Borrow(c__PAD24___allocs)

	x.refa906f3b7 = refa906f3b7
	x.allocsa906f3b7 = allocsa906f3b7
	return refa906f3b7, allocsa906f3b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x OtaStart) PassValue() (C.tstrOtaStart, *cgoAllocMap) {
	if x.refa906f3b7 != nil {
		return *x.refa906f3b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *OtaStart) Deref() {
	if x.refa906f3b7 == nil {
		return
	}
	x.U32TotalLen = (uint32)(x.refa906f3b7.u32TotalLen)
	x.AcUrl = *(*[256]byte)(unsafe.Pointer(&x.refa906f3b7.acUrl))
	x.AcSNI = *(*[64]byte)(unsafe.Pointer(&x.refa906f3b7.acSNI))
	x.U8SSLFlags = (byte)(x.refa906f3b7.u8SSLFlags)
	x.__PAD24__ = *(*[3]byte)(unsafe.Pointer(&x.refa906f3b7.__PAD24__))
}

// allocSockErrMemory allocates memory for type C.tstrSockErr in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSockErrMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSockErrValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSockErrValue = unsafe.Sizeof([1]C.tstrSockErr{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SockErr) Ref() *C.tstrSockErr {
	if x == nil {
		return nil
	}
	return x.ref7741dd47
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SockErr) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref7741dd47)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SockErr) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SockErr) Free() {
	if x != nil && x.allocs7741dd47 != nil {
		x.allocs7741dd47.(*cgoAllocMap).Free()
		x.ref7741dd47 = nil
	}
}

// NewSockErrRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSockErrRef(ref unsafe.Pointer) *SockErr {
	if ref == nil {
		return nil
	}
	obj := new(SockErr)
	obj.ref7741dd47 = (*C.tstrSockErr)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SockErr) PassRef() (*C.tstrSockErr, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7741dd47 != nil {
		return x.ref7741dd47, nil
	}
	mem7741dd47 := allocSockErrMemory(1)
	ref7741dd47 := (*C.tstrSockErr)(mem7741dd47)
	allocs7741dd47 := new(cgoAllocMap)
	allocs7741dd47.Add(mem7741dd47)

	var cenuErrSource_allocs *cgoAllocMap
	ref7741dd47.enuErrSource, cenuErrSource_allocs = (C.tenuSockErrSource)(x.EnuErrSource), cgoAllocsUnknown
	allocs7741dd47.Borrow(cenuErrSource_allocs)

	var cu8ErrCode_allocs *cgoAllocMap
	ref7741dd47.u8ErrCode, cu8ErrCode_allocs = (C.uint8_t)(x.U8ErrCode), cgoAllocsUnknown
	allocs7741dd47.Borrow(cu8ErrCode_allocs)

	x.ref7741dd47 = ref7741dd47
	x.allocs7741dd47 = allocs7741dd47
	return ref7741dd47, allocs7741dd47

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SockErr) PassValue() (C.tstrSockErr, *cgoAllocMap) {
	if x.ref7741dd47 != nil {
		return *x.ref7741dd47, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SockErr) Deref() {
	if x.ref7741dd47 == nil {
		return
	}
	x.EnuErrSource = (EnumSockErrSource)(x.ref7741dd47.enuErrSource)
	x.U8ErrCode = (byte)(x.ref7741dd47.u8ErrCode)
}

// allocSocketBindMsgMemory allocates memory for type C.tstrSocketBindMsg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSocketBindMsgMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSocketBindMsgValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSocketBindMsgValue = unsafe.Sizeof([1]C.tstrSocketBindMsg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SocketBindMsg) Ref() *C.tstrSocketBindMsg {
	if x == nil {
		return nil
	}
	return x.ref5e2a78d3
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SocketBindMsg) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref5e2a78d3)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SocketBindMsg) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SocketBindMsg) Free() {
	if x != nil && x.allocs5e2a78d3 != nil {
		x.allocs5e2a78d3.(*cgoAllocMap).Free()
		x.ref5e2a78d3 = nil
	}
}

// NewSocketBindMsgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSocketBindMsgRef(ref unsafe.Pointer) *SocketBindMsg {
	if ref == nil {
		return nil
	}
	obj := new(SocketBindMsg)
	obj.ref5e2a78d3 = (*C.tstrSocketBindMsg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SocketBindMsg) PassRef() (*C.tstrSocketBindMsg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5e2a78d3 != nil {
		return x.ref5e2a78d3, nil
	}
	mem5e2a78d3 := allocSocketBindMsgMemory(1)
	ref5e2a78d3 := (*C.tstrSocketBindMsg)(mem5e2a78d3)
	allocs5e2a78d3 := new(cgoAllocMap)
	allocs5e2a78d3.Add(mem5e2a78d3)

	var cstatus_allocs *cgoAllocMap
	ref5e2a78d3.status, cstatus_allocs = (C.int8_t)(x.Status), cgoAllocsUnknown
	allocs5e2a78d3.Borrow(cstatus_allocs)

	x.ref5e2a78d3 = ref5e2a78d3
	x.allocs5e2a78d3 = allocs5e2a78d3
	return ref5e2a78d3, allocs5e2a78d3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SocketBindMsg) PassValue() (C.tstrSocketBindMsg, *cgoAllocMap) {
	if x.ref5e2a78d3 != nil {
		return *x.ref5e2a78d3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SocketBindMsg) Deref() {
	if x.ref5e2a78d3 == nil {
		return
	}
	x.Status = (int8)(x.ref5e2a78d3.status)
}

// allocSocketListenMsgMemory allocates memory for type C.tstrSocketListenMsg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSocketListenMsgMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSocketListenMsgValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSocketListenMsgValue = unsafe.Sizeof([1]C.tstrSocketListenMsg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SocketListenMsg) Ref() *C.tstrSocketListenMsg {
	if x == nil {
		return nil
	}
	return x.refc9d3f17f
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SocketListenMsg) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refc9d3f17f)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SocketListenMsg) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SocketListenMsg) Free() {
	if x != nil && x.allocsc9d3f17f != nil {
		x.allocsc9d3f17f.(*cgoAllocMap).Free()
		x.refc9d3f17f = nil
	}
}

// NewSocketListenMsgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSocketListenMsgRef(ref unsafe.Pointer) *SocketListenMsg {
	if ref == nil {
		return nil
	}
	obj := new(SocketListenMsg)
	obj.refc9d3f17f = (*C.tstrSocketListenMsg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SocketListenMsg) PassRef() (*C.tstrSocketListenMsg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc9d3f17f != nil {
		return x.refc9d3f17f, nil
	}
	memc9d3f17f := allocSocketListenMsgMemory(1)
	refc9d3f17f := (*C.tstrSocketListenMsg)(memc9d3f17f)
	allocsc9d3f17f := new(cgoAllocMap)
	allocsc9d3f17f.Add(memc9d3f17f)

	var cstatus_allocs *cgoAllocMap
	refc9d3f17f.status, cstatus_allocs = (C.int8_t)(x.Status), cgoAllocsUnknown
	allocsc9d3f17f.Borrow(cstatus_allocs)

	x.refc9d3f17f = refc9d3f17f
	x.allocsc9d3f17f = allocsc9d3f17f
	return refc9d3f17f, allocsc9d3f17f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SocketListenMsg) PassValue() (C.tstrSocketListenMsg, *cgoAllocMap) {
	if x.refc9d3f17f != nil {
		return *x.refc9d3f17f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SocketListenMsg) Deref() {
	if x.refc9d3f17f == nil {
		return
	}
	x.Status = (int8)(x.refc9d3f17f.status)
}

// allocSocketAcceptMsgMemory allocates memory for type C.tstrSocketAcceptMsg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSocketAcceptMsgMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSocketAcceptMsgValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSocketAcceptMsgValue = unsafe.Sizeof([1]C.tstrSocketAcceptMsg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SocketAcceptMsg) Ref() *C.tstrSocketAcceptMsg {
	if x == nil {
		return nil
	}
	return x.ref91ace819
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SocketAcceptMsg) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref91ace819)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SocketAcceptMsg) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SocketAcceptMsg) Free() {
	if x != nil && x.allocs91ace819 != nil {
		x.allocs91ace819.(*cgoAllocMap).Free()
		x.ref91ace819 = nil
	}
}

// NewSocketAcceptMsgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSocketAcceptMsgRef(ref unsafe.Pointer) *SocketAcceptMsg {
	if ref == nil {
		return nil
	}
	obj := new(SocketAcceptMsg)
	obj.ref91ace819 = (*C.tstrSocketAcceptMsg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SocketAcceptMsg) PassRef() (*C.tstrSocketAcceptMsg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref91ace819 != nil {
		return x.ref91ace819, nil
	}
	mem91ace819 := allocSocketAcceptMsgMemory(1)
	ref91ace819 := (*C.tstrSocketAcceptMsg)(mem91ace819)
	allocs91ace819 := new(cgoAllocMap)
	allocs91ace819.Add(mem91ace819)

	var csock_allocs *cgoAllocMap
	ref91ace819.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs91ace819.Borrow(csock_allocs)

	x.ref91ace819 = ref91ace819
	x.allocs91ace819 = allocs91ace819
	return ref91ace819, allocs91ace819

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SocketAcceptMsg) PassValue() (C.tstrSocketAcceptMsg, *cgoAllocMap) {
	if x.ref91ace819 != nil {
		return *x.ref91ace819, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SocketAcceptMsg) Deref() {
	if x.ref91ace819 == nil {
		return
	}
	x.Sock = (int8)(x.ref91ace819.sock)
}

// allocSocketConnectMsgMemory allocates memory for type C.tstrSocketConnectMsg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSocketConnectMsgMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSocketConnectMsgValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSocketConnectMsgValue = unsafe.Sizeof([1]C.tstrSocketConnectMsg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SocketConnectMsg) Ref() *C.tstrSocketConnectMsg {
	if x == nil {
		return nil
	}
	return x.ref124e0d02
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SocketConnectMsg) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref124e0d02)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SocketConnectMsg) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SocketConnectMsg) Free() {
	if x != nil && x.allocs124e0d02 != nil {
		x.allocs124e0d02.(*cgoAllocMap).Free()
		x.ref124e0d02 = nil
	}
}

// NewSocketConnectMsgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSocketConnectMsgRef(ref unsafe.Pointer) *SocketConnectMsg {
	if ref == nil {
		return nil
	}
	obj := new(SocketConnectMsg)
	obj.ref124e0d02 = (*C.tstrSocketConnectMsg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SocketConnectMsg) PassRef() (*C.tstrSocketConnectMsg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref124e0d02 != nil {
		return x.ref124e0d02, nil
	}
	mem124e0d02 := allocSocketConnectMsgMemory(1)
	ref124e0d02 := (*C.tstrSocketConnectMsg)(mem124e0d02)
	allocs124e0d02 := new(cgoAllocMap)
	allocs124e0d02.Add(mem124e0d02)

	var csock_allocs *cgoAllocMap
	ref124e0d02.sock, csock_allocs = (C.SOCKET)(x.Sock), cgoAllocsUnknown
	allocs124e0d02.Borrow(csock_allocs)

	var cs8Error_allocs *cgoAllocMap
	ref124e0d02.s8Error, cs8Error_allocs = (C.int8_t)(x.S8Error), cgoAllocsUnknown
	allocs124e0d02.Borrow(cs8Error_allocs)

	x.ref124e0d02 = ref124e0d02
	x.allocs124e0d02 = allocs124e0d02
	return ref124e0d02, allocs124e0d02

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SocketConnectMsg) PassValue() (C.tstrSocketConnectMsg, *cgoAllocMap) {
	if x.ref124e0d02 != nil {
		return *x.ref124e0d02, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SocketConnectMsg) Deref() {
	if x.ref124e0d02 == nil {
		return
	}
	x.Sock = (int8)(x.ref124e0d02.sock)
	x.S8Error = (int8)(x.ref124e0d02.s8Error)
}

// allocSocketRecvMsgMemory allocates memory for type C.tstrSocketRecvMsg in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSocketRecvMsgMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfSocketRecvMsgValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfSocketRecvMsgValue = unsafe.Sizeof([1]C.tstrSocketRecvMsg{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *SocketRecvMsg) Ref() *C.tstrSocketRecvMsg {
	if x == nil {
		return nil
	}
	return x.ref4cb67fc3
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *SocketRecvMsg) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref4cb67fc3)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *SocketRecvMsg) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *SocketRecvMsg) Free() {
	if x != nil && x.allocs4cb67fc3 != nil {
		x.allocs4cb67fc3.(*cgoAllocMap).Free()
		x.ref4cb67fc3 = nil
	}
}

// NewSocketRecvMsgRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSocketRecvMsgRef(ref unsafe.Pointer) *SocketRecvMsg {
	if ref == nil {
		return nil
	}
	obj := new(SocketRecvMsg)
	obj.ref4cb67fc3 = (*C.tstrSocketRecvMsg)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *SocketRecvMsg) PassRef() (*C.tstrSocketRecvMsg, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4cb67fc3 != nil {
		return x.ref4cb67fc3, nil
	}
	mem4cb67fc3 := allocSocketRecvMsgMemory(1)
	ref4cb67fc3 := (*C.tstrSocketRecvMsg)(mem4cb67fc3)
	allocs4cb67fc3 := new(cgoAllocMap)
	allocs4cb67fc3.Add(mem4cb67fc3)

	var cpu8Buffer_allocs *cgoAllocMap
	ref4cb67fc3.pu8Buffer, cpu8Buffer_allocs = copyPUint8_tBytes((*sliceHeader)(unsafe.Pointer(&x.Pu8Buffer)))
	allocs4cb67fc3.Borrow(cpu8Buffer_allocs)

	var cs16BufferSize_allocs *cgoAllocMap
	ref4cb67fc3.s16BufferSize, cs16BufferSize_allocs = (C.int16_t)(x.S16BufferSize), cgoAllocsUnknown
	allocs4cb67fc3.Borrow(cs16BufferSize_allocs)

	var cu16RemainingSize_allocs *cgoAllocMap
	ref4cb67fc3.u16RemainingSize, cu16RemainingSize_allocs = (C.uint16_t)(x.U16RemainingSize), cgoAllocsUnknown
	allocs4cb67fc3.Borrow(cu16RemainingSize_allocs)

	x.ref4cb67fc3 = ref4cb67fc3
	x.allocs4cb67fc3 = allocs4cb67fc3
	return ref4cb67fc3, allocs4cb67fc3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x SocketRecvMsg) PassValue() (C.tstrSocketRecvMsg, *cgoAllocMap) {
	if x.ref4cb67fc3 != nil {
		return *x.ref4cb67fc3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *SocketRecvMsg) Deref() {
	if x.ref4cb67fc3 == nil {
		return
	}
	hxf95e7c8 := (*sliceHeader)(unsafe.Pointer(&x.Pu8Buffer))
	hxf95e7c8.Data = unsafe.Pointer(x.ref4cb67fc3.pu8Buffer)
	hxf95e7c8.Cap = 0x7fffffff
	// hxf95e7c8.Len = ?

	x.S16BufferSize = (int16)(x.ref4cb67fc3.s16BufferSize)
	x.U16RemainingSize = (uint16)(x.ref4cb67fc3.u16RemainingSize)
}

// allocEC_POINT_REPMemory allocates memory for type C.WDRV_WINC_EC_POINT_REP in C.
// The caller is responsible for freeing the this memory via C.free.
func allocEC_POINT_REPMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfEC_POINT_REPValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfEC_POINT_REPValue = unsafe.Sizeof([1]C.WDRV_WINC_EC_POINT_REP{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *EC_POINT_REP) Ref() *C.WDRV_WINC_EC_POINT_REP {
	if x == nil {
		return nil
	}
	return x.ref45b763ad
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *EC_POINT_REP) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref45b763ad)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *EC_POINT_REP) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *EC_POINT_REP) Free() {
	if x != nil && x.allocs45b763ad != nil {
		x.allocs45b763ad.(*cgoAllocMap).Free()
		x.ref45b763ad = nil
	}
}

// NewEC_POINT_REPRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewEC_POINT_REPRef(ref unsafe.Pointer) *EC_POINT_REP {
	if ref == nil {
		return nil
	}
	obj := new(EC_POINT_REP)
	obj.ref45b763ad = (*C.WDRV_WINC_EC_POINT_REP)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *EC_POINT_REP) PassRef() (*C.WDRV_WINC_EC_POINT_REP, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref45b763ad != nil {
		return x.ref45b763ad, nil
	}
	mem45b763ad := allocEC_POINT_REPMemory(1)
	ref45b763ad := (*C.WDRV_WINC_EC_POINT_REP)(mem45b763ad)
	allocs45b763ad := new(cgoAllocMap)
	allocs45b763ad.Add(mem45b763ad)

	var cx_allocs *cgoAllocMap
	ref45b763ad.x, cx_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.X)), cgoAllocsUnknown
	allocs45b763ad.Borrow(cx_allocs)

	var cy_allocs *cgoAllocMap
	ref45b763ad.y, cy_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Y)), cgoAllocsUnknown
	allocs45b763ad.Borrow(cy_allocs)

	var csize_allocs *cgoAllocMap
	ref45b763ad.size, csize_allocs = (C.uint16_t)(x.Size), cgoAllocsUnknown
	allocs45b763ad.Borrow(csize_allocs)

	var cprivKeyID_allocs *cgoAllocMap
	ref45b763ad.privKeyID, cprivKeyID_allocs = (C.uint16_t)(x.PrivKeyID), cgoAllocsUnknown
	allocs45b763ad.Borrow(cprivKeyID_allocs)

	x.ref45b763ad = ref45b763ad
	x.allocs45b763ad = allocs45b763ad
	return ref45b763ad, allocs45b763ad

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x EC_POINT_REP) PassValue() (C.WDRV_WINC_EC_POINT_REP, *cgoAllocMap) {
	if x.ref45b763ad != nil {
		return *x.ref45b763ad, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *EC_POINT_REP) Deref() {
	if x.ref45b763ad == nil {
		return
	}
	x.X = *(*[32]byte)(unsafe.Pointer(&x.ref45b763ad.x))
	x.Y = *(*[32]byte)(unsafe.Pointer(&x.ref45b763ad.y))
	x.Size = (uint16)(x.ref45b763ad.size)
	x.PrivKeyID = (uint16)(x.ref45b763ad.privKeyID)
}

// allocECDSA_VERIFY_REQ_INFOMemory allocates memory for type C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECDSA_VERIFY_REQ_INFOMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfECDSA_VERIFY_REQ_INFOValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfECDSA_VERIFY_REQ_INFOValue = unsafe.Sizeof([1]C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ECDSA_VERIFY_REQ_INFO) Ref() *C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO {
	if x == nil {
		return nil
	}
	return x.ref9275a4f4
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ECDSA_VERIFY_REQ_INFO) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref9275a4f4)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ECDSA_VERIFY_REQ_INFO) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ECDSA_VERIFY_REQ_INFO) Free() {
	if x != nil && x.allocs9275a4f4 != nil {
		x.allocs9275a4f4.(*cgoAllocMap).Free()
		x.ref9275a4f4 = nil
	}
}

// NewECDSA_VERIFY_REQ_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewECDSA_VERIFY_REQ_INFORef(ref unsafe.Pointer) *ECDSA_VERIFY_REQ_INFO {
	if ref == nil {
		return nil
	}
	obj := new(ECDSA_VERIFY_REQ_INFO)
	obj.ref9275a4f4 = (*C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ECDSA_VERIFY_REQ_INFO) PassRef() (*C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9275a4f4 != nil {
		return x.ref9275a4f4, nil
	}
	mem9275a4f4 := allocECDSA_VERIFY_REQ_INFOMemory(1)
	ref9275a4f4 := (*C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO)(mem9275a4f4)
	allocs9275a4f4 := new(cgoAllocMap)
	allocs9275a4f4.Add(mem9275a4f4)

	var cnSig_allocs *cgoAllocMap
	ref9275a4f4.nSig, cnSig_allocs = (C.uint32_t)(x.NSig), cgoAllocsUnknown
	allocs9275a4f4.Borrow(cnSig_allocs)

	x.ref9275a4f4 = ref9275a4f4
	x.allocs9275a4f4 = allocs9275a4f4
	return ref9275a4f4, allocs9275a4f4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ECDSA_VERIFY_REQ_INFO) PassValue() (C.WDRV_WINC_ECDSA_VERIFY_REQ_INFO, *cgoAllocMap) {
	if x.ref9275a4f4 != nil {
		return *x.ref9275a4f4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ECDSA_VERIFY_REQ_INFO) Deref() {
	if x.ref9275a4f4 == nil {
		return
	}
	x.NSig = (uint32)(x.ref9275a4f4.nSig)
}

// allocECDSA_SIGN_REQ_INFOMemory allocates memory for type C.WDRV_WINC_ECDSA_SIGN_REQ_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECDSA_SIGN_REQ_INFOMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfECDSA_SIGN_REQ_INFOValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfECDSA_SIGN_REQ_INFOValue = unsafe.Sizeof([1]C.WDRV_WINC_ECDSA_SIGN_REQ_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ECDSA_SIGN_REQ_INFO) Ref() *C.WDRV_WINC_ECDSA_SIGN_REQ_INFO {
	if x == nil {
		return nil
	}
	return x.ref474741b0
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ECDSA_SIGN_REQ_INFO) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref474741b0)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ECDSA_SIGN_REQ_INFO) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ECDSA_SIGN_REQ_INFO) Free() {
	if x != nil && x.allocs474741b0 != nil {
		x.allocs474741b0.(*cgoAllocMap).Free()
		x.ref474741b0 = nil
	}
}

// NewECDSA_SIGN_REQ_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewECDSA_SIGN_REQ_INFORef(ref unsafe.Pointer) *ECDSA_SIGN_REQ_INFO {
	if ref == nil {
		return nil
	}
	obj := new(ECDSA_SIGN_REQ_INFO)
	obj.ref474741b0 = (*C.WDRV_WINC_ECDSA_SIGN_REQ_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ECDSA_SIGN_REQ_INFO) PassRef() (*C.WDRV_WINC_ECDSA_SIGN_REQ_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref474741b0 != nil {
		return x.ref474741b0, nil
	}
	mem474741b0 := allocECDSA_SIGN_REQ_INFOMemory(1)
	ref474741b0 := (*C.WDRV_WINC_ECDSA_SIGN_REQ_INFO)(mem474741b0)
	allocs474741b0 := new(cgoAllocMap)
	allocs474741b0.Add(mem474741b0)

	var ccurveType_allocs *cgoAllocMap
	ref474741b0.curveType, ccurveType_allocs = (C.uint16_t)(x.CurveType), cgoAllocsUnknown
	allocs474741b0.Borrow(ccurveType_allocs)

	var chashSz_allocs *cgoAllocMap
	ref474741b0.hashSz, chashSz_allocs = (C.uint16_t)(x.HashSz), cgoAllocsUnknown
	allocs474741b0.Borrow(chashSz_allocs)

	x.ref474741b0 = ref474741b0
	x.allocs474741b0 = allocs474741b0
	return ref474741b0, allocs474741b0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ECDSA_SIGN_REQ_INFO) PassValue() (C.WDRV_WINC_ECDSA_SIGN_REQ_INFO, *cgoAllocMap) {
	if x.ref474741b0 != nil {
		return *x.ref474741b0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ECDSA_SIGN_REQ_INFO) Deref() {
	if x.ref474741b0 == nil {
		return
	}
	x.CurveType = (uint16)(x.ref474741b0.curveType)
	x.HashSz = (uint16)(x.ref474741b0.hashSz)
}

// allocECDH_INFOMemory allocates memory for type C.WDRV_WINC_ECDH_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECDH_INFOMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfECDH_INFOValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfECDH_INFOValue = unsafe.Sizeof([1]C.WDRV_WINC_ECDH_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ECDH_INFO) Ref() *C.WDRV_WINC_ECDH_INFO {
	if x == nil {
		return nil
	}
	return x.refd1e512
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ECDH_INFO) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refd1e512)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ECDH_INFO) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ECDH_INFO) Free() {
	if x != nil && x.allocsd1e512 != nil {
		x.allocsd1e512.(*cgoAllocMap).Free()
		x.refd1e512 = nil
	}
}

// NewECDH_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewECDH_INFORef(ref unsafe.Pointer) *ECDH_INFO {
	if ref == nil {
		return nil
	}
	obj := new(ECDH_INFO)
	obj.refd1e512 = (*C.WDRV_WINC_ECDH_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ECDH_INFO) PassRef() (*C.WDRV_WINC_ECDH_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd1e512 != nil {
		return x.refd1e512, nil
	}
	memd1e512 := allocECDH_INFOMemory(1)
	refd1e512 := (*C.WDRV_WINC_ECDH_INFO)(memd1e512)
	allocsd1e512 := new(cgoAllocMap)
	allocsd1e512.Add(memd1e512)

	var cpubKey_allocs *cgoAllocMap
	refd1e512.pubKey, cpubKey_allocs = x.PubKey.PassValue()
	allocsd1e512.Borrow(cpubKey_allocs)

	var ckey_allocs *cgoAllocMap
	refd1e512.key, ckey_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Key)), cgoAllocsUnknown
	allocsd1e512.Borrow(ckey_allocs)

	x.refd1e512 = refd1e512
	x.allocsd1e512 = allocsd1e512
	return refd1e512, allocsd1e512

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ECDH_INFO) PassValue() (C.WDRV_WINC_ECDH_INFO, *cgoAllocMap) {
	if x.refd1e512 != nil {
		return *x.refd1e512, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ECDH_INFO) Deref() {
	if x.refd1e512 == nil {
		return
	}
	x.PubKey = *NewEC_POINT_REPRef(unsafe.Pointer(&x.refd1e512.pubKey))
	x.Key = *(*[32]byte)(unsafe.Pointer(&x.refd1e512.key))
}

// allocECC_HANDSHAKE_INFOMemory allocates memory for type C.WDRV_WINC_ECC_HANDSHAKE_INFO in C.
// The caller is responsible for freeing the this memory via C.free.
func allocECC_HANDSHAKE_INFOMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfECC_HANDSHAKE_INFOValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfECC_HANDSHAKE_INFOValue = unsafe.Sizeof([1]C.WDRV_WINC_ECC_HANDSHAKE_INFO{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ECC_HANDSHAKE_INFO) Ref() *C.WDRV_WINC_ECC_HANDSHAKE_INFO {
	if x == nil {
		return nil
	}
	return x.ref435c2a3e
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *ECC_HANDSHAKE_INFO) SizeOf() uintptr {
	return unsafe.Sizeof(*x.ref435c2a3e)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *ECC_HANDSHAKE_INFO) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ECC_HANDSHAKE_INFO) Free() {
	if x != nil && x.allocs435c2a3e != nil {
		x.allocs435c2a3e.(*cgoAllocMap).Free()
		x.ref435c2a3e = nil
	}
}

// NewECC_HANDSHAKE_INFORef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewECC_HANDSHAKE_INFORef(ref unsafe.Pointer) *ECC_HANDSHAKE_INFO {
	if ref == nil {
		return nil
	}
	obj := new(ECC_HANDSHAKE_INFO)
	obj.ref435c2a3e = (*C.WDRV_WINC_ECC_HANDSHAKE_INFO)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ECC_HANDSHAKE_INFO) PassRef() (*C.WDRV_WINC_ECC_HANDSHAKE_INFO, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref435c2a3e != nil {
		return x.ref435c2a3e, nil
	}
	mem435c2a3e := allocECC_HANDSHAKE_INFOMemory(1)
	ref435c2a3e := (*C.WDRV_WINC_ECC_HANDSHAKE_INFO)(mem435c2a3e)
	allocs435c2a3e := new(cgoAllocMap)
	allocs435c2a3e.Add(mem435c2a3e)

	var cdata_allocs *cgoAllocMap
	ref435c2a3e.data, cdata_allocs = *(*[2]C.uint32_t)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs435c2a3e.Borrow(cdata_allocs)

	x.ref435c2a3e = ref435c2a3e
	x.allocs435c2a3e = allocs435c2a3e
	return ref435c2a3e, allocs435c2a3e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ECC_HANDSHAKE_INFO) PassValue() (C.WDRV_WINC_ECC_HANDSHAKE_INFO, *cgoAllocMap) {
	if x.ref435c2a3e != nil {
		return *x.ref435c2a3e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *ECC_HANDSHAKE_INFO) Deref() {
	if x.ref435c2a3e == nil {
		return
	}
	x.Data = *(*[2]uint32)(unsafe.Pointer(&x.ref435c2a3e.data))
}

// allocCIPHER_SUITE_CONTEXTMemory allocates memory for type C.WDRV_WINC_CIPHER_SUITE_CONTEXT in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCIPHER_SUITE_CONTEXTMemory(n int) unsafe.Pointer {
	mem := C.calloc(C.size_t(n), (C.size_t)(sizeOfCIPHER_SUITE_CONTEXTValue))
	if mem == nil {
		panic("memory alloc error")
	}
	return mem
}

const sizeOfCIPHER_SUITE_CONTEXTValue = unsafe.Sizeof([1]C.WDRV_WINC_CIPHER_SUITE_CONTEXT{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CIPHER_SUITE_CONTEXT) Ref() *C.WDRV_WINC_CIPHER_SUITE_CONTEXT {
	if x == nil {
		return nil
	}
	return x.refeaa2203b
}

// Sizeof returns the size of underlying reference to the C object in bytes.
func (x *CIPHER_SUITE_CONTEXT) SizeOf() uintptr {
	return unsafe.Sizeof(*x.refeaa2203b)
}

// Bytes returns a slice with its pointer set to the address of the underlying C object.
func (x *CIPHER_SUITE_CONTEXT) Bytes() []byte {
	ref, _ := x.PassRef()
	return unsafe.Slice((*byte)(unsafe.Pointer(ref)), unsafe.Sizeof(*ref))
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CIPHER_SUITE_CONTEXT) Free() {
	if x != nil && x.allocseaa2203b != nil {
		x.allocseaa2203b.(*cgoAllocMap).Free()
		x.refeaa2203b = nil
	}
}

// NewCIPHER_SUITE_CONTEXTRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCIPHER_SUITE_CONTEXTRef(ref unsafe.Pointer) *CIPHER_SUITE_CONTEXT {
	if ref == nil {
		return nil
	}
	obj := new(CIPHER_SUITE_CONTEXT)
	obj.refeaa2203b = (*C.WDRV_WINC_CIPHER_SUITE_CONTEXT)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CIPHER_SUITE_CONTEXT) PassRef() (*C.WDRV_WINC_CIPHER_SUITE_CONTEXT, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refeaa2203b != nil {
		return x.refeaa2203b, nil
	}
	memeaa2203b := allocCIPHER_SUITE_CONTEXTMemory(1)
	refeaa2203b := (*C.WDRV_WINC_CIPHER_SUITE_CONTEXT)(memeaa2203b)
	allocseaa2203b := new(cgoAllocMap)
	allocseaa2203b.Add(memeaa2203b)

	var cciperSuites_allocs *cgoAllocMap
	refeaa2203b.ciperSuites, cciperSuites_allocs = (C.uint32_t)(x.CiperSuites), cgoAllocsUnknown
	allocseaa2203b.Borrow(cciperSuites_allocs)

	x.refeaa2203b = refeaa2203b
	x.allocseaa2203b = allocseaa2203b
	return refeaa2203b, allocseaa2203b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CIPHER_SUITE_CONTEXT) PassValue() (C.WDRV_WINC_CIPHER_SUITE_CONTEXT, *cgoAllocMap) {
	if x.refeaa2203b != nil {
		return *x.refeaa2203b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *CIPHER_SUITE_CONTEXT) Deref() {
	if x.refeaa2203b == nil {
		return
	}
	x.CiperSuites = (uint32)(x.refeaa2203b.ciperSuites)
}
